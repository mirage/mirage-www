module People = struct
  type t = { name : string; uri : string option; email : string option }
end

module Blog = struct
  type t = {
    updated : string;
    authors : People.t list;
    subject : string;
    permalink : string;
    body : string;
  }

  let all =
    [
      {
        updated = {js|2022-02-10 17:00|js};
        authors =
          [
            {
              name = {js|Thomas Gazagnaire|js};
              uri = Some {js|https://gazagnaire.org|js};
              email = None;
            };
          ];
        subject = {js|Announcing MirageOS 4.0.0 Beta Release|js};
        permalink = {js|announcing-mirage-40-beta-release|js};
        body =
          {js|<p><strong>On behalf of the Mirage team, I am delighted to announce the beta release of MirageOS 4.0!</strong></p>
<p><a href="https://mirage.io">MirageOS</a> is a library operating system that constructs unikernels for secure, high-performance network applications across a variety of hypervisor and embedded platforms. For example, OCaml code can be developed on a standard OS, such as Linux or macOS, and then compiled into a fully standalone, specialised unikernel that runs under a Xen or KVM hypervisor. The MirageOS project also supplies several protocol and storage implementations written in pure OCaml, ranging from TCP/IP to TLS to a full Git-like storage stack.</p>
<p>The beta of the MirageOS 4.00 release contains:</p>
<ul>
<li><code>mirage.4.0.0~beta</code>: the CLI tool;
</li>
<li><code>ocaml-freestanding.0.7.0</code>: a libc-free OCaml runtime;
</li>
<li>and <code>solo5.0.7.0</code>: a cross-compiler for OCaml.
</li>
</ul>
<p>They are all available in <code>opam</code> by using:</p>
<pre><code>opam install 'mirage&gt;=4.0'
</code></pre>
<p><em>Note</em>: you need to explicitly add the <code>4.0&gt;=0</code> version here, otherwise <code>opam</code> will select the latest <code>3.*</code> stable release. For a good experience, check that at least version <code>4.0.0~beta3</code> is installed.</p>
<h2>New Features</h2>
<p>This new release of MirageOS adds systematic support for cross-compilation to all supported unikernel targets. This means that libraries that use C stubs (like Base, for example) can now seamlessly have those stubs cross-compiled to the desired target.  Previous releases of MirageOS required specific support to accomplish this by adding the stubs to a central package.</p>
<p>MirageOS implements cross-compilation using <em>Dune Workspaces</em>, which can take a whole collection of OCaml code (including all transitive dependencies) and compile it with a given set of C and OCaml compiler flags. This workflow also unlocks support for familiar IDE tools (such as <code>ocaml-lsp-server</code> and Merlin) while developing unikernels in OCaml. It makes day-to-day coding much faster because builds are decoupled from configuration and package updates. This means that live-builds, such as Dune's watch mode, now work fine even for exotic build targets!</p>
<p>A complete list of features can be found on the <a href="https://mirage.io/docs/mirage-4">MirageOS 4 release page</a>.</p>
<h2>Cross-Compilation and Dune Overlays</h2>
<p>This release introduces a significant change in the way MirageOS projects are compiled based on Dune Workspaces. This required implementing a new developer experience for Opam users in order to simplify cross-compilation of large OCaml projects.</p>
<p>That new tool, called <a href="https://github.com/ocamllabs/opam-monorepo">opam-monorepo</a> (née duniverse), separates package management from building the resulting source code. It is an Opam plugin that:</p>
<ul>
<li>creates a lock file for the project dependencies
</li>
<li>downloads and extracts the dependency sources locally
</li>
<li>sets up a Dune Workspace so that <code>dune build</code> builds everything in one go.
</li>
</ul>
<p><a href="https://asciinema.org/a/rRf6s8cNyHUbBsDDfZkBjkf7X?speed=2"><img src="https://asciinema.org/a/rRf6s8cNyHUbBsDDfZkBjkf7X.svg" alt="asciicast" /></a></p>
<p><code>opam-monorepo</code> is already available in Opam and can be used on many projects which use <code>dune</code> as a build system. However, as we don't expect the complete set of OCaml dependencies to use <code>dune</code>, we MirageOS maintainers are committed to maintaining patches to build the most common dependencies with <code>dune</code>. These packages are hosted in a separate <a href="https://github.com/mirage/opam-overlays">dune-universe/mirage-opam-overlays</a> repository, which can be used by <code>opam-monorepo</code> and is enabled by default when using the Mirage CLI tool.</p>
<h2>Next Steps</h2>
<p>Your feedback on this beta release is very much appreciated. You can follow the tutorials <a href="https://mirage.io/docs/mirage-4">here</a>. Issues are very welcome on our <a href="https://github.com/mirage/mirage/issues">bug-tracker</a>, or come find us on Matrix in the MirageOS channel: <a href="https://matrix.to/#/#mirageos:matrix.org">#mirageos:matrix.org</a>.</p>
<p>The <strong>final release</strong> will happen in about a month. This release will incorporate your early feedback. It will also ensure the existing MirageOS ecosystem is compatible with MirageOS 4 by reducing the overlay packages to the bare minimum. We also plan to write more on <code>opam-monorepo</code> and all the new things MirageOS 4.0 will bring.</p>
|js};
      };
      {
        updated = {js|2020-12-08 13:30|js};
        authors =
          [
            {
              name = {js|Hannes Mehnert|js};
              uri = Some {js|https://github.com/hannesm|js};
              email = Some {js|hm519@cam.ac.uk|js};
            };
          ];
        subject = {js|Announcing MirageOS 3.10|js};
        permalink = {js|announcing-mirage-310-release|js};
        body =
          {js|<p>IPv6 and dual (IPv4 and IPv6) stack support https://github.com/mirage/mirage/pull/1187 https://github.com/mirage/mirage/issues/1190</p>
<p>Since a long time, IPv6 code was around in our TCP/IP stack (thanks to @nojb who developed it in 2014). Some months ago, @hannesm and @MagnusS got excited to use it. After we managed to fix some bugs and add some test cases, and writing more code to setup IPv6-only and dual stacks, we are eager to share this support for MirageOS in a released version. We expect there to be bugs lingering around, but duplicate address detection (neighbour solicitation and advertisements) has been implemented, and (unless &quot;--accept-router-advertisement=false&quot;) router advertisements are decoded and used to configure the IPv6 part of the stack. Configuring a static IPv6 address is also possible (with
&quot;--ipv6=2001::42/64&quot;).</p>
<p>While at it, we unified the boot arguments between the different targets: namely, on Unix (when using the socket stack), you can now pass &quot;--ipv4=127.0.0.1/24&quot; to the same effect as the direct stack: only listen on 127.0.0.1 (the subnet mask is ignored for the Unix socket stack).</p>
<p>A dual stack unikernel has &quot;--ipv4-only=BOOL&quot; and &quot;--ipv6-only=BOOL&quot; parameters, so a unikernel binary could support both Internet Protocol versions, while the operator can decide which protocol version to use. I.e. now there are both development-time (stackv4 vs stackv6 vs stackv4v6) choices, as well as the run-time choice (via boot parameter).</p>
<p>I'm keen to remove the stackv4 &amp; stackv6 in future versions, and always develop with dual stack (leaving it to configuration &amp; startup time to decide whether to enable ipv4 and ipv6).</p>
<p>Please also note that the default IPv4 network configuration no longer uses 10.0.0.1 as default gateway (since there was no way to unset the default gateway https://github.com/mirage/mirage/issues/1147).</p>
<p>For unikernel developers, there are some API changes in the Mirage module</p>
<ul>
<li>New &quot;v4v6&quot; types for IP protocols and stacks
</li>
<li>The ipv6_config record was adjusted in the same fashion as the ipv4_config type: it is now a record of a network (V6.Prefix.t) and gateway (V6.t option)
</li>
</ul>
<p>Some parts of the Mirage_key module were unified as well:</p>
<ul>
<li>Arp.ip_address is available (for a dual Ipaddr.t)
</li>
<li>Arg.ipv6_address replaces Arg.ipv6 (for an Ipaddr.V6.t)
</li>
<li>Arg.ipv6 replaces Arg.ipv6_prefix (for a Ipaddr.V6.Prefix.t)
</li>
<li>V6.network and V6.gateway are available, mirroring the V4 submodule
</li>
</ul>
<p>If you're ready to experiment with the dual stack: below is a diff for our basic network example (from mirage-skeleton/device-usage/network) replacing IPv4 with a dual stack, and the tlstunnel unikernel commit
https://github.com/roburio/tlstunnel/commit/2cb3e5aa11fca4b48bb524f3c0dbb754a6c8739b
changed tlstunnel from IPv4 stack to dual stack.</p>
<pre><code>diff --git a/device-usage/network/config.ml b/device-usage/network/config.ml
index c425edb..eabc9d6 100644
--- a/device-usage/network/config.ml
+++ b/device-usage/network/config.ml
@@ -4,9 +4,9 @@ let port =
   let doc = Key.Arg.info ~doc:&quot;The TCP port on which to listen for
incoming connections.&quot; [&quot;port&quot;] in
   Key.(create &quot;port&quot; Arg.(opt int 8080 doc))

-let main = foreign ~keys:[Key.abstract port] &quot;Unikernel.Main&quot; (stackv4
@-&gt; job)
+let main = foreign ~keys:[Key.abstract port] &quot;Unikernel.Main&quot;
(stackv4v6 @-&gt; job)

-let stack = generic_stackv4 default_network
+let stack = generic_stackv4v6 default_network

 let () =
   register &quot;network&quot; [
diff --git a/device-usage/network/unikernel.ml
b/device-usage/network/unikernel.ml
index 5d29111..1bf1228 100644
--- a/device-usage/network/unikernel.ml
+++ b/device-usage/network/unikernel.ml
@@ -1,19 +1,19 @@
 open Lwt.Infix

-module Main (S: Mirage_stack.V4) = struct
+module Main (S: Mirage_stack.V4V6) = struct

   let start s =
     let port = Key_gen.port () in
-    S.listen_tcpv4 s ~port (fun flow -&gt;
-        let dst, dst_port = S.TCPV4.dst flow in
+    S.listen_tcp s ~port (fun flow -&gt;
+        let dst, dst_port = S.TCP.dst flow in
         Logs.info (fun f -&gt; f &quot;new tcp connection from IP %s on port %d&quot;
-                  (Ipaddr.V4.to_string dst) dst_port);
-        S.TCPV4.read flow &gt;&gt;= function
+                  (Ipaddr.to_string dst) dst_port);
+        S.TCP.read flow &gt;&gt;= function
         | Ok `Eof -&gt; Logs.info (fun f -&gt; f &quot;Closing connection!&quot;);
Lwt.return_unit
-        | Error e -&gt; Logs.warn (fun f -&gt; f &quot;Error reading data from
established connection: %a&quot; S.TCPV4.pp_error e); Lwt.return_unit
+        | Error e -&gt; Logs.warn (fun f -&gt; f &quot;Error reading data from
established connection: %a&quot; S.TCP.pp_error e); Lwt.return_unit
         | Ok (`Data b) -&gt;
           Logs.debug (fun f -&gt; f &quot;read: %d bytes:\\n%s&quot; (Cstruct.len b)
(Cstruct.to_string b));
-          S.TCPV4.close flow
+          S.TCP.close flow
       );

     S.listen s
</code></pre>
<p>Other bug fixes include https://github.com/mirage/mirage/issues/1188 (in https://github.com/mirage/mirage/pull/1201) and adapt to charrua 1.3.0 and arp 2.3.0 changes (https://github.com/mirage/mirage/pull/1199).</p>
|js};
      };
      {
        updated = {js|2020-10-27 15:00|js};
        authors =
          [
            {
              name = {js|Martin Lucina|js};
              uri = Some {js|https://lucina.net/|js};
              email = Some {js|martin@lucina.net|js};
            };
            {
              name = {js|Hannes Mehnert|js};
              uri = Some {js|https://github.com/hannesm|js};
              email = Some {js|hm519@cam.ac.uk|js};
            };
          ];
        subject = {js|Announcing MirageOS 3.9.0|js};
        permalink = {js|announcing-mirage-39-release|js};
        body =
          {js|<p>We are pleased to announce the release of MirageOS 3.9.0.</p>
<p>Our last release announcement was for <a href="https://mirage.io/blog/announcing-mirage-36-release">MirageOS 3.6.0</a>, so we will also cover changes since 3.7.x and 3.8.x in this announcement.</p>
<p>New features:</p>
<ul>
<li>The Xen backend has been <a href="https://github.com/mirage/mirage/issues/1159">re-written from scratch</a> to be based on Solo5, and now supports PVHv2 on Xen 4.10 or higher, and QubesOS 4.0.
</li>
<li>As part of this re-write, the existing Mini-OS based implementation has been retired, and all non-UNIX backends now use a unified OCaml runtime based on <code>ocaml-freestanding</code>.
</li>
<li>OCaml runtime settings settable via the <code>OCAMLRUNPARAM</code> environment variable are now exposed as unikernel boot parameters. For details, refer to <a href="https://github.com/mirage/mirage/pull/1180">#1180</a>.
</li>
</ul>
<p>Security posture improvements:</p>
<ul>
<li>With the move to a unified Solo5 and ocaml-freestanding base MirageOS unikernels on Xen gain several notable improvements to their overall security posture such as SSP for all C code, W^X, and malloc heap canaries. For details, refer to the mirage-xen 6.0.0 release <a href="https://github.com/mirage/mirage-xen/releases/tag/v6.0.0">announcement</a>.
</li>
</ul>
<p>API breaking changes:</p>
<ul>
<li>Several Xen-specific APIs have been removed or replaced, unikernels using these may need to be updated. For details, refer to the mirage-xen 6.0.0 release <a href="https://github.com/mirage/mirage-xen/releases/tag/v6.0.0">announcement</a>.
</li>
</ul>
<p>Other notable changes:</p>
<ul>
<li><code>Mirage_runtime</code> provides event loop enter and exit hook registration (<a href="https://github.com/mirage/mirage/pull/1010">#1010</a>).
</li>
<li>All MirageOS backends now behave similarly on a successful exit of the unikernel: they call <code>exit</code> with the return value 0, thus <code>at_exit</code> handlers are now executed (<a href="https://github.com/mirage/mirage/pull/1011">#1011</a>).
</li>
<li>The unix backend used a toplevel exception handler, which has been removed. All backends now behave equally with respect to exceptions.
</li>
<li>Please note that the <code>Mirage_net.listen</code> function still installs an exception handler, which will be removed in a future release. The out of memory exception is no longer caught by <code>Mirage_net.listen</code> (<a href="https://github.com/mirage/mirage/issues/1036">#1036</a>).
</li>
<li>To reduce the number of OPAM packages, the <code>mirage-*-lwt</code> packages are now deprecated. <code>Mirage_net</code> (and others) now use <code>Lwt.t</code> directly, and their <code>buffer</code> type is <code>Cstruct.t</code> (<a href="https://github.com/mirage/mirage/issues/1004">#1004</a>).
</li>
<li>OPAM files generated by <code>mirage configure</code> now include opam build and installation instructions, and also an URL to the Git <code>origin</code> (<a href="https://github.com/mirage/mirage/pull/1022">#1022</a>).
</li>
</ul>
<p>Known issues:</p>
<ul>
<li><code>mirage configure</code> fails if the unikernel is under version control and no <code>origin</code> remote is present (<a href="https://github.com/mirage/mirage/issues/1188">#1188</a>).
</li>
<li>The Xen backend has issues with event delivery if built with an Alpine Linux GCC toolchain. As a work-around, please use a Fedora or Debian based toolchain.
</li>
</ul>
<p>Acknowledgements:</p>
<ul>
<li>Thanks to Roger Pau Monné, Andrew Cooper and other core Xen developers for help with understanding the specifics of how Xen PVHv2 works, and how to write an implementation from scratch.
</li>
<li>Thanks to Marek Marczykowski-Górecki for help with the QubesOS specifics, and for forward-porting some missing parts of PVHv2 to QubesOS version of Xen.
</li>
<li>Thanks to @palainp on Github for help with testing on QubesOS.
</li>
</ul>
|js};
      };
      {
        updated = {js|2020-05-20 14:00|js};
        authors =
          [
            {
              name = {js|Hannes Mehnert|js};
              uri = Some {js|https://github.com/hannesm|js};
              email = Some {js|hm519@cam.ac.uk|js};
            };
          ];
        subject = {js|TLS 1.3 support for MirageOS|js};
        permalink = {js|tls-1-3-mirageos|js};
        body =
          {js|<p>We are pleased to announce that <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#TLS_1.3">TLS 1.3</a> support for MirageOS is available. With
mirage 3.7.7 and tls 0.12 the <a href="https://tools.ietf.org/html/rfc8446">Transport Layer Security (TLS) Protocol Version 1.3</a>
is available in all MirageOS unikernels, including on our main website. If you're reading this, you've likely established a TLS 1.3 connection already :)</p>
<p>Getting there was some effort: we now embed the Coq-verified <a href="https://github.com/mirage/fiat/">fiat</a>
library (from <a href="https://github.com/mit-plv/fiat-crypto/">fiat-crypto</a>) for the P-256 elliptic curve, and the F*-verified <a href="https://github.com/mirage/hacl">hacl</a>
library (from <a href="https://project-everest.github.io/">Project Everest</a>) for the X25519 elliptic curve to establish 1.3 handshakes with ECDHE.</p>
<p>Part of our TLS 1.3 stack is support for pre-shared keys, and 0 RTT. If you're keen to try these features, please do so and report any issues you encounter <a href="https://github.com/mirleft/ocaml-tls">to our issue tracker</a>.</p>
<p>We are still lacking support for RSA-PSS certificates and EC certificates, post-handshake authentication, and the chacha20-poly1305 ciphersuite. There is also a <a href="https://github.com/mirage/hacl/issues/32">minor symbol clash</a> with the upstream F* C bindings which we are aware of. We will continue to work on these, and patches are welcome.</p>
|js};
      };
      {
        updated = {js|2020-01-08 20:00|js};
        authors =
          [
            {
              name = {js|Damien Leloup|js};
              uri =
                Some {js|https://www.lemonde.fr/signataires/damien-leloup/|js};
              email = None;
            };
          ];
        subject = {js|Hackers and climate activists join forces in Leipzig|js};
        permalink = {js|ccc-2019-leipzig|js};
        body =
          {js|<p><em>By Damien Leloup, special correspondent, Le Monde. Originally <a href="https://www.lemonde.fr/pixels/article/2019/12/30/a-leipzig-hackers-et-militants-pour-le-climat-font-front-commun_6024362_4408996.html">published</a> by Le Monde on December 30, 2019. English translation by the MirageOS Core Team.</em></p>
<p><strong>The Chaos Communication Congress, the world's largest self-managed event dedicated to IT security, hosted its 36th edition this weekend in Germany.</strong></p>
<p>In front of Leipzig station, around fifty students and high school students are gathered.  It's Sunday, but the local branch of the Fridays for Future movement, which organizes demonstrations on Fridays at the call of activist Greta Thunberg, made an exception to its usual calendar to take advantage of the presence, a few kilometers from there, of the Chaos Communication Congress (CCC).</p>
<p>Organized each year for thirty-six years, this gigantic gathering of hackers and activists - 18,000 participants, dozens of conference talks around the clock - invades the Leipzig convention center for four days, in an atmosphere that is both anarcho-libertarian and very family oriented.  For the first time, the slogan of the 2019 edition is devoted to the environment: “Resource exhaustion”, a reference both to a computer <a href="https://en.wikipedia.org/wiki/Resource_exhaustion_attack">attack technique</a> and to the preservation of the planet.</p>
<p><em>&quot;It makes sense: it's a major issue, and the environmental movement is a highlight of the year, isn't it?&quot;</em>, notes, hair dyed pink and megaphone in hand, Rune, one of the organizers of the event. <em>“In any case, we are very happy that the CCC opened its doors to us and supports us.&quot;</em></p>
<p>The conference program gave pride of place to ecological themes and organizations such as Fridays for Future or Extinction Rebellion. These themes were all features in the main talks.  The audience for the event, marked on the far left, is quite sensitive to environmental issues.  <a href="https://www.fridaysforfuture.org/">Fridays for Future's</a> review of the year was sold out;  the track where some scientists explained how they build their climate models was full and was not able to host all the attendees.</p>
<h2>Safety of power plants and the right to repair</h2>
<p>But if the CCC has given a lot of space to environmental issues, it has done it in its own way.  In this mecca of cyber-security, we could for example discover long lists of vulnerabilities affecting the on-board systems used to manage the turbines of power plants. <em>Do not</em> panic: <em>&quot;These flaws do not block a power plant, or cut the power of a city,&quot;</em> relativized Radu Motspan, the author of the study.  Some of them have been corrected;  for others, it is up to plant managers to carry out verifications.  The researcher and his associates produced a small turnkey guide to help them: <em>“No need to hire expensive consultants, you can do everything yourself.&quot;</em></p>
<p>This “do it yourself” spirit, omnipresent in hacker culture in general and at the CCC in particular, easily lends itself to an environmental translation.  The collective <a href="https://runder-tisch-reparatur.de/">Runder Tisch Reparatur</a>, which campaigns for the adoption at European level of a &quot;right to repair&quot;, was thus invited for the first time to the conference.  The philosophy of the movement, which aims above all to reduce the amount of waste produced by obsolescence whether or not it is programmed, is very similar to that of the free software movement, say Eduard and Erik, who run the stand of the association. <em>&quot;An object that you cannot repair does not really belong to you,&quot;</em> they believe, just as the promoters of free software believe that software that you cannot modify yourself deprives you of certain freedoms.</p>
<p>But the main issue, at the heart of many talks during the four days of the CCC, is that of the energy impact of the Internet.  No one in the aisles of the Leipzig congress center plans to reduce their use of the Internet;  but everyone concedes that the network consumes a lot of electricity unnecessarily, or uses too much fossil energy.  <em>&quot;There are simple things to do to improve the carbon footprint of a site or service,&quot;</em> said Chris Adams, environmental activist and member of the Green Web Foundation.  <em>“If your service uses Amazon Web Service [AWS, a very popular cloud service], you can choose the data center you want to use, for example.  The one assigned to you by default may be in a country that produces little renewable electricity and uses a lot of coal for its power plants… ”</em></p>
<p>Existing non-digital systems (like boilers) already have ways to function more efficiently, such as off-peak hours at night, when electricity is both cheaper and more eco-friendly. There are equivalent options for more modern, digital systems, for instance: Chris Adams advocates the use of the <a href="http://ceur-ws.org/Vol-2382/ICT4S2019_paper_28.pdf">Low Carbon Kubernetes Scheduler</a>, an orchestration tool which allows to optimise the power consumption of a server in order to reduce its environmental impact.</p>
<h2>Safety and minimum consumption, get the best of both worlds</h2>
<p>Despite everything, the “greenest” electricity remains that which we do not consume in the first place.  There too, promising solutions exist: <a href="https://hannes.nqsb.io/">Hannes Mehnert</a>, a German computer scientist, presented at the opening of the CCC the MirageOS project, an operating system for ultra-minimalist servers, coded in a language renowned for its lightness, and which runs each process in a dedicated virtual machine.  A radical approach - and reserved for connoisseurs - which allows the software to embed only the bare minimum of lines of code in each compiled version. <em>&quot;Reducing complexity mathematically reduces the number of calculation operations required,&quot;</em> explains Mehnert.  Result: <em>&quot;A carbon footprint that drops drastically, with ten times less computing power used by the processor, and up to twenty-five times less memory used&quot;</em>, according to his measurements.</p>
<p>Above all, and this is a strong argument at a conference dedicated to computer security, minimalism is also a real advantage in terms of potential vulnerabilities: the more compact the code is, the less it risks containing flaws or errors.  And such systems are also better protected and safer than more conventional systems, as they are not vulnerable to memory-safety issues.</p>
<p>But the collaboration between environmentalists and privacy advocates seemed much broader than just focusing on technical issues. That mix was everywhere: for instance the corridor walls had graffiti concerned with the the excessive consumption of CO2 on the planet close to others highlighting the fact that every human being generates, on average, 1.7 MB of data per second. The posters of the anarchist or anti-fascist movements were also mixed with the flyers of the collective Hackers against <a href="https://hacc.uber.space/Main_Page">Climate Change</a>, which attracted the curious with a joke typical of the place: <em>&quot;cli / mate crisis is real&quot;</em>, in reference to Club-Mate, an ubiquitous drink at the event.</p>
<p>This community of views between hackers and climate activists comes as little surprise in Germany, where both movements are very present, and even less in Leipzig, the flagship city of the former GDR where pre-Internet mass surveillance tools from the Stasi were also directed against environmental activists in the 1980s. Some environmental movements feel naturally close to the anarchist spirit of the German hackers of the Chaos Computer Club, which organizes the CCC: a talk by <a href="https://rebellion.earth/">Extinction Rebellion</a> detailed the security measures they took to ensure their privacy, and how they didn't depend on third-party tools from Facebook, Google or Amazon - responsible, in their eyes, both for mass surveillance and <em>green washing</em>.</p>
<p>However, in this atmosphere of global collaboration some questions remained unanswered.  In some specific cases, better IT security can also consume more resources.  A talk dedicated to encrypted messaging thus presented many tools which make it possible to reinforce the confidentiality of exchanges, but also require using more computing power, to encrypt or decrypt messages, or even request the sending of large quantities of data to scramble the origin or volume of a message.  This first CCC under the sign of environmental protection did not really address this contradiction - pending, perhaps, a next edition?</p>
|js};
      };
      {
        updated = {js|2019-11-26 15:00|js};
        authors =
          [
            {
              name = {js|Anil Madhavapeddy|js};
              uri = Some {js|http://anil.recoil.org|js};
              email = Some {js|anil@recoil.org|js};
            };
            {
              name = {js|Thomas Gazagnaire|js};
              uri = Some {js|http://gazagnaire.org|js};
              email = Some {js|thomas@gazagnaire.org|js};
            };
          ];
        subject = {js|Announcing Irmin 2.0.0|js};
        permalink = {js|introducing-irmin-v2|js};
        body =
          {js|<p>We are pleased to announce <a href="https://github.com/mirage/irmin/releases">Irmin
2.0.0</a>, a major release of the
Git-like distributed branching and storage substrate that underpins MirageOS.
We began the release process for all the components that make up Irmin <a href="https://tarides.com/blog/2019-05-13-on-the-road-to-irmin-v2">back in
May 2019</a>, and
there have been close to 1000 commits since Irmin 1.4.0 release back in June
2018. To celebrate this milestone, we have a new logo and opened a dedicated
website: <a href="https://irmin.org">irmin.org</a>.</p>
<p>You can read more details about the new features in the <a href="https://tarides.com/blog/2019-11-21-irmin-v2">Irmin v2 blog
post</a>.  Enjoy the new release,
and stay tuned for the upcoming Wodan integration in 2020 that will be a stable
filesystem for the hypervisor targets for MirageOS that do not have a
conventional OS kernel underneath them!</p>
|js};
      };
      {
        updated = {js|2019-10-18 15:00|js};
        authors =
          [
            {
              name = {js|Martin Lucina|js};
              uri = Some {js|https://lucina.net/|js};
              email = Some {js|martin@lucina.net|js};
            };
          ];
        subject = {js|Announcing MirageOS 3.6.0|js};
        permalink = {js|announcing-mirage-36-release|js};
        body =
          {js|<p>We are pleased to announce the release of MirageOS 3.6.0. This release updates MirageOS to support <a href="https://github.com/Solo5/solo5">Solo5</a> 0.6.0 and later.</p>
<p>New features:</p>
<ul>
<li>Support for the Solo5 <code>spt</code> (sandboxed process tender) target via <code>mirage configure -t spt</code>. The <code>spt</code> target runs MirageOS unikernels in a minimal strict seccomp sandbox on Linux <code>x86_64</code>, <code>aarch64</code> and <code>ppc64le</code> hosts.
</li>
<li>Support for the Solo5 <em>application manifest</em>, enabling support for multiple network and block storage devices on the <code>hvt</code>, <code>spt</code> and <code>muen</code> targets. The <code>genode</code> and <code>virtio</code> targets are still limited to using a single network or block storage device.
</li>
<li>Several notable security enhancements to Solo5 targets, such as enabling stack smashing protection throughout the toolchain by default and improved page protections on some targets.  For details, please refer to the Solo5 0.6.0 <a href="https://github.com/Solo5/solo5/releases/tag/v0.6.0">release notes</a>.
</li>
</ul>
<p>Additional user-visible changes:</p>
<ul>
<li>Solo5 0.6.0 has removed the compile-time specialization of the <code>solo5-hvt</code> tender. As a result, a <code>solo5-hvt</code> binary is no longer built at <code>mirage build</code> time. Use the <code>solo5-hvt</code> binary installed in your <code>$PATH</code> by OPAM to run the unikernel.
</li>
<li><code>mirage build</code> now produces silent <code>ocamlbuild</code> output by default. To get the old behaviour, run with <code>--verbose</code> or set the log level to <code>info</code> or <code>debug</code>.
</li>
<li>New functions <code>Mirage_key.is_solo5</code> and <code>Mirage_key.is_xen</code>, analogous to <code>Mirage_key.is_unix</code>.
</li>
</ul>
<p>Thanks to Hannes Mehnert for help with the release engineering for MirageOS 3.6.0.</p>
|js};
      };
      {
        updated = {js|2019-04-26 00:00|js};
        authors =
          [
            {
              name = {js|Thomas Leonard|js};
              uri = Some {js|http://roscidus.com/blog/|js};
              email = Some {js|talex5@gmail.com|js};
            };
          ];
        subject = {js|MirageOS security advisory 02: mirage-xen < 3.3.0|js};
        permalink = {js|MSA02|js};
        body =
          {js|<h2>MirageOS Security Advisory 02 - grant unshare vulnerability in mirage-xen</h2>
<ul>
<li>Module:       mirage-xen
</li>
<li>Announced:    2019-04-25
</li>
<li>Credits:      Thomas Leonard, Mindy Preston
</li>
<li>Affects:      mirage-xen &lt; 3.3.0,
mirage-block-xen &lt; 1.6.1,
mirage-net-xen &lt; 1.10.2,
mirage-console &lt; 2.4.2,
ocaml-vchan &lt; 4.0.2,
ocaml-gnt (no longer supported)
</li>
<li>Corrected:    2019-04-22: mirage-xen 3.4.0,
2019-04-05: mirage-block-xen 1.6.1,
2019-04-02: mirage-net-xen 1.10.2,
2019-03-27: mirage-console 2.4.2,
2019-03-27: ocaml-vchan 4.0.2
</li>
</ul>
<p>For general information regarding MirageOS Security Advisories,
please visit <a href="https://mirage.io/security">https://mirage.io/security</a>.</p>
<h3>Background</h3>
<p>MirageOS is a library operating system using cooperative multitasking, which can
be executed as a guest of the Xen hypervisor. Virtual machines running on a Xen
host can communicate by sharing pages of memory. For example, when a Mirage VM
wants to use a virtual network device provided by a Linux dom0:</p>
<ol>
<li>The Mirage VM reserves some of its memory for this purpose and writes an entry
to its <em>grant table</em> to say that dom0 should have access to it.
</li>
<li>The Mirage VM tells dom0 (via XenStore) about the grant.
</li>
<li>dom0 asks Xen to map the memory into its address space.
</li>
</ol>
<p>The Mirage VM and dom0 can now communicate using this shared memory.
When dom0 has finished with the memory:</p>
<ol>
<li>dom0 tells Xen to unmap the memory from its address space.
</li>
<li>dom0 tells the Mirage VM that it no longer needs the memory.
</li>
<li>The Mirage VM removes the entry from its grant table.
</li>
<li>The Mirage VM may reuse the memory for other purposes.
</li>
</ol>
<h3>Problem Description</h3>
<p>Mirage removes the entry by calling the <a href="https://github.com/mirage/mini-os/blob/94cb25eb73e58e5c825c1ad5f6cf3d2647603a50/gnttab.c#L98">gnttab_end_access</a> function in Mini-OS.
This function checks whether the remote domain still has the memory mapped. If so,
it returns 0 to indicate that the entry cannot be removed yet. To make this function
available to OCaml code, the <a href="https://github.com/mirage/mirage-xen/blob/v3.2.0/bindings/gnttab_stubs.c#L227">stub_gntshr_end_access</a> C stub in mirage-xen wrapped this
with the OCaml calling conventions. Unfortunately, it ignored the return code and reported
success in all cases.</p>
<h3>Impact</h3>
<p>A malicious VM can tell a MirageOS unikernel that it has finished using some
shared memory while it is still mapped. The Mirage unikernel will think that
the unshare operation has succeeded and may reuse the memory, or allow it to be
garbage collected. The malicious VM will still have access to the memory.</p>
<p>In many cases (such as in the example above) the remote domain will be dom0,
which is already fully trusted. However, if a unikernel shares memory with an
untrusted domain then there is a problem.</p>
<h3>Workaround</h3>
<p>No workaround is available.</p>
<h3>Solution</h3>
<p>Returning the result from the C stub required changes to the OCaml grant API to
deal with the result. This turned out to be difficult because, for historical
reasons, the OCaml part of the API was in the ocaml-gnt package while the C stubs
were in mirage-xen, and because the C stubs are also shared with the Unix backend.</p>
<p>We instead created a <a href="https://github.com/mirage/mirage-xen/pull/9">new grant API</a> in mirage-xen, migrated all existing
Mirage drivers to use it, and then dropped support for the old API.
mirage-xen 3.3.0 added support for the new API and 3.4.0 removed support for the
old one.</p>
<p>The recommended way to upgrade is:</p>
<pre><code class="language-bash">opam update
opam upgrade mirage-xen
</code></pre>
<h3>Correction details</h3>
<p>The following PRs were part of the fix:</p>
<ul>
<li><a href="https://github.com/mirage/mirage-xen/pull/9">mirage-xen/pull/9</a> - Add grant-handling code to OS.Xen
</li>
<li><a href="https://github.com/mirage/mirage-net-xen/pull/85">mirage-net-xen/pull/85</a> - Use new OS.Xen API for grants
</li>
<li><a href="https://github.com/mirage/ocaml-vchan/pull/125">ocaml-vchan/pull/125</a> - Update to new OS.Xen grant API
</li>
<li><a href="https://github.com/mirage/mirage-block-xen/pull/79">mirage-block-xen/pull/79</a> - Port to new grant interface provided by mirage-xen
</li>
<li><a href="https://github.com/mirage/mirage-console/pull/75">mirage-console/pull/75</a> - Use new grant interface in mirage-xen
</li>
<li><a href="https://github.com/mirage/mirage-xen/pull/12">mirage-xen/pull/12</a> - Drop support for old ocaml-gnt package
</li>
</ul>
<h3>References</h3>
<p>You can find the latest version of this advisory online at
<a href="https://mirage.io/blog/MSA02">https://mirage.io/blog/MSA02</a>.</p>
<p>This advisory is signed using OpenPGP, you can verify the signature
by downloading our public key from a keyserver (<code>gpg --recv-key 4A732D757C0EDA74</code>),
downloading the raw markdown source of this advisory from
<a href="https://raw.githubusercontent.com/mirage/mirage-www/master/tmpl/advisories/02.txt.asc">GitHub</a>
and executing <code>gpg --verify 02.txt.asc</code>.</p>
|js};
      };
      {
        updated = {js|2019-04-03 16:00|js};
        authors =
          [
            {
              name = {js|Hannes Mehnert|js};
              uri = Some {js|https://github.com/hannesm|js};
              email = Some {js|hm519@cam.ac.uk|js};
            };
          ];
        subject = {js|MirageOS Spring 2019 hack retreat roundup|js};
        permalink = {js|2019-spring-retreat-roundup|js};
        body =
          {js|<p>Early March 2019, 31 MirageOS hackers gathered again in Marrakesh for our bi-annual hack retreat. We'd like to thank our amazing hosts, and everyone who participated on-site or remotely, and especially those who wrote up their experiences.
<img src="/graphics/spring2019.jpg" style="glot:right; padding: 15px" /></p>
<p>On this retreat, we ate our own dogfood, and used our MirageOS <a href="https://github.com/mirage/mirage-skeleton/tree/master/applications/dhcp">DHCP</a>, <a href="https://github.com/roburio/unikernels/tree/master/resolver">recursive DNS resolver</a>, and <a href="https://github.com/roburio/caldav">CalDAV</a> unikernels as isolated virtual machines running on a <a href="https://pcengines.ch/apu2c4.htm">PC Engines APU</a> with <a href="https://freebsd.org">FreeBSD</a> as host system. The CalDAV server persisted its data in a git repository on the host system, using the raw git protocol for communication, the smart HTTP protocol could have been used as well. Lynxis wrote a <a href="https://lunarius.fe80.eu/blog/mirageos-2019.html">detailed blog post about our uplink situation</a>.</p>
<p>Lots of interesting discussions took place, code was developed, knowledge was exchanged, and issues were solved while we enjoyed the sun and the Moroccan food. The following list is not exhaustive, but gives an overview what was pushed forward.</p>
<h2><a href="https://github.com/rlepigre/ocaml-imagelib">Imagelib</a></h2>
<p>Imagelib is a library that can parse several image formats, and <a href="https://github.com/cfcs/eye-of-mirage">eye-of-mirage</a> uses it to display those images in a <a href="https://github.com/cfcs/mirage-framebuffer/">framebuffer</a>.</p>
<p>During the retreat, imagelib was extended with <a href="https://github.com/rlepigre/ocaml-imagelib/pull/22">support for the BMP format</a>, it's <a href="https://github.com/rlepigre/ocaml-imagelib/pull/23">build system was revised to split off Unix-dependent functionality</a>, and preliminary support for the GIF format was implemented.</p>
<h2><a href="https://github.com/kit-ty-kate/ocaml-activitypub">ActivityPub</a></h2>
<p>ActivityPub is an open, decentralized social networking protocol, as used by <a href="https://mastodon.social">mastodon</a>. It provides a client/server API for creating, updating, and deleting content, and a federated server-to-server API for notifications and content delivery. During the retreat, an initial prototype of a protocol implementation was drafted.</p>
<h2><a href="https://github.com/ocaml/opam">opam</a></h2>
<p>Opam, the OCaml package manager, was extended in several directions:</p>
<ul>
<li><a href="https://github.com/rjbou/opam/tree/depext">External (OS package system) dependency integration</a>
</li>
<li><a href="https://github.com/ocaml/opam/pull/3777">Interleaving download with build/install actions</a>
</li>
<li><a href="https://github.com/ocaml/opam/pull/3778">Generalisation of the job scheduler</a>
</li>
<li><a href="https://github.com/ocaml/opam/pull/3776">JSON serialisation, including crowbar round-trip tests</a>
</li>
<li>Plugin evaluating (binary) <a href="https://reproducible-builds.org/">reproducibility</a> of opam packages
</li>
<li>some smaller cleanup PRs (<a href="https://github.com/ocaml/opam/pull/3781">return values</a>, <a href="https://github.com/ocaml/opam/pull/3783">locking code</a>)
</li>
</ul>
<h2><a href="https://github.com/Armael/marracheck/">marracheck</a></h2>
<p>Work was started on a new utility to install as many opam packages as possible on a machine (there just wasn't enough choice with <a href="https://github.com/OCamlPro/opam-builder">opam-builder</a>, <a href="https://github.com/damiendoligez/opamcheck">opamcheck</a> and <a href="https://github.com/kit-ty-kate/opam-check-all">opam-check-all</a>). It uses opam-lib and Z3 to accomplish this.</p>
<h2><a href="https://github.com/hannesm/conex">Conex</a></h2>
<p>Conex is used for signing community repositories, esp. the opam-repository. Any opam package author can cryptographically sign their package releases, and users can verify that the downloaded tarball and build instructions are identical to what the author intended.</p>
<p>Conex has been developed since 2015, but is not yet widely deployed. We extended <a href="https://github.com/ocaml/opam-publish">opam-publish</a> to invoke the <code>conex_targets</code> utility and sign before opening a pull request on the opam-repository.</p>
<h2><a href="https://github.com/clecat/colombe">SMTP</a></h2>
<p>The simple mail transfer protocol is an Internet standard for sending and receiving eMail. Our OCaml implementation has been improved, and it is possible to send eMails from OCaml code now.</p>
<h2><a href="https://github.com/anmonteiro/ocaml-h2">HTTP2</a></h2>
<p>The hypertext transfer protocol is an Internet standard widely used for browsing the world wide web. HTTP 1.1 is a line-based protocol which was specified 20 years ago. HTTP2 is an attempt to fix various shortcomings, and uses a binary protocol with multiplexing, priorities, etc. An OCaml implementation of HTTP2 has been actively worked on in Marrakesh.</p>
<h2><a href="https://github.com/mirage/irmin">Irmin</a></h2>
<p>Irmin is a distributed database that follows the same design principles as git. Soon, Irmin 2.0 will be released, which includes GraphQL, HTTP, chunk support, and can use the git protocol for interoperability. Irmin provides a key-value interface for MirageOS.</p>
<h2>OCaml compiler</h2>
<p>Some hints on type errors for <a href="https://github.com/ocaml/ocaml/pull/2301">int literals</a> and <a href="https://github.com/ocaml/ocaml/pull/2307">int operators</a> were developed and merged to the OCaml compiler.</p>
<pre><code># 1.5 +. 2;;
         ^
Error: This expression has type int but an expression was expected of type
         float
       Hint: Did you mean `2.'?

# 1.5 + 2.;;
  ^^^ ^
Error: This expression has type float but an expression was expected of type
         int
Line 1, characters 4-5:
  Hint: Did you mean to use `+.'?
</code></pre>
<p>Also, the <a href="https://github.com/ocaml/ocaml/pull/608">whole program dead code elimination</a> PR was rebased onto trunk.</p>
<h2>BGP / lazy trie</h2>
<p>The <a href="https://github.com/mor1/mrt-format">mrt-format</a> library which can parse multi-threaded routing toolkit traces, has been adapted to the modern OCaml ecosystem. The <a href="https://github.com/jimyuan1995/Mirage-BGP">border gateway protocol (BGP)</a> library was slightly updated, one of its dependencies, <a href="https://github.com/mirage/ocaml-lazy-trie">lazy-trie</a> was adapted to the modern ecosystem as well.</p>
<h2>Xen PVH</h2>
<p>Xen provides several modes for virtualization.  MirageOS's first non-Unix target was the para-virtualized (PV) mode for Xen, which does not require hardware support from the hypervisor's host operating system but has a weak security profile (static mapping of addresses, large attack surface).  However, PV mode provides an attractive target for unikernels because it provides a simple software-based abstraction for dealing with drivers and a simple memory model; this is in contrast to hardware-virtualization mode, which provides greater security but requires more work from the guest OS.</p>
<p>A more modern virtualization mode combining the virtues of both approaches is PVH (formerly referred to as HVMLite), which is not yet supported by MirageOS.  Marek Marczykowski-Górecki from the <a href="https://qubes-os.org">QubesOS</a> project visited to help us bring PVH support to the <a href="https://xenproject.org/developers/teams/unikraft/">unikraft project</a>, a common platform for building unikernels which we hope to use for MirageOS's Xen support in the future.</p>
<p>During the retreat, lots of bugs porting MirageOS to PVH were solved. It boots and crashes now!</p>
<h2>Learn OCaml as a unikernel</h2>
<p>The platform learn OCaml embeds an editor, top-level, and exercises into a HTTP server, and allows students to learn OCaml, and submit solutions via the web interface, where an automated grader runs unit tests etc. to evaluate the submitted solutions. Teachers can assign mandatory exercises, and have an overview how the students are doing. Learn OCaml used to be executable only on a Unix host, but is now beeing ported into a MirageOS unikernel, executable as a standalone virtual machine.</p>
<h2>Network device driver (ixy)</h2>
<p>The ixy network driver supports Intel 82599 network interface cards, and <a href="https://github.com/ixy-languages/ixy.ml">is implemented in OCaml</a>. Its performance has been improved, including several failing attempts which degraded its performance. Also, <a href="https://github.com/mirage/mirage/pull/977">it has been integrated into the mirage tool</a> and is usable as a <a href="https://github.com/mirage/mirage-net">mirage-net</a> implementation.</p>
<h2>DNS client API</h2>
<p>Our proposed API is <a href="https://github.com/roburio/udns/blob/09c5e3c74c92505ec97f2a16818cc8a030e2868f/client/udns_client_flow.mli#L53-L80">described here</a>. Unix, Lwt, and MirageOS implementations are already available.</p>
<h2><a href="https://github.com/mirage/mirage-http">mirage-http</a> unified HTTP API</h2>
<p>Since we now have two HTTP servers, <a href="https://github.com/mirage/ocaml-cohttp">cohttp</a> and <a href="https://github.com/inhabitedtype/httpaf">httpaf</a>, in OCaml and MirageOS available, the new interface <a href="https://github.com/mirage/mirage-http">mirage-http</a> provides a unified interface, and also supports connection upgrades to websockets.</p>
<h2><a href="https://github.com/mirage/ocaml-cstruct">cstruct</a> capabilities</h2>
<p>We use cstruct, a wrapper around OCaml's <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Bigarray.html">Bigarray</a>, quite a lot in MirageOS. Until now, cstruct is a readable and writable byte array. We used phantom types to <a href="https://github.com/mirage/ocaml-cstruct/pull/237">add capabilities</a> to the interface to distinct read-only and write-only buffers.</p>
<h2><a href="https://github.com/hannesm/patch">patch</a></h2>
<p>An OCaml implementation to apply unified diffs. This code has been extracted from conex (since we found some issues in it), and still needs to be fixed.</p>
<h2>Statistical memory profiler</h2>
<p>Since 2016, Jacques-Henri Jourdan has been working on a <a href="https://github.com/ocaml/ocaml/pull/847">statistical memory profiler for OCaml</a> (read the <a href="https://jhjourdan.mketjh.fr/pdf/jourdan2016statistically.pdf">OCaml 2016 paper</a>). An <a href="https://github.com/jhjourdan/statmemprof-emacs/">Emacs user interface</a> is available since some years. We integrated statmemprof into MirageOS unikernels <a href="https://github.com/hannesm/statmemprof-mirage">using the statmemprof-mirage library</a>, marshal the data via TCP, and provide a proxy that communicates with Emacs over a Unix domain socket, and the unikernel.</p>
<h2><a href="https://github.com/p2pcollab">P2Pcollab</a></h2>
<p>P2Pcollab is a collection of composable libraries implementing protocols for P2P collaboration.
So far various P2P gossip protocols has been implemented.
At this retreat the focus was on a gossip-based publish-subscribe dissemination protocol.
Future plans include building P2P unikernels and adding P2P pub/sub sync functionality to Irmin.</p>
|js};
      };
      {
        updated = {js|2019-03-21 18:00|js};
        authors =
          [
            {
              name = {js|Mindy Preston|js};
              uri = Some {js|https://github.com/yomimono|js};
              email = Some {js|mindy.preston@cl.cam.ac.uk|js};
            };
          ];
        subject = {js|MirageOS security advisory 01: netchannel 1.10.0|js};
        permalink = {js|MSA01|js};
        body =
          {js|<h2>MirageOS Security Advisory 01 - memory disclosure in mirage-net-xen</h2>
<ul>
<li>Module:       netchannel
</li>
<li>Announced:    2019-03-21
</li>
<li>Credits:      Thomas Leonard, Hannes Mehnert, Mindy Preston
</li>
<li>Affects:      netchannel = 1.10.0
</li>
<li>Corrected:    2019-03-20 1.10.1 release
</li>
</ul>
<p>For general information regarding MirageOS Security Advisories,
please visit <a href="https://mirage.io/security">https://mirage.io/security</a>.</p>
<h3>Background</h3>
<p>MirageOS is a library operating system using cooperative multitasking, which can
be executed as a guest of the Xen hypervisor.  Virtual devices, such as a
network device, share memory between MirageOS and the hypervisor.  To maintain
adequate performance, the virtual device managing network communication between
MirageOS and the Xen hypervisor maintains a shared pool of pages and reuses
them for write requests.</p>
<h3>Problem Description</h3>
<p>In version 1.10.0 of netchannel, the API for handling network requests
changed to provide higher-level network code with an interface for writing into
memory directly.  As part of this change, code paths which exposed memory taken
from the shared page pool did not ensure that previous data had been cleared
from the buffer.  This error resulted in memory which the user did not
overwrite staying resident in the buffer, and potentially being sent as part of
unrelated network communication.</p>
<p>The mirage-tcpip library, which provides interfaces for higher-level operations
like IPv4 and TCP header writes, assumes that buffers into which it writes have
been zeroed, and therefore may not explicitly write some fields which are always
zero.  As a result, some packets written with netchannel v1.10.0 which were
passed to mirage-tcpip with nonzero data will have incorrect checksums
calculated and will be discarded by the receiver.</p>
<h3>Impact</h3>
<p>This issue discloses memory intended for another recipient and corrupts packets.
Only version 1.10.0 of netchannel is affected.  Version 1.10.1 fixes this issue.</p>
<p>Version 1.10.0 was available for less than one month and many upstream users
had not yet updated their own API calls to use it.  In particular, no version of
qubes-mirage-firewall or its dependency mirage-nat compatible with version
1.10.0 was released.</p>
<h3>Workaround</h3>
<p>No workaround is available.</p>
<h3>Solution</h3>
<p>Transmitting corrupt data and disclosing memory is fixed in version 1.10.1.</p>
<p>The recommended way to upgrade is:</p>
<pre><code class="language-bash">opam update
opam upgrade netchannel
</code></pre>
<p>Or, explicitly:</p>
<pre><code class="language-bash">opam upgrade
opam reinstall netchannel=1.10.1
</code></pre>
<p>Affected releases (version 1.10.0 of netchannel and mirage-net-xen) have been marked uninstallable in the opam repository.</p>
<h3>Correction details</h3>
<p>The following list contains the correction revision numbers for each
affected branch.</p>
<p>Memory disclosure on transmit:</p>
<p>master: <a href="https://github.com/mirage/mirage-net-xen/commit/6c7a13a5dae0f58dcc0653206a73fa3d8174b6d2">6c7a13a5dae0f58dcc0653206a73fa3d8174b6d2</a></p>
<p>1.10.0: <a href="https://github.com/mirage/mirage-net-xen/commit/bd0382eabe17d0824c8ba854ec935d8a2e5f7489">bd0382eabe17d0824c8ba854ec935d8a2e5f7489</a></p>
<h3>References</h3>
<p><a href="https://github.com/mirage/mirage-net-xen">netchannel</a></p>
<p>You can find the latest version of this advisory online at
<a href="https://mirage.io/blog/MSA01">https://mirage.io/blog/MSA01</a>.</p>
<p>This advisory is signed using OpenPGP, you can verify the signature
by downloading our public key from a keyserver (<code>gpg --recv-key 4A732D757C0EDA74</code>),
downloading the raw markdown source of this advisory from <a href="https://raw.githubusercontent.com/mirage/mirage-www/master/tmpl/advisories/01.txt.asc">GitHub</a>
and executing <code>gpg --verify 01.txt.asc</code>.</p>
|js};
      };
      {
        updated = {js|2019-03-05 20:00|js};
        authors =
          [
            {
              name = {js|Hannes Mehnert|js};
              uri = Some {js|https://github.com/hannesm|js};
              email = Some {js|hm519@cam.ac.uk|js};
            };
          ];
        subject = {js|Announcing MirageOS 3.5.0|js};
        permalink = {js|announcing-mirage-35-release|js};
        body =
          {js|<p>We are happy to announce our MirageOS 3.5.0 release. We didn't announce post 3.0.0 releases too well -- that's why this post tries to summarize the changes in the MirageOS ecosystem over the past two years. MirageOS consists of over 100 opam packages, lots of which are reused in other OCaml projects and deployments without MirageOS. These opam packages are maintained and developed further by lots of developers.</p>
<p>On the OCaml tooling side, since MirageOS 3.0.0 we did several major changes:</p>
<ul>
<li>moved most packages to <a href="https://dune.build/">dune</a> (formerly jbuilder) and began using <a href="https://github.com/samoht/dune-release">dune-release</a> for smooth developer experience and simple releases,
</li>
<li>require <a href="https://opam.ocaml.org">opam</a> to be version 2.0.2 or later, allowing <code>pin-depends</code> in <code>config.ml</code>. <code>pin-depends</code> allows you to depend on a development branch of any opam package for your unikernel,
</li>
<li>adjusted documentation to adhere to <a href="https://github.com/ocaml/odoc/">odoc</a> requirements,
</li>
<li>the <code>mirage</code> command-line utility now emits lower and upper bounds of opam packages, allowing uncompromising deprecation of packages,
</li>
<li>support for OCaml 4.06.0 (and above), where <code>safe-string</code> is enabled by default. Strings are immutable now!!,
</li>
<li>remove usage of <code>result</code> package, which has incorporated into <code>Pervasives</code> since OCaml 4.03.0.
</li>
</ul>
<p>The 3.5.0 release contains several API improvements of different MirageOS interfaces - if you're developing your own MirageOS unikernels, you may want to read this post to adjust to the new APIs.</p>
<h2>MirageOS interface API changes:</h2>
<ul>
<li><a href="https://github.com/mirage/mirage-clock">mirage-clock</a> has the <code>type t</code> constrained to <code>unit</code> as of 2.0.0;
</li>
<li><a href="https://github.com/mirage/mirage-protocols">mirage-protocols</a> renames the <code>ETHIF</code> module type to the clearer <code>ETHERNET</code>. As of 2.0.0 it also contains keep-alive support, complies with recent TCP/IP layering rework (see below), and IPv4 now supports reassembly and fragmentation;
</li>
<li><a href="https://github.com/mirage/mirage-net">mirage-net</a> reflects revised layering API as of 2.0.0 (see below);
</li>
<li><a href="https://github.com/mirage/mirage-kv">mirage-kv</a> has a revised API and introduction of a read-write key-value store (see below).
</li>
</ul>
<h2>Major changes</h2>
<h3><a href="https://github.com/mirage/mirage-kv">Key-value store</a></h3>
<p>We improved the key-value store API, and added a read-write store. There is also <a href="https://github.com/mirage/irmin/pull/559">ongoing work</a> which implements the read-write interface using irmin, a branchable persistent storage that can communicate via the git protocol. Motivations for these changes were the development of <a href="https://github.com/roburio/caldav">CalDAV</a>, but also the development of <a href="https://github.com/mirage/wodan">wodan</a>, a flash-friendly, safe and flexible filesystem. The goal is to EOL the <a href="https://github.com/mirage/mirage-fs">mirage-fs</a> interface in favour of the key-value store.</p>
<p>Major API improvements (in <a href="https://github.com/mirage/mirage-kv/pull/14">this PR</a>, since 2.0.0):</p>
<ul>
<li>The <code>key</code> is now a path (list of segments) instead of a <code>string</code>
</li>
<li>The <code>value</code> type is now a <code>string</code>
</li>
<li>The new function <code>list : t -&gt; key -&gt; (string * [</code>Value|<code>Dictionary], error) result io</code> was added
</li>
<li>The function <code>get : t -&gt; key -&gt; (value, error) result io</code> is now provided (used to be named <code>read</code> and requiring an <code>offset</code> and <code>length</code> parameter)
</li>
<li>The functions <code>last_modified : t -&gt; key -&gt; (int * int64, error) result io</code> and <code>digest : t -&gt; key -&gt; (string, error) result io</code> have been introduced
</li>
<li>The function <code>size</code> was removed.
</li>
<li>The signature <code>RW</code> for read-write key-value stores extends <code>RO</code> with three functions <code>set</code>, <code>remove</code>, and <code>batch</code>
</li>
</ul>
<p>There is now a <a href="https://github.com/mirage/mirage-kv-mem">non-persistent in-memory implementation</a> of a read-write key-value store available. Other implementations (such as <a href="https://github.com/mirage/ocaml-crunch">crunch</a>, <a href="https://github.com/mirage/mirage-kv-unix">mirage-kv-unix</a>, <a href="https://github.com/mirage/mirage-fs">mirage-fs</a>, <a href="https://github.com/mirage/ocaml-tar">tar</a> have been adapted, as well as clients of mirage-kv (dns, cohttp, tls)).</p>
<h3><a href="https://github.com/mirage/mirage-tcpip">TCP/IP</a></h3>
<p>The IPv4 implementation now has support for <a href="https://github.com/mirage/mirage-tcpip/pull/375">fragment reassembly</a>. Each incoming IPv4 fragment is checked for the &quot;more fragments&quot; and &quot;offset&quot; fields. If these are non-zero, the fragment is processed by the <a href="https://mirage.github.io/mirage-tcpip/tcpip/Fragments/index.html">fragment cache</a>, which uses a <a href="https://github.com/pqwy/lru">least recently used</a> data structure of maximum size 256kB content shared by all incoming fragments. If there is any overlap in fragments, the entire packet is dropped (<a href="https://eprint.iacr.org/2015/1020.pdf">avoiding security issues</a>). Fragments may arrive out of order. The code is <a href="https://github.com/mirage/mirage-tcpip/blob/v3.7.1/test/test_ipv4.ml#L49-L203">heavily unit-tested</a>. Each IPv4 packet may at most be in 16 fragments (to minimise CPU DoS with lots of small fragments), the timeout between the first and last fragment is 10 seconds.</p>
<p>The layering and allocation discipline has been revised. <a href="https://github.com/mirage/ethernet"><code>ethernet</code></a> (now encapsulating and decapsulating Ethernet) and <a href="https://github.com/mirage/arp"><code>arp</code></a> (the address resolution protocol) are separate opam packages, and no longer part of <code>tcpip</code>.</p>
<p>At the lowest layer, <a href="https://github.com/mirage/mirage-net">mirage-net</a> is the network device. This interface is implemented by our different backends (<a href="https://github.com/mirage/mirage-net-xen">xen</a>, <a href="https://github.com/mirage/mirage-net-solo5">solo5</a>, <a href="https://github.com/mirage/mirage-net-unix">unix</a>, <a href="https://github.com/mirage/mirage-net-macosx">macos</a>, and <a href="https://github.com/mirage/mirage-vnetif">vnetif</a>). Some backends require buffers to be page-aligned when they are passed to the host system. This was previously not really ensured: while the abstract type <code>page_aligned_buffer</code> was required, <code>write</code> (and <code>writev</code>) took the abstract <code>buffer</code> type (always constrained to <code>Cstruct.t</code> by mirage-net-lwt). The <code>mtu</code> (maximum transmission unit) used to be an optional <code>connect</code> argument to the Ethernet layer, but now it is a function which needs to be provided by mirage-net.</p>
<p>The <code>Mirage_net.write</code> function now has a signature that is explicit about ownership and lifetime: <code>val write : t -&gt; size:int -&gt; (buffer -&gt; int) -&gt; (unit, error) result io</code>.
It requires a requested <code>size</code> argument to be passed, and a fill function which is called with an allocated buffer, that satisfies the backend demands. The <code>fill</code> function is supposed to write to the buffer, and return the length of the frame to be send out. It can neither error (who should handle such an error anyways?), nor is it in the IO monad. The <code>fill</code> function should not save any references to the buffer, since this is the network device's memory, and may be reused. The <code>writev</code> function has been removed.</p>
<p>The <a href="https://github.com/mirage/mirage-protocols">Ethernet layer</a> does encapsulation and decapsulation now. Its <code>write</code> function has the following signature:
<code>val write: t -&gt; ?src:macaddr -&gt; macaddr -&gt; Ethernet.proto -&gt; ?size:int -&gt; (buffer -&gt; int) -&gt; (unit, error) result io</code>.
It fills in the Ethernet header with the given source address (defaults to the device's own MAC address) and destination address, and Ethernet protocol. The <code>size</code> argument is optional, and defaults to the MTU. The <code>buffer</code> that is passed to the <code>fill</code> function is usable from offset 0 on. The Ethernet header is not visible at higher layers.</p>
<p>The IP layer also embeds a revised <code>write</code> signature:
<code>val write: t -&gt; ?fragment:bool -&gt; ?ttl:int -&gt; ?src:ipaddr -&gt; ipaddr -&gt; Ip.proto -&gt; ?size:int -&gt; (buffer -&gt; int) -&gt; buffer list -&gt; (unit, error) result io</code>.
This is similar to the Ethernet signature - it writes the IPv4 header and sends a packet. It also supports fragmentation (including setting the do-not-fragment bit for path MTU discovery) -- whenever the payload is too big for a single frame, it is sent as multiple fragmented IPv4 packets. Additionally, setting the time-to-live is now supported, meaning we now can implement traceroute!
The API used to include two functions, <code>allocate_frame</code> and <code>write</code>, where only buffers allocated by the former should be used in the latter. This has been combined into a single function that takes a fill function and a list of payloads. This change is for maximum flexibility: a higher layer can either construct its header and payload, and pass it to <code>write</code> as payload argument (the <code>buffer list</code>), which is then copied into the buffer(s) allocated by the network device, or the upper layer can provide the callback <code>fill</code> function to assemble its data into the buffer allocated by the network device, to avoid copying. Of course, both can be used - the outgoing packet contains the IPv4 header, and possibly the buffer until the offset returned by <code>fill</code>, and afterwards the payload.</p>
<p>The TCP implementation has <a href="https://github.com/mirage/mirage-tcpip/pull/338">preliminary keepalive support</a>.</p>
<h3><a href="https://github.com/solo5/solo5">Solo5</a></h3>
<ul>
<li>MirageOS 3.0.0 used the 0.2.0 release of solo5
</li>
<li>The <code>ukvm</code> target was renamed to <code>hvt</code>, where <code>solo5-hvt</code> is the monitoring process
</li>
<li>Support for <a href="http://bhyve.org/">FreeBSD bhyve</a> and <a href="https://man.openbsd.org/vmm.4">OpenBSD VMM</a> hypervisor (within the hvt target)
</li>
<li>Support for ARM64 and KVM
</li>
<li>New target <a href="https://muen.sk">muen.sk</a>, a separation kernel developed in SPARK/Ada
</li>
<li>New target <a href="https://genode.org">GenodeOS</a>, an operating system framework using a microkernel
</li>
<li>Debugger support: attach gdb in the host system for improved debugging experience
</li>
<li>Core dump support
</li>
<li>Drop privileges on OpenBSD and FreeBSD
</li>
<li>Block device write fixes (in <a href="https://github.com/mirage/mirage-block-solo5">mirage-block-solo5</a>)
</li>
</ul>
<h3><a href="https://github.com/mirage/mirage-random">random</a></h3>
<p>The <a href="https://github.com/mirage/mirage-random-stdlib">default random device</a> from the OCaml standard library is now properly seeded using <a href="https://github.com/mirage/mirage-entropy">mirage-entropy</a>. In the future, we plan to make the <a href="https://github.com/mirleft/ocaml-nocrypto">fortuna RNG</a> the default random number generator.</p>
<h3>Argument passing to unikernels</h3>
<p>The semantics of arguments passed to a MirageOS unikernel used to vary between different backends, now they're the same everywhere: all arguments are concatenated using the whitespace character as separator, and split on the whitespace character again by <a href="https://github.com/mirage/parse-argv">parse-argv</a>. To pass a whitespace character in an argument, the whitespace now needs to be escaped: <code>--hello=foo\\ bar</code>.</p>
<h3>Noteworthy package updates</h3>
<ul>
<li><a href="https://github.com/mirage/ocaml-cstruct">cstruct 3.6.0</a> API changes and repackaging, see <a href="https://discuss.ocaml.org/t/ann-cstruct-3-0-0-with-packaging-changes">this announcement</a> and <a href="https://discuss.ocaml.org/t/psa-cstruct-3-4-0-removes-old-ocamlfind-subpackage-aliases">this announcement</a>
</li>
<li><a href="https://github.com/mirage/ocaml-ipaddr">ipaddr 3.0.0</a> major API changes, the s-expression serialisation is a separate subpackage, macaddr is now a standalone opam package
</li>
<li><a href="https://github.com/mirage/base64">base64 3.0.0</a> performance and API changes, see <a href="https://discuss.ocaml.org/t/ann-major-release-of-base64-article">this announcement</a>
</li>
<li><a href="https://github.com/mirage/ocaml-git">git 2.0.0</a>, read <a href="https://discuss.ocaml.org/t/ann-ocaml-git-2-0">this announcement</a>, as well as <a href="https://discuss.ocaml.org/t/ocaml-git-git-design-and-implementation">its design and implementation</a>
</li>
<li><a href="https://github.com/mirage/io-page">io-page 2.0.0</a>, see <a href="https://discuss.ocaml.org/t/ann-io-page-2-0-0-with-packaging-changes">this announcement</a>
</li>
<li><a href="https://github.com/mirage/ocaml-cohttp">cohttp 2.0.0</a>, see <a href="https://discuss.ocaml.org/t/ann-major-releases-of-cohttp-conduit-dns-tcpip">this announcement</a>
</li>
<li><a href="https://github.com/mirage/ocaml-dns">dns 1.0.0</a>, see <a href="https://discuss.ocaml.org/t/ann-major-releases-of-cohttp-conduit-dns-tcpip">this announcement</a>
</li>
<li><a href="https://github.com/mirage/ocaml-conduit">conduit 1.0.0</a>, see <a href="https://discuss.ocaml.org/t/ann-major-releases-of-cohttp-conduit-dns-tcpip">this announcement</a>
</li>
</ul>
<h2>More features and bugfixes</h2>
<ul>
<li>More HTTP server choices are supported via a new <a href="https://github.com/mirage/mirage/pull/955">httpaf device</a> that permits the <a href="https://github.com/inhabitedtype/httpaf">high performance httpaf</a> stack to run as a unikernel now.
</li>
<li><a href="https://github.com/mirage/mirage/pull/903">libvirt.xml is generated for virtio target</a>
</li>
<li><a href="https://github.com/mirage/mirage/issues/861">Unix target now include -tags thread</a> (for mirage-framebuffer SDL support)
</li>
<li>Various modules (IPv6, DHCP) are explicit about their dependency to the random device
</li>
<li><a href="https://github.com/mirage/mirage/pull/807">QubesDB can be requested in config.ml when the target is Xen</a>
</li>
</ul>
<p>You may also want to read the <a href="https://discuss.ocaml.org/t/ann-mirage-3-2-0">MirageOS 3.2.0 announcement</a> and the <a href="https://discuss.ocaml.org/t/mirage-3-3-0-released">MirageOS 3.3.0 announcement</a>.</p>
<h2>Next steps</h2>
<p>We are working on <a href="https://github.com/mirage/mirage/issues/969">further</a> <a href="https://github.com/mirage/functoria/pull/167">changes</a> which revise the <code>mirage</code> internal build system to <a href="https://dune.build">dune</a>. At the moment it uses <code>ocamlbuild</code>, <code>ocamlfind</code>, <code>pkg-config</code>, and <code>make</code>. The goal of this change is to make MirageOS more developer-friendly. On the horizon we have MirageOS unikernel monorepos, incremental builds, pain-free cross-compilation, documentation generation, ...</p>
<p>Several other MirageOS ecosystem improvements are on the schedule for 2019, including an <a href="https://zshipko.github.io/irmin-tutorial/">irmin 2.0 release</a>, a <a href="https://github.com/Solo5/solo5/pull/310">seccomp target for Solo5</a>, and <a href="https://github.com/Solo5/solo5/issues/326">easier deployment and multiple interface in Solo5</a>.</p>
|js};
      };
      {
        updated = {js|2018-04-20 16:00|js};
        authors =
          [
            {
              name = {js|Stefanie Schirmer|js};
              uri = Some {js|https://linse.me|js};
              email = None;
            };
          ];
        subject =
          {js|Visiting the camels - MirageOS spring hack retreat 2018|js};
        permalink = {js|2018-visiting-the-camels|js};
        body =
          {js|<p>Original posted on <a href="https://linse.me/2018/04/20/Visiting-the-camels.html">linse's blog</a>.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/7/7f/Maroc_Marrakech_Jemaa-el-Fna_Luc_Viatour.JPG" alt="Jemaa El Fnaa" />
Image by Luc Viatour / https://Lucnix.be</p>
<p>In March 2018, I attended my first <a href="http://retreat.mirage.io/">MirageOS hack retreat</a> in Morrocco.
<a href="https://mirage.io/">MirageOS</a> is a library operating system which allows everyone to build very small, specialized operating system kernels that are intended to run directly on the virtualization layer.
The application code itself is the guest operating system kernel, and can be deployed at scale without the need for an extra containerization step in between.
It is written in <a href="https://ocaml.org/learn/description.html">OCaml</a> and each kernel is built only with exactly the code that is necessary for the particular application.
A pretty different approach from traditional operating systems. Linux feels <a href="https://www.linuxcounter.net/statistics/kernel">huge</a> all of a sudden.</p>
<p>I flew in from New York via Casablanca to Marrakesh, and then took a cab to the city center, to the main square, <a href="https://en.wikipedia.org/wiki/Jemaa_el-Fnaa">Jemaa El Fnaa</a>.
At Cafe de France, Hannes was picking me up and we walked back through the labyrinth of the Medina to the hostel Riad &quot;Priscilla&quot; where we lived with about 20 MirageOS folks, two <a href="https://www.instagram.com/p/BgPaVbuD3Y3/?taken-by=l1ns3">turtles</a> and a dog.
We ate some food, and there were talks about Mirage's quickcheck-style fuzzing library <a href="https://github.com/stedolan/crowbar">Crowbar</a>, and an API realized on top of a message queue written in OCaml.</p>
<p>Coming from compiler construction in Haskell and building &quot;stateless&quot; services for information retrieval in Scala, I have a good grasp of functional programming. The funny problem is I don't know much about OCaml yet.</p>
<p>At Etsy, I was part of the Core Platform team where we first <a href="https://www.youtube.com/watch?v=75j1RRxxARI">used hhvm</a> (Facebook's hip-hop virtual machine) on the API cluster, and then advocated to use their gradually typed <a href="http://hacklang.org/">&quot;hack&quot; language</a> to introduce typing to the gigantic PHP codebase at Etsy. Dan Miller and I added types to the codebase with Facebook's <a href="https://docs.hhvm.com/hack/tools/hackificator"><code>hackificator</code></a>, but then
PHP 7 added the possibility of type annotations and great speedups, and PHP's own static analyzer <a href="https://github.com/phan/phan"><code>phan</code></a> was developed by Rasmus Lerdorf and Andrew Morrison to work with PHP's types.
We abandoned the hackification approach.
Why is this interesting? These were my first encounters with OCaml! The <a href="https://docs.hhvm.com/hack/typechecker/introduction">hack typechecker</a> is written in OCaml, and Dan and I have read it to understand the gradual typing approach.
Also, we played with <a href="https://github.com/facebook/pfff/wiki/Main"><code>pfff</code></a>, a tool written in OCaml that allows structural edits on PHP programs, based on the abstact syntax tree.
I made a list to translate between Haskell and OCaml syntax, and later Maggie Zhou and I used <code>pfff</code> to <a href="https://codeascraft.com/author/sschirmer/">unify</a> the syntax of several hundred endpoints in Etsy's internal API.</p>
<p>At the MirageOS retreat, I started my week reading <a href="https://dev.realworldocaml.org/">&quot;Real World OCaml&quot;</a>, but got stuck because the examples did not work with the buildsystem used in the book. Stephen helped me to find a workaround, I made a PR to the book but it was closed since it is a temporary problem. Also, I started reading about OCaml's <a href="https://mirage.io/wiki/tutorial-lwt">&quot;lwt&quot; library</a> for concurrent programming. The abbreviation stands for lightweight threads and the library provides a monadic way to do multithreading, really similar to <a href="https://twitter.github.io/util/docs/com/twitter/util/Future.html">twitter futures</a> in Scala. Asynchronous calls can be made in a thread, which then returns at some point when the call was successful or failed. We can  do operations &quot;inside&quot; lwt with bind (<code>&gt;&gt;=</code>) in the same way we can flatMap over Futures in scala. The library also provides ways to run multiple threads in sequence or in parallel, and to block and wait.
In the evening, there was a talk about a <a href="https://github.com/cfcs/mirage-ocra-demo">high-end smart card</a> that based on a private start value can provide a succession of keys. The hardware is interesting, being the size of a credit card it has a small keypad and a screen. Some banks use these cards already (for their TAN system?), and we all got a sample card to play with.</p>
<p>One day I went swimming with Lix and Reynir, which was quite the adventure since the swimming pool was closed and we were not sure what to do. We still made it to the part that was still open, swam a lot and then got a cake for Hannes birthday which lead to a cake overflow since there were multiple cakes and an awesome party with candles, food and live music already. :D Thanks everyone for organizing!! Happy birthday Hannes!</p>
<p>I started reading another book, <a href="http://ocaml-book.com/">&quot;OCaml from the very beginning&quot;</a>, and working through it with Kugg. This book was more focused on algorithms and the language itself than on tooling and libraries, and the exercises were really fun to solve. Fire up OCaml's REPL <a href="https://github.com/diml/utop"><code>utop</code></a> and go! :D</p>
<p>At the same time I started reading the code for <a href="https://github.com/solo5/solo5">solo5</a> to get an understanding of the underlying hypervisor abstraction layer and the backends we compile to. This code is really a pleasure to read.
It is called solo5 because of MirageOS's system calls, initially a set of 5 calls to the hypervisor, called hypercalls which sounds really futuristic. :D</p>
<p>So that's the other fun problem: I don't know too much about kernel programming yet. I did the <a href="http://eudyptula-challenge.org/">Eudyptula (Linux kernel) challenge</a>, an email-based challenge that sends you programming quests to learn about kernel programming.
Over the course of the challenge, I've made my own Linux kernel module that says &quot;Hello world!&quot; but I have not built anything serious yet.</p>
<p>The next things I learned were <a href="https://mirage.io/wiki/hello-world">configuring and compiling</a> a MirageOS unikernel. Hannes showed me how this works.
The config system is powerful and can be tailored to the unikernel we are about to build, via a config file.
After configuring the build, we can build the kernel for a target backend of our choice. I started out with compiling to Unix, which means all network calls go through unix pipes and the unikernel runs as a simple unix binary in my host system, which is really useful for testing.</p>
<p>The next way to run MirageOS that I tried was running it in ukvm. For this setup you have to change the networking approach so that you can talk from the host system to you unikernel inside ukvm. In Linux you can use the Tun/Tap loopback interface for networking to wire up this connection.</p>
<p>We had a session with <a href="https://hackingwithcare.in/about-2/">Jeremie</a> about our vision for MirageOS which was super fun, and very interesting because people have all kinds of different backgrounds but the goals are still very aligned.</p>
<p>Another thing I learned was how to look at network traffic with <a href="https://www.wireshark.org/">wireshark</a>. <a href="https://s4y.us/">Sidney</a> and I had previously recorded a TLS handshake with tcpdump and looked at the binary data in the pcap file with &quot;hexfiend&quot; next to Wikipedia to decode what we saw.
Derpeter gave me a nice introduction about how to do this with wireshark, which knows about most protocols already and will do the decoding of the fields for us. We talked about all layers of the usual stack, other kinds of internet protocols, the iptables flow, and bgp / <a href="https://www.peeringdb.com/net/12276">peeringDB</a>. Quite interesting and I feel I have a pretty good foundational understanding about how the internet actually works now.</p>
<p>During the last days I wanted to write a unikernel that does something new, and I thought about monitoring, as there is no monitoring for MirageOS yet. I set up a <a href="https://grafana.com/">grafana</a> on my computer and sent some simple data packets to grafana from a unikernel, producing little peaks in a test graph. Reynir and I played with this a bit and restructured the program.</p>
<p>After this, the week was over, I walked back to Jemaa el Fnaa with Jeremie, I feel I learned a ton and yet am still at the very beginning, excited what to build next. On the way back I got stuck in a weird hotel in Casablanca due to the flight being cancelled, where I bumped into a Moroccan wedding and met some awesome travelling women from Brazil and the US who also got stuck. All in all a fun adventure!</p>
<p><img src="https://scontent-frt3-2.cdninstagram.com/vp/b7383ad87744d99eae8940b38789fc94/5B58DFFC/t51.2885-15/e35/28764104_231320117439563_2956918922680467456_n.jpg" alt="" /></p>
|js};
      };
      {
        updated = {js|2018-01-26 16:00|js};
        authors =
          [
            {
              name = {js|Anil Madhavapeddy|js};
              uri = Some {js|http://anil.recoil.org|js};
              email = Some {js|anil@recoil.org|js};
            };
          ];
        subject = {js|MirageOS running on the ESP32 embedded chip|js};
        permalink = {js|2018-esp32-booting|js};
        body =
          {js|<p>Now that the winter holiday break is over, we are starting to see the results of winter hacking among our community.</p>
<p>The first great hack for 2018 is from <a href="http://toao.com">Sadiq Jaffer</a>, who got OCaml booting on a tiny and relatively new CPU architecture -- the <a href="http://esp32.net">Espressif ESP32</a>.  After proudly demonstrating a battery powered version to the folks at <a href="https://ocamllabs.io">OCaml Labs</a>, he then proceeded to clean it up enough tha it can be built with a <a href="https://github.com/sadiqj/ocaml-esp32-docker">Dockerfile</a>, so that others can start to do a native code port and get bindings to the networking interface working.</p>
<p><a href="http://toao.com/blog/getting-ocaml-running-on-the-esp32#getting-ocaml-running-on-the-esp32">Read all about it on Sadiq's blog</a>, and thanks for sharing this with us, Sadiq!</p>
<p>We also noticed that another OCaml generic virtual machine for even smaller microcontrollers has <a href="https://github.com/stevenvar/omicrob">shown up on GitHub</a>.  This, combined with some functional metaprogramming, may mean that 2018 is the year of OCaml in all the tiny embedded things...</p>
|js};
      };
      {
        updated = {js|2017-4-15 16:00|js};
        authors =
          [
            {
              name = {js|Hannes Mehnert|js};
              uri = Some {js|https://github.com/hannesm|js};
              email = Some {js|hm519@cam.ac.uk|js};
            };
            {
              name = {js|Gemma Gordon|js};
              uri = Some {js|https://github.com/GemmaG|js};
              email = Some {js|gg417@cl.cam.ac.uk|js};
            };
            {
              name = {js|Anil Madhavapeddy|js};
              uri = Some {js|http://anil.recoil.org|js};
              email = Some {js|anil@recoil.org|js};
            };
          ];
        subject = {js|MirageOS March 2017 hack retreat roundup|js};
        permalink = {js|2017-march-hackathon-roundup|js};
        body =
          {js|<p>This March, 34 people from around the world gathered in Marrakech for a spring Mirage hack retreat. This is fast becoming a <a href="/blog/2016-spring-hackathon">MirageOS tradition</a>, and we're a little sad that it's over already! We've collected some trip reports from those who attended the 2017 Hack Retreat, and we'd like to thank our amazing hosts, organisers and everyone who took the time to write up their experiences. Props go especially to Hannes Mehnert who initiated the event and took care of many of the logistics, and to Gemma Gordon for designing and printing <a href="http://reynard.io/2017/03/10/OCamlCollection.html">limited edition t-shirts</a> especially for the occasion!
<img src="/graphics/medina-2017.jpg" style="float:right; padding: 15px" /></p>
<p>In addition to the reports below, you can find other information online:</p>
<ul>
<li>the daily <a href="http://ocamllabs.io/events/2017/03/06/MirageHackUpdates.html">tweets about the event</a>, including sophisticated &quot;paper slides&quot;
</li>
<li><a href="http://ollehost.dk/blog/2017/03/17/travel-report-mirageos-hack-retreat-in-marrakesh-2017/">Olle Jonsson</a> and <a href="https://reynir.dk/posts/2017-03-20-11-27-Marrakech%202017.html">Reynir Björnsson</a> wrote up their experiences on their personal sites.
</li>
</ul>
<h2>Hannes Mehnert</h2>
<p>At the retreat, 34 people from all around the world (mainly Western
Europe) interested in MirageOS gathered for a week in Marrakech.</p>
<p>Numerous social contacts, political discussions, technical challenges
were discussed in smaller and bigger groups. Lots of pull requests were
opened and merged - we kept the DSL line busy with git pushes and pulls
:) - sometimes overly busy.</p>
<p>In contrast to <a href="/blog/2016-spring-hackathon">last year</a>, we organised several events:</p>
<ul>
<li>Body self-awareness workshop (by the resident dancers)
</li>
<li>Hiking to waterfalls on Sunday
</li>
<li>Hamam visit on Monday
</li>
<li>Herbalist visit on Tuesday
</li>
<li>Talk by the resident dancers on Tuesday
</li>
<li>A <a href="https://www.dropbox.com/s/w5wnlbxujf7pk5w/Marrakech.pdf?dl=0">public talk</a> led by Amir on Saturday (highly appreciated, it
was announced rather late, only ~10 external people showed up)
<img src="/graphics/spiros-camel.jpg" style="float:right; padding: 15px" />
</li>
</ul>
<p>Several voluntary presentations on topics of interest to several people:</p>
<ul>
<li>&quot;Reverse engineering MirageOS with radare2 (and IDA pro)&quot; by Alfredo
(Alfredo and Chris tried afterwards the link-time optimization branch of
OCaml, which does not seem to have any effect at all (there may be
something missing from the 4.04.0+trunk+forced_lto switch))
</li>
<li>&quot;Introduction to base&quot; by Spiros
</li>
<li>&quot;Solo5&quot; (or rather: what is below the OCaml runtime, xen vs solo5) by
Mato https://pbs.twimg.com/media/C6VQffoWMAAtbot.jpg
</li>
<li>&quot;Angstrom intro&quot; by Spiros
</li>
</ul>
<p>After the week in Marrakech, I was sad to leave the place and all the nice people. Fortunately we can interact via the Internet (on IRC,
GitHub, Mail, ...) on projects which we started or continued to work on at the retreat.</p>
<p>It was a very nice week, I met lots of new faces. These were real people with interesting stories, and I could finally match email addresses to faces. I was delighted to share knowledge about software I know to other people, and learned about other pieces of software.</p>
<p>My personal goal is to grow a nice and diverse community around MirageOS, and so far I have the feeling that this is coming along smoothly.</p>
<h2>Thanks again to everybody for participating (on-site and remote) and special thanks to <a href="http://ocamllabs.io">OCaml Labs</a> for support, and Gemma Gordon for the limited edition <a href="http://reynard.io/2017/03/10/OCamlCollection.html">t-shirts</a> (design and logistics)!</h2>
<h2>Ximin Luo</h2>
<p>Good people, good food, good weather, what more could you ask for? This year's MirageOS hackathon was a blast, like last year.</p>
<p>I started off the week by giving a monad tutorial to a few people - introducing the terminology around it, the motivation behind it, giving a few concrete examples and exercises, and relating it to some basic category theory.</p>
<p>Since last year, I've been working on-and-off on a group messaging protocol. One of its aims is to completely separate the transport and application layers, by sticking an end-to-end secure session layer in between them. This could help to unify <a href="https://xkcd.com/1810/">all the messaging protocols that exist today</a> or it could <a href="https://xkcd.com/927/">make the problem worse</a>, time will tell how this works out in the end. :)</p>
<p>Another of my interests is to write more code that is obviously-more-secure, using strong type systems that provide compile-time guarantees about what your code can or can't do. As part of bringing these two concepts together, I've been working on writing a pure library for doing scheduled (timed) computations - i.e., to express &quot;do this in X time in the future&quot; then actually do it. This is very important in real world security systems, where you can't wait for too long for certain events to happen, otherwise you'll be susceptible to attacks.</p>
<p>To give the game away, the utility is just a state monad transformer where the state is a schedule data structure that records the tasks to be performed in the future, together with a pure monadic runner that executes these tasks but is triggered by impure code that knows the &quot;real&quot; time. However, implementing the specifics so that user code is composable and still looks (relatively) nice, has taken quite some effort to figure out. There are various other nice properties I added, such as being able to serialise the schedule to disk, so the behaviour is preserved across program shutdowns.</p>
<p>Using this pure lower-level control-flow utility, we can build slightly higher-level utilities, such as a &quot;monitor&quot; (something that runs a task repeatedly, e.g. useful for resending algorithms) or an &quot;expectation&quot; (a promise/future that can time out, and also runs a monitor to repeatedly &quot;try&quot; to succeed, while it is not yet succeeded or failed, which is useful for <em>deferring</em> high-level security properties but not forgetting about them, a very common pattern). I spent much of the week building these things and testing them, and using this practical experience to refine the APIs for the low-level scheduled computations.</p>
<p>I also did some more short-term work to spread type-safe languages to more audiences, packaging OCaml 4.04 for Debian, and also reporting and working around some test failures for rustc 1.15.1 on Debian, earning me the label of &quot;traitor&quot; for a while. :p</p>
<p>I wrote more documentation for my in-progress contribution to the ocaml-lens library, to bring traverse-once &quot;van Laarhoven&quot; lens to OCaml, similar to the ones in Haskell. I had some very interesting discussions with Jens and Rudi on Rust, Haskell, OCaml and various other &quot;cutting-edge&quot; FP research topics. Rudi also gave some useful feedback on my ocaml-lens code as well as some other pure functional utilities that I've been developing for the messaging protocol mentioned above, thanks Rudi!</p>
<p>Viktor and Luk taught us how to play <a href="https://web.archive.org/web/20161026135837/http://joshaguirre.com/cambio-card-game-rules-and-cheatsheet/">Cambio</a> and we in turn taught that to probably 10 more people around the hostel, including some non-mirage guests of the hostel! It was very enjoyable playing this into the early hours of the morning.</p>
<h2>On one of the evenings Jurre and I got drunk and did some very diverse and uncensored karaoke and eventually embarassed^H^H^H^H^H^H^H persuaded a lot of the others to join us in the fun and celebrations. We'll be back next year with more, don't worry!</h2>
<h2>Michele Orrù</h2>
<p>Last summer I started, while being an intern in Paris, a <a href="https://letsencrypt.org/">let's encrypt</a> (or rather
<a href="https://www.ietf.org/id/draft-ietf-acme-acme-06.txt">ACME</a>.</p>
<p>Let's encrypt is a certificate authority which issues signed certificates via an automated service (using the ACME protocol). Even though it is still in the process of being standardized, the first eCA already launched in April 2016, as a low-cost alternative to commercial CAs (where you usually need to provide identity information (passport) for verification).</p>
<p>If you want to run a secure service on your domain, such as HTTPS, STARTTLS in SMTP, IMAPS, ..., you have to generate a private key and a certificate signing request (CSR).  You then upload this CSR via HTTP to the let's encrypt server and solve a some &quot;challenge&quot; proposed by the server in order to certify you <em>own</em> the requested domain.</p>
<p>At the time of the hack retreat, the following challenges were supported:</p>
<ul>
<li>TLS (using the SNI extension),
</li>
<li>DNS (setting a TXT record), or
</li>
<li>HTTP (replying to a particular request at some &quot;.well_known&quot; url),
</li>
</ul>
<p>In order to reach a working implementation, I had to implement myself a JSON web signature, and a JSON web key <a href="https://github.com/mmaker/ocaml-letsencrypt/">library in OCaml</a>.</p>
<p>My goal for the hack retreat was to polish this library, get it up to date with the new internet standards, and present this library to the Mirage community, as I do believe it could be the cornerstone for bootstrapping a unikernel on the internet having encryption by default. I was impressed by the overwhelming interest of the participants and their interest in helping out polishing this library. I spent a lot of time reviewing pull requests and coding with people I had just met. For instance, <a href="https://github.com/reynir">Reynir</a> ported it to the <a href="http://erratique.ch/software/topkg">topkg</a> packager, cleaned up the dependencies and made it possible to have a certificate for multiple domains. <a href="https://github.com/vbaluch">Viktor</a> and <a href="https://github.com/realfake">Luk</a> helped out implementing the DNS challenge. <a href="https://github.com/azet">Aaron</a> helped out adding the new internet draft.</p>
<p>While busy reviewing and merging the pull requests, and extending <a href="https://github.com/Engil/Canopy">Canopy</a> to automatically renew its certificates (<a href="https://github.com/Engil/Canopy/tree/feature/letsencrypt">WIP on this feature branch</a>). My library is still not released, but I will likely do an initial release before the end of the month, after some more tests.</p>
<h2>This was the second time I attended the hack retreat, and it's been quite different: last year I was mostly helping out people, uncovering bugs and reporting documentation. This time it was other people helping me out and uncovering bugs on my code. The atmosphere and cooperation between the participants was amazing: everybody seemed to have different skills and be pleased to explain their own area of expertise, even at the cost of interrupting their own work. (I'd have to say sorry to Mindy and Thomas for interrupting too often, but they were sooo precious!) I particularly enjoyed the self-organized sessions: some of them, like Ximin's one on monads, even occurred spontaneously!</h2>
<h2>Mindy Preston</h2>
<p>Update 2017: Morocco, Marrakesh, the medina, and Priscilla are still sublime. Thank you very much to Hannes Mehnert for organizing and to the wonderful Queens at Priscilla for creating an excellent space and inviting us to inhabit it.</p>
<p>I tried to spend some time talking with people about getting started with the project and with OCaml. There's still a thirst for good-first-bug which isn't met by &quot;please implement this protocol&quot;. People are also eager for intermediate-level contributions; people are less resistant to &quot;please clean up this mess&quot; than I would have expected. I think that figuring out how to make cross-cutting changes in Mirage is still not very accessible, and would be a welcome documentation effort; relatedly, surfacing the set of work we have to do in more self-contained packages would go a long way to filling that void and is probably easier.</p>
<p>People were excited about, and did, documentation work!! And test implementation!! I was so excited to merge all of the PRs improving READMEs, blog entries, docstrings, and all of the other important bits of non-code that we haven't done a good job of keeping up with. It was <em>amazing</em> to see test contributions to our existing repositories, too -- we have our first unit test touching ipv6 in tcpip since the ipv6 modules were added in 2014. :D Related to the previous bullet point, it would be great to point at a few repositories which particularly need testing and documentation attention -- I found doing that kind of work for mirage-tcpip very helpful when I was first getting started, and there's certainly more of it to do there and in other places as well.</p>
<p>I spent a lot less time on install problems this year than last year, and a lot more time doing things like reviewing code, seeing cats, merging PRs, exploring the medina, cutting releases, climbing mountains, and pairing with people on building and testing stuff. \\o/</p>
<p>Presentations from folks were a great addition! We got introductions to Angstrom and Base from Spiros, a tour through reversing unikernels with radare2 from Alfredo, and a solo5 walkthrough from Martin. Amir gave a great description of MirageOS, OCaml, and use cases like Nymote and Databox for some of our fellow guests and friends of the hostel.  My perception is that we had more folks from the non-Mirage OCaml community this year, and I think that was a great change; talking about jbuilder, Base, Logs, and Conduit from new perspectives was illuminating. I don't have much experience of writing OCaml outside of Mirage and it's surprisingly easy (for me, anyway) to get siloed into the tools we already use and the ways we already use them. Like last year, we had several attendees who don't write much OCaml or don't do much systems programming, and I'm really glad that was preserved -- that mix of perspectives is how we get new and interesting stuff, and also all of the people were nice :)</p>
<p>There were several projects I saw more closely for the first time and was really interested in: g2p's storage, timada's performance harness; haesbaert's awa-ssh; maker's ocaml-acme; and there were tons of other things I didn't see closely but overheard interesting bits and pieces of!</p>
<h2>Rereading the aggregated trip report from the 2016 spring hack retreat, it's really striking to me how much of Mirage 3's work started there; from this year's event, I think Mirage 4 is going to be amazing. :)</h2>
<h2>Viktor Baluch &amp; Luk Burchard:</h2>
<p>“Let’s make operating systems great again” – with this in mind we started our trip to Marrakech. But first things first: we are two first year computer science students from Berlin with not a whole lot of knowledge of hypervisors, operating systems or functional programming. This at first seems like a problem… and it turned out it was :).
The plan was set, let’s learn this amazing language called OCaml and start hacking on some code, right? But, as you could imagine, it turned out to be different yet even better experience. When we arrived, we received a warm welcome in Marrakech from very motivated people who were happy to teach us new things from their areas of expertise. We wanted to share some of our valuable knowledge as well, so we taught some people how to play Cambio, our favourite card game, and it spread like wildfire (almost everyone was playing it in the second evening). We’re glad that we managed to set back productivity in such a fun way. ;P</p>
<p>Back to what we came to Morocco for: as any programming language, OCaml seems to provide its special blend of build system challenges. <a href="https://github.com/rgrinberg/">Rudi</a> was kind enough to help us navigate the labyrinth of distribution packages, opam, and ocamlfind with great patience and it took us only two days to get it almost right.</p>
<p>Finally having a working installation, we got started by helping <a href="https://github.com/mmaker/">Michele</a> with his <a href="https://github.com/mmaker/ocaml-acme/">ocaml-acme</a> package, a client for Let's Encrypt (and other services implementing the protocol). An easy to use and integrate client seemed like one feature that could provide a boost to unikernel adoption and it looked like a good match for us as OCaml beginners since there are many implementations in other programming languages that we could refer to. After three days we finally made our first Open Source OCaml contributions to this MirageOS-related project by implementing the dns-01 challenge.</p>
<p>Hacking away on OCaml code of course wasn’t the only thing we did in Marrakech: we climbed the Atlas mountains to see the seven magic waterfalls (little disclaimer: there are only four). It was not a really productive day but great for building up the spirit which makes the community so unique and special. Seeing camels might also helped a little bit. ;)</p>
<p>One of the most enjoyable things that the retreat provided was the chance for participants to share knowledge through presentations which lead to very interesting conversations like after <a href="https://github.com/amirmc/">Amir’s</a> presentation when some artists asked about sense of life and computer systems (by the way, one question is already solved and it is ’42’). We were also very impressed by the power and expressiveness of functional languages which <a href="https://github.com/seliopou/">Sprios</a> demonstrated in his parser combinator <a href="https://github.com/inhabitedtype/angstrom/">Angstrom</a>.</p>
<p>Thank you to everyone involved for giving us the experience of an early ‘enlightenment’ about functional programming as first year students and the engaging discussions with so many amazing people! We sure learned a lot and will continue working with OCaml and MirageOS whenever possible.</p>
<h2>Hope to see all of you again next time!</h2>
<h2>Aaron Zauner</h2>
<p>I flew from Egypt to Marrakech not sure what to expect, although I'm not new to functional programming, I'm a total OCaml novice and haven't worked on unikernels - but have always been interested in the topic. Hannes invited me to hang out and discuss, and that's exactly what I did. I really enjoyed spending my time with and meeting all of you. Some of you I have known &quot;from the interwebs&quot; for a while, but never met in person, so this was a great opportunity for me to finally get to see some of you in real life. I spent most of my time discussing security topics (everything from cryptography, bootstrapping problems to telco/ mobile security), operating system design and some programming language theory. I got to know the OCaml environment, a bit more about MirageOS and I read quite a few cryptography and operating system security papers.</p>
<h2>All of the people I spoke with were very knowledgeble - and I got to see what people exactly work on in MirageOS - which certainly sparked further interest in the project. I've been to Morocco a couple of times but the food we got at Queens of the Medina was by far the best food I've eaten in Morocco so far. I think the mix of nerds and artists living at the Riad was really inspiring for all of us, I was certainly interested in what they were working on, and they seemed to be interested in what all of these freaky hackers were about too. Living together for more than a week gives the opportunity to get to know people not only on a technical level but -- on a personal level, in my opinion we had a great group of people. Giving back to the local community by giving talks on what we're doing at the Hackathon was a great idea, and I enjoyed all of the talks that I've attended. I've been to a few hackathons (and even organized one or two), but this one has certainly been the most enjoyable one for me. People, food, location and the discussions (also Karaoke and learning to play Cambio!) I've had will make me remember the time I spent with you guys for a long time. I hope I'm able to join again at some point (and actually contribute to code not only discussions) in the future. Unfortunately I cannot give any feedback on possible improvements, as I think we had a very well selected group of people and perfect conditions for a Hackathon, could not think of how to organize it better - Thank you Hannes!</h2>
<h2>Thomas Leonard</h2>
<p>This was my second time at the hackathon, and it was great to see everyone and work on Mirage stuff again! I brought along a NUC which provided an additional wireless access point, running a Mirage/Xen DHCP server using haesbaert's <a href="https://github.com/mirage/charrua-core">charrua</a> library - one of the fruits of last year's efforts.</p>
<p>My goal this year was to update <a href="http://roscidus.com/blog/blog/2016/01/01/a-unikernel-firewall-for-qubesos/">qubes-mirage-firewall</a> to support Mirage 3 and the latest version of <a href="https://github.com/yomimono/mirage-nat">mirage-nat</a>, and to add support for NAT of ICMP messages (so that <code>ping</code> works and connection errors are reported). In the process, I converted mirage-nat to use the new parsers in the Mirage 3 version of the tcpip library, which cleaned up the code a lot. It turned out that the firewall stressed these parsers in new ways and we were able to <a href="https://github.com/mirage/mirage-tcpip/pull/301">make them more robust</a> as a result. Having Mirage 3 release manager and mirage-nat author yomimono on hand to help out was very useful!</p>
<p>It was great to see so many QubesOS users there this year. Helping them get the firewall installed motivated me to write some proper installation instructions for <a href="https://github.com/talex5/qubes-test-mirage">qubes-test-mirage</a>.</p>
<p>After the hackathon, I also updated mirage-nat to limit the size of the NAT table (using pqwy's <a href="https://github.com/pqwy/lru">lru</a>) and made a new release of the firewall with all the improvements.</p>
<p>ComposMin was looking for a project and I hopefully suggested some tedious upgrading and build system porting work. He accepted!! So, <a href="https://github.com/talex5/qubes-mirage-skeleton">qubes-mirage-skeleton</a> now works with Mirage 3 and <a href="https://github.com/mirage/mirage-profile">mirage-profile</a> has been ported to topkg - something I had previously attempted and failed at.</p>
<p>Rudi gave me an introduction to the new <a href="https://github.com/janestreet/jbuilder">jbuilder</a> build tool and I look forward to converting some of my projects to use it in the near future.</p>
<p>Particularly useful for me personally was the chance discovery that Ximin Luo is a Debian Developer. He signed my GPG key, allowing me to complete a Debian key rollover that I began in May 2009, and thus recover the ability to update my package again.</p>
<p>I also wanted to work on <a href="https://github.com/talex5/irmin-indexeddb">irmin-indexeddb</a> (which allows web applications to store Irmin data in the browser), but ran out of time - maybe next year...</p>
<h2>Many thanks to hannesm for organising this!</h2>
<h2>Amir Chaudhry</h2>
<p>This was my first time at the Marrakech hack retreat. I was only there for about half the time (mostly the weekend) and my goal was simply to meet people and understand what their experiences have been. Having missed the inaugural event last year, I wasn't sure what to expect in terms of format/event. What I found was a very relaxed approach with lots of underlying activity. The daily stand ups just before lunch were well managed and it was interesting to hear what people were thinking of working on, even when that included taking a break. The food was even more amazing than I'd been led to believe by tweets :)</p>
<p>Somehow, a few hours after I arrived, Hannes managed to sweet-talk me in to giving a presentation the next day about MirageOS to the artists and dance troupe that normally make use of the venue. Since we'd taken over the place for a week — displacing their normal activities — our host thought it would be helpful if someone explained &quot;what the nerds are doing here&quot;. This was an unexpected challenge as getting across the background for MirageOS involves a lot of assumed knowledge about operating system basics, software development, software <em>itself</em>, the differences between end-users and developers, roughly how the internet works, and so on. There's a surprising number of things that we all just 'know', which the average software user has no clue about. I hadn't given a talk to that kind of audience before so I spent half a day scrambling for analogies before settling on one that seemed like it might work — involving houses, broken windows, and the staff of Downton Abbey. The talk led to a bunch of interesting discussions with the artists which everyone got involved with. I think the next time I do this, I might also add an analogy around pizza (I have many ideas on this theme already). If you're interested in the slides themselves (mostly pics), there's a PDF at https://www.dropbox.com/s/w5wnlbxujf7pk5w/Marrakech.pdf?dl=0</p>
<p>I also had time to chat with Mindy about an upcoming talk on MirageOS 3.0, and Martin about future work on Solo5. The talks and demos I saw were really useful too and sharing that knowledge with others in this kind of environment was a great idea. Everyone loved the t-shirts and were especially pleased to see me as it turned out I was bringing many of the medium-sized ones. One of the best things about this trip was putting names and faces to GitHub handles, though my brain regularly got the mapping wrong. :)</p>
<h2>Overall, this was an excellent event and now that it's happened twice, I think we can call it a tradition. I'm looking forward to the next one!</h2>
<h2>Jurre van Bergen</h2>
<p>I spent most of my time reading up on functional programming and setting up an developer environment and helped with some small things here and there. I didn't feel confident to do a lot of code yet, but it was a very nice environment to ask questions in, especially as a newcomer to MirageOS and OCaml!</p>
<p>I plan to do more OCaml in my spare time and play more with MirageOS in the future. Maybe someday, we can actually merge in some MirageOS things into <a href="https://tails.boum.org/">Tails</a>. I hope to actually do some OCaml code with people next year!
Next to that, there was also some time to relax, climbing the Atlas mountains was a welcome change of scenery after reading through up on functional programming for a couple of days. Will definitely do that again some day!</p>
<h2>Next to that, shout out to Viktor and Luke for teaching us how to play Cambio, we had a lot of fun with it the entire retreat in the evenings!
I was excited to learn that so many people were actually into karaoke, I hope those who don't will join us next year ;-)</h2>
<h2>Reynir Björnsson</h2>
<p>A work in progress from Reynir is his work on documentation in the toplevel:</p>
<blockquote>
<p>As mentioned on the midday talkie talkie I've made a OCaml toplevel directive for querying documentation (if available). It's available here <a href="https://github.com/reynir/ocp-index-top">https://github.com/reynir/ocp-index-top</a>.
To test it out you can install it with opam pin:
opam pin add ocp-index-top https://github.com/reynir/ocp-index-top.git</p>
</blockquote>
<p>It doesn't depend on opam-lib. opam-lib is yuuuuge and the API is unstable. Instead I shell out to opam directly similar to how ocp-browser works. This means installing the package is less likely to make a mess in your dependencies.</p>
<blockquote>
<p>There is one issue I don't know how to fix (see issue #1). When requiring <code>ocp-index-top</code> the <code>compiler-libs</code> and <code>ocp-index.lib</code> libraries are pulled into scope which is not cool and totally unnecessary.</p>
</blockquote>
<hr />
<p>Many thanks to everyone involved!  The hackathon is already booked for next year in the same place...</p>
|js};
      };
      {
        updated = {js|2017-12-23 16:00|js};
        authors =
          [
            {
              name = {js|Hannes Mehnert|js};
              uri = Some {js|https://github.com/hannesm|js};
              email = Some {js|hm519@cam.ac.uk|js};
            };
          ];
        subject = {js|MirageOS Winter 2017 hack retreat roundup|js};
        permalink = {js|2017-winter-hackathon-roundup|js};
        body =
          {js|<p>This winter, 33 people from around the world gathered in Marrakesh for a Mirage hack retreat. This is fast becoming a <a href="/blog/2016-spring-hackathon">MirageOS</a> <a href="/blog/2017-march-hackathon-roundup">tradition</a>, and we're a little sad that it's over already! We've collected some trip reports from those who attended the 2017 winter hack retreat, and we'd like to thank our amazing hosts, organisers and everyone who took the time to write up their experiences.
<img src="/graphics/winter2017.jpg" style="float:right; padding: 15px" /></p>
<p>We, the MirageOS community, strongly believe in using our own software: this website has been a unikernel since day one^W^W it was possible to run MirageOS unikernels.  In Marrakesh we used our own DHCP and DNS server without trouble.  There are many more services under heavy development (including git, ssh, ...), which we're looking forward to using soon ourselves.</p>
<p>Several atteendees joined for the second or third time in Marrakesh, and brought their own projects, spanning over <a href="https://github.com/andreas/ocaml-graphql-server">graphql</a>, <a href="https://reproducible-builds.org/">reproducible builds</a> (with application to <a href="https://github.com/talex5/qubes-mirage-firewall">qubes-mirage-firewall</a>, see <a href="http://layer-acht.org/thinking/blog/20171204-qubes-mirage-firewall/">holger's report</a> and <a href="https://github.com/ocaml/ocaml/pull/1515">Gabriel's OCaml fixes for build path variation</a>).  A stream of improving error messages in the OCaml compiler (based on <a href="https://github.com/ocaml/ocaml/pull/102">Arthur Charguéraud PR</a>) was prepared and merged (<a href="https://github.com/ocaml/ocaml/pull/1496">PR 1496</a>, <a href="https://github.com/ocaml/ocaml/pull/1501">PR 1501</a>, <a href="https://github.com/ocaml/ocaml/pull/1505">PR 1505</a>, <a href="https://github.com/ocaml/ocaml/pull/1510">PR 1510</a>, and <a href="https://github.com/ocaml/ocaml/pull/1534">PR 1534</a>).  Our OCaml <a href="https://github.com/mirage/ocaml-git/">git implementation</a> was rewritten to support git push properly, and this PR was <a href="https://github.com/mirage/ocaml-git/pull/227">merged</a>.  Other projects of interest are <a href="https://github.com/haesbaert/awa-ssh">awa-ssh</a>, <a href="https://github.com/mirage/charrua-core/pull/76">anonymity profiles in DHCP</a>, and fixes to the deployment troubles of <a href="https://github.com/mirage/mirage-www">our website</a>.  There is now a <a href="https://github.com/cfcs/eye-of-mirage">mirage PNG viewer integrated into Qubes</a> and a <a href="https://github.com/cfcs/passmenage">password manager</a>.  Some <a href="https://github.com/juga0/mirage_mar2017">getting started notes</a> were written down as well as the new <a href="https://mirage.io/wiki/learning">learning about MirageOS</a> website.</p>
<p>A huge fraction of the <a href="https://github.com/solo5/solo5">Solo5 contributors</a> gathered in Marrakesh as well and discussed the future, including terminology, the project scope, and outlined a roadmap for merging branches in various states.  Adrian from the <a href="https://muen.sk">Muen</a> project joined the discussion, and in the aftermath they are now running their website using MirageOS on top of the Muen separation kernel.</p>
<p>A complete list of fixes and discussions is not available, please bear with us if we forgot anything above.  A sneak preview: there will be <a href="http://retreat.mirage.io">another retreat in March 2018</a> in Marrakesh.  Following are texts written by individual participants about their experience.</p>
<h2>Mindy Preston</h2>
<p>I came to Marrakesh for the hack retreat with one goal in mind: documentation.  I was very pleased to discover that <a href="https://github.com/mk270">Martin Keegan</a> had come with the same goal in mind and fresher eyes, and so I had some time to relax, enjoy Priscilla and the sun, photograph some cats, and chat about projects both past and future.  In particular, I was really pleased that there's continued interest in building on some of the projects I've worked on at previous hack retreats.</p>
<p>On the way to the first hack retreat, I did some work applying <a href="https://github.com/stedolan">Stephen Dolan's</a> then-experimental <a href="http://lcamtuf.coredump.cx">American Fuzzy Lop</a> instrumentation to testing the <a href="https://github.com/mirage/mirage-tcpip">mirage-tcpip</a> library via <a href="https://github.com/yomimono/mirage-net-pcap">mirage-net-pcap</a>. (A post on this was <a href="http://canopy.mirage.io/Projects/Fuzzing">one of the first Canopy entries!</a>  At this hack retreat, I did a short presentation on the current state of this work:</p>
<ul>
<li>AFL instrumentation was released in OCaml 4.05; switches with it enabled by default are available in opam (<code>opam sw 4.05.0+afl</code>)
</li>
<li><a href="https://github.com/stedolan/crowbar">crowbar</a> for writing generative tests powered by AFL, with an <a href="https://github.com/stedolan/crowbar/tree/staging">experimental staging branch</a> that shows OCaml code for regenerating failing test cases
</li>
<li>a <a href="https://github.com/yomimono/ppx_deriving_crowbar">companion ppx_deriving</a> plugin for automatic generator discovery based on type definitions
</li>
<li><a href="https://github.com/yomimono/ocaml-bun">bun</a>, for integrating afl tests into CI runs
</li>
</ul>
<p>I was lucky to have a lot of discussions about fuzzing in OCaml, some of which inspired further work and suggestions on <a href="https://github.com/stedolan/crowbar/issues/7">some current problems in Crowbar</a>.  (Special thanks to <a href="https://github.com/gasche">gasche</a> and <a href="https://github.com/armael">armael</a> for their help there!)  I'm also grateful to <a href="https://github.com/aantron">aantron</a> for some discussions on ppx_bisect motivated by an attempt to estimate coverage for this testing workflow.  I was prodded into trying to get Crowbar ready to release by these conversations, and wrote a lot of docstrings and an actual README for the project.</p>
<p><a href="https://github.com/juga0">juga0</a> added some extensions to the <a href="https://github.com/mirage/charrua-core">charrua-core DHCP library</a> started by <a href="https://github.com/haesbaert">Christiano Haesbaert</a> a few hack retreats ago.  juga0 wanted to add some features to support <a href="https://tools.ietf.org/html/rfc7844.html">more anonymity for DHCP clients</a>, so we did some associated work on the <a href="https://github.com/haesbaert/rawlink">rawlink</a> library, and added an experimental Linux DHCP client for charrua-core itself.  I got to write a lot of docstrings for this library!</p>
<p>I was also very excited to see the work that <a href="https://github.com/cfcs">cfcs</a> has been doing on building more interesting MirageOS unikernels for use in QubesOS.  I had seen static screenshots of <a href="https://github.com/cfcs/mirage-framebuffer">mirage-framebuffer</a> in action which didn't do it justice at all; seeing it in person (including self-hosted slides!) was really cool, and inspired me to think about how to fix <a href="https://discuss.ocaml.org/t/mirageos-parametric-compilation-depending-on-target/1005/12">some ugliness in writing unikernels using the framebuffer</a>. The <a href="https://github.com/cfcs/passmenage">experimental password manager</a> is something I hope to be using by the next hack retreat.  Maybe 2017 really is <a href="https://mirage.io/blog/qubes-target">the year of unikernels on the desktop</a>!</p>
<p>tg, hannes, halfdan, samoht, and several others (sorry if I missed you!) worked hard to get some unikernel infrastructure up and running at Priscilla, including homegrown DHCP and DNS services, self-hosted pastebin and etherpad, an FTP server for blazing-fast local filesharing, and (maybe most importantly!) a local <code>opam</code> mirror.  I hope that in future hack retreats, we can set up a local <code>git</code> server using the <a href="https://github.com/mirage/ocaml-git">OCaml git implementation</a>, which got some major improvements during the hack retreat thanks to dinosaure (from the other side of the world!) and samoht.</p>
<p>Finally, the <a href="https://github.com/talex5/qubes-mirage-firewall">qubes-mirage-firewall</a> got a lot of attention this hack retreat.  (The firewall itself incorporates some past hack retreat work by me and talex5.)  h01ger worked on the <a href="http://layer-acht.org/thinking/blog/20171204-qubes-mirage-firewall/">reproducibility of the build</a>, and cfcs did some work on passing ruleset changes to the firewall -- currently, users of qubes-mirage-firewall need to rebuild the unikernel with ruleset changes.</p>
<p>We also uncovered some strangeness and bugs in the <a href="https://github.com/mirage/mirage/pull/874">handling of Xen block-storage devices</a>, which I was happy to fix in advance of the more intense use of block storage I expect with <a href="https://github.com/g2p/wodan">wodan</a> and <a href="https://github.com/mirage/irmin">irmin</a> in the near future.</p>
<h2>Oh yes, and somewhere in there, I did find time to see some cats, eat tajine, wander around the medina, and enjoy all of the wonder that <a href="http://queenofthemedina.com">Priscilla, the Queen of the Medina</a> and her lovely hosts have to offer.  Thanks to everyone who did the hard work of organizing, feeding, and laundering this group of itinerant hackers!</h2>
<h2>Ximin Luo</h2>
<p>This was my third MirageOS hack retreat, I continued right where I left off last time.</p>
<p>I've had a pet project for a while to develop a end-to-end secure protocol for group messaging. One of its themes is to completely separate the transport and application layers, by sticking an end-to-end secure session layer in between them, with the aim of unifying all the <em>secure messaging</em> protocols that exist today. Like many pet projects, I haven't had much time to work on it recently, and took the chance to this week.</p>
<p>I worked on implementing a consistency checker for the protocol. This allows chat members to verify everyone is seeing and has seen the same messages, and to distinguish between other members being silent (not sending anything) vs the transport layer dropping packets (either accidentally or maliciously). This is built on top of my as-yet-unreleased pure library for setting timeouts, monitors (scheduled tasks) and expectations (promises that can timeout), which I worked on in the previous hackathons.</p>
<p>I also wrote small libraries for doing 3-valued and 4-valued logic, useful for implementing complex control flows where one has to represent different control states like <code>success</code>, <code>unknown/pending</code>, <code>temporary failure</code>, <code>permanent failure</code>, and be able to compose these states in a logically coherent way.</p>
<p>For my day-to-day work I work on the <a href="https://reproducible-builds.org/">Reproducible Builds</a>, and as part of this we write patches and/or give advice to compilers on how to generate output deterministically. I showed Gabriel Scherer our testing framework with our results for various ocaml libraries, and we saw that the main remaining issue is that the build process embeds absolute paths into the output. I explained our <code>BUILD_PATH_PREFIX_MAP</code> mechanism for stripping this information without negatively impacting the build result, and he implemented this for the ocaml compiler. It works for findlib! Then, I need to run some wider tests to see the overall effect on all ocaml packages. Some of the non-reproducibility is due to GCC and/or GAS, and more analysis is needed to distinguish these cases.</p>
<p>I had very enjoyable chats with Anton Bachin about continuation-passing style, call-cc, coroutines, and lwt; and with Gabriel Scherer about formal methods, proof systems, and type systems.</p>
<p>For fun times I carried on the previous event's tradition of playing Cambio, teaching it to at least half of other people here who all seemed to enjoy it very much! I also organised a few mini walks to places a bit further out of the way, like Gueliz and the Henna Art Cafe.</p>
<p>On the almost-last day, I decided to submerge myself in the souks at 9am or so and explored it well enough to hopefully never get lost in there ever again! The existing data on OpenStreetMap for the souks is actually er, <em>topologically accurate</em> shall we say, except missing some side streets. :)</p>
<h2>All-in-all this was another enjoyable event and it was good to be back in a place with nice weather and tasty food!</h2>
<h2>Martin Keegan</h2>
<p>My focus at the retreat was on working out how to improve the documentation.
This decomposed into</p>
<ul>
<li>encouraging people to fix the build for the docs system
</li>
<li>talking to people to find out what the current state of Mirage is
</li>
<li>actually writing some material and getting it merged
</li>
</ul>
<p>What I learnt was</p>
<ul>
<li>which backends are in practice actually usable today
</li>
<li>the current best example unikernels
</li>
<li>who can actually get stuff done
</li>
<li>how the central configuration machinery of <code>mirage configure</code> works today
</li>
<li>what protocols and libraries are currently at the coal-face
</li>
<li>that some important documentation exists in the form of blog posts
</li>
</ul>
<p>I am particularly grateful to Mindy Preston and Thomas Gazagnaire for
their assistance on documentation. I am continuing the work now that I
am back in Cambridge.</p>
<p>The tone and pace of the retreat was just right, for which Hannes is
due many thanks.</p>
<p>On the final day, I gave a brief presentation about the use of OCaml
for making part of a vote counting system, focusing on the practicalities
and cost of explaining to laymen the guarantees provided by <code>.mli</code>
interface files, with an implicit comparison to the higher cost in more
conventional programming languages.</p>
<h2>The slides for the talk as delivered <a href="http://mk.ucant.org/media/talks/2017-12-05_OCaml-Marrakesh-STV/">are here</a>, but it deserves its own
blog post.</h2>
<h2>Michele Orrù</h2>
<p>This year's Marrakech experience has been been a bit less productive than
past years'. I indulged a bit more chatting to people, and pair programming with
them.</p>
<p>I spent some of my individual time time getting my hands dirty with the Jsonm
library, hoping that I would have been able to improve the state of my
ocaml-letsencrypt library; I also learned how to integrate ocaml API in C,
improving and updating the ocaml-scrypt library, used by another fellow mirage
user in order to develop its own password manager.
Ultimately, I'm not sure either direction I took was good: a streaming Json library is
perhaps not the best choice for an application that shares few jsons (samoht
should have been selling more his <a href="https://github.com/mirage/ezjsonm">easyjson</a> library!), and the ocaml-scrypt
library has been superseeded by the pure implementation <a href="https://github.com/abeaumont/ocaml-scrypt-kdf">ocaml-scrypt-kdf</a>, which
supposedly will make the integration in mirage easier.</p>
<h2>The overall warm atmosphere and the overall positive attitude of the
group make me still think of this experience as a positive learning experience,
and how they say: failure the best teacher is.</h2>
<h2>Reynir Björnsson</h2>
<p>For the second time this year (and ever) I went to Marrakech to participate in the MirageOS hack retreat / unconference.
I wrote about my <a href="http://reynir.dk/posts/2017-03-20-11-27-Marrakech%202017.html">previous trip</a>.</p>
<h3>The walk from the airport</h3>
<p>Unlike the previous trip I didn't manage to meet any fellow hackers at the RAK airport.
Considering the annoying haggling taking a taxi usually involves and that the bus didn't show up last time I decided to walk the 5.3 km from the airport to Priscilla (the venue).
The walk to <a href="https://en.wikipedia.org/wiki/Jemaa_el-Fnaa">Jemaa el-Fnaa</a> (AKA 'Big Square') was pretty straight forward.
Immediately after leaving the airport area I discovered every taxi driver would stop and tell me I needed a ride.
I therefore decided to walk on the opposite side of the road.
This made things more difficult because I then had more difficulties reading the road signs.
Anyway, I found my way to the square without any issues, although crossing the streets on foot requires cold blood and nerves of steel.</p>
<p>Once at the square I noticed a big café with lots of lights that I recognized immediately.
I went past it thinking it was Café de France.
It was not.
I spent about 30-40 minutes practicing my backtracking skills untill I finally gave up.
I went back to the square in order to call Hannes and arrange a pickup.
The two meeting points at the square was some juice stand whose number I couldn't remember and Café de France, so I went looking for the latter.
I quickly realized my mistake, and once I found the correct café the way to Priscilla was easy to remember.</p>
<p>All in all I don't recommend walking unless you <em>definitely</em> know the way and is not carrying 12-15 kg of luggage.</p>
<h3>People</h3>
<p>Once there I met new and old friends.
Some of the old friends I had seen at <a href="https://bornhack.dk">Bornhack</a> while others I hadn't seen since March.
In either case it was really nice to meet them again!
As for the new people it's amazing how close you can get with strangers in just a week.
I had some surprisingly personal conversations with people I had only met a few days prior.
Lovely people!</p>
<h3>My goals</h3>
<p>Two months prior to the hack retreat I had started work on implementing the ssh-agent protocol.
I started the project because I couldn't keep up with Christiano's <a href="https://github.com/haesbaert/awa-ssh">awa-ssh</a> efforts in my limited spare time, and wanted to work on something related that might help that project.
My goals were to work on my <a href="https://github.com/reynir/ocaml-ssh-agent">ocaml-ssh-agent</a> implementation as well as on awa-ssh.</p>
<p>Before going to Marrakech I had had a stressful week at work.
I had some things to wrap up before going to a place without a good internet connection.
I therefore tried to avoid doing anything on the computer the first two days.
On the plane to Marrakech I had taken up knitting again - something I hadn't done in at least two years.
The morning of the first day I started knitting.
Eventually I had to stop knitting because I had drunk too much coffee for me to have steady enough hands to continue, so I started the laptop despite my efforts not to.
I then looked at awa-ssh, and after talking with Christiano I made the first (and sadly only) contribution to awa-ssh of that trip:
The upstream <a href="https://github.com/mirleft/ocaml-nocrypto">nocrypto</a> library had been changed in a way that required changes to awa-ssh.
I rewrote the digest code to reflect the upstream changes, and refactored the code on suggestion by Christiano.</p>
<p>In ocaml-ssh-agent I was already using <a href="https://github.com/inhabitedtype/angstrom">angstrom</a> for parsing ssh-agent messages.
I rewrote the serialization from my own brittle cstruct manipulations to using <a href="https://github.com/inhabitedtype/faraday">faraday</a>.
This worked great, except I never quite understood how to use the <code>Faraday_lwt_unix</code> module.
Instead I'm serializing to a string and then writing that string to the <code>SSH_AUTH_SOCK</code>.</p>
<h3>GADT !!!FUN!!!</h3>
<p>The ssh-agent is a request-response protocol.
Only a certain subset of the responses are valid for each request.
I wanted to encode that relationship into the types so that the user of the library wouldn't have to deal with invalid responses.
In order to do that I got help by <a href="https://github.com/aantron">@aantron</a> to implement this with GADTs.
The basic idea is a phantom type is added to the request and response types.
The phantom type, called request_type, is a polymorphic variant that reflects the kind of requests that are possible.
Each response is parameterized with a subset of this polymorphic variant.
For example, every request can fail, so <code>Ssh_agent_failure</code> is parameterized with the whole set,
while <code>Ssh_agent_identities_answer</code> is parameterized with <code> `Ssh_agent_request_identities</code>,
and <code>Ssh_agent_success</code> is parameterized with <code> `Ssh_agent_successable</code> - a collapse of all the request types that can either return success or failure.</p>
<p>This worked great except it broke the typing of my parser -
The compiler can't guess what the type parameter should be for the resulting <code>ssh_agent_response</code>.
To work around that <a href="https://github.com/gasche">@gasche</a> helped me solve that problem by introducing an existential type:</p>
<pre><code class="language-OCaml">    type any_ssh_agent_response = Any_response : 'a ssh_agent_response -&gt; any_ssh_agent_response
</code></pre>
<p>Using this I could now write a function <code>unpack_any_response</code> which 'discards' every response that doesn't make sense for a particular request.
Its type is the following:</p>
<pre><code class="language-OCaml">    val unpack_any_response : 'a ssh_agent_request -&gt; any_ssh_agent_response -&gt;
                              ('a ssh_agent_response, string) result
</code></pre>
<p>Now I want to write a <code>listen</code> function that takes a handler of type <code>'a ssh_agent_request -&gt; 'a ssh_agent_response</code>, in other words a handler that can only create valid response types.
This unfortunately doesn't type check.
The parser returns an existential
<code>type any_ssh_agent_request = Any_request : 'req_type ssh_agent_request -&gt; any_ssh_agent_request</code>.
This is causing me a problem: the <code>'req_type</code> existential would escape.
I do not know how to solve this problem, or if it's possible to solve it at all.
I discussed this issue with <a href="http://github.com/infinity0">@infinity0</a> after the retreat, and we're not very optimistic.
Perhaps someone in <code>#ocaml</code> on Freenode might know a trick.</p>
<pre><code class="language-OCaml">    let listen ((ic, oc) : in_channel * out_channel)
        (handler : 'a Ssh_agent.ssh_agent_request -&gt; 'a Ssh_agent.ssh_agent_response) =
      match Angstrom_unix.parse Ssh_agent.Parse.ssh_agentc_message ic with
      | { len = 0; _ }, Ok (Ssh_agent.Any_request request) -&gt;
        Ok (Ssh_agent.Any_response (handler response))
      | { len; _ }, Ok _ -&gt;
        Error &quot;Additional data in reply&quot;
      | _, Error e -&gt;
        Error e
</code></pre>
<h3>Ideas for uses of ocaml-ssh-agent</h3>
<p>Besides the obvious use in a ssh-agent client in a ssh client, the library could be used to write an ssh-agent unikernel.
This unikernel could then be used in <a href="https://www.qubes-os.org/">Qubes OS</a> in the same way as <a href="https://github.com/henn/qubes-app-split-ssh">Qubes Split SSH</a> where the ssh-agent is running in a separate VM not connected to the internet.
Furthermore, <a href="https://github.com/cfcs">@cfcs</a> suggested an extension could be implemented such that only identities relevant for a specific host or host key are offered by the ssh-agent.
When one connects to e.g. github.com using ssh keys all the available public keys are sent to the server.
This allows the server to do finger printing of the client since the set of keys is likely unique for that machine, and may leak information about keys irrelevant for the service (Github).
This requires a custom ssh client which may become a thing with awa-ssh soon-ish.</p>
<h3>Saying goodbye</h3>
<p>Leaving such lovely people is always difficult.
The trip to the airport was emotional.
It was a chance to spend some last few moments with some of the people from the retreat knowing it was also the last chance this time around.
I will see a lot of the participants at 34c3 in 3 weeks already, while others I might not see again in the near future.
I do hope to stay in contact with most of them online!</p>
<h2>Thank you for yet another great retreat!</h2>
<p>Many thanks to everyone involved!  The hostel is already booked for <a href="http://retreat.mirage.io">another retreat in March 2018</a>...</p>
|js};
      };
      {
        updated = {js|2017-03-06 14:00|js};
        authors =
          [
            {
              name = {js|Thomas Gazagnaire|js};
              uri = Some {js|http://gazagnaire.org|js};
              email = Some {js|thomas@gazagnaire.org|js};
            };
          ];
        subject = {js|Easy distributed analytics with Irmin 1.0|js};
        permalink = {js|irmin-1.0|js};
        body =
          {js|<p>I am really happy to announce the release of Irmin 1.0, which fully
supports MirageOS 3.0 and which brings a simpler and yet more
expressive API. Irmin is a library for designing Git-like distributed
databases, with built-in branching, snapshoting, reverting and
auditing capabilities. With Irmin, applications can create tailored
mergeable datastructures to scale seamlessly. Applications built on
top of Irmin include <a href="https://tezos.com/">Tezos</a>, a distributed ledger,
<a href="https://github.com/docker/datakit">Datakit</a>, a distributed and reactive key-value store, and
<a href="https://github.com/talex5/cuekeeper">cuekeeper</a>, a web-based GTD system. Read <a href="https://mirage.io/blog/introducing-irmin">&quot;Introducing
Irmin: Git-like distributed, branchable storage&quot;</a> for a
description of the concepts and high-level architecture of the system.</p>
<p>To install Irmin 1.0:</p>
<pre><code>opam install irmin
</code></pre>
<p>The running example in this post will be an imaginary model for
collecting distributed metrics (for instance to count network
packets). In this model, every node has a unique ID, and uses Irmin to
store metrics names and counters. Every node is also a distributed
collector and can sync with the metrics of other nodes at various
points in time. Users of the application can read metrics for the
network from any node. We want the metrics to be eventually
consistent.</p>
<p>This post will describe:</p>
<ul>
<li>how to define the metrics as a mergeable data-structures;
</li>
<li>how to create a new Irmin store with the metrics, the basic
operations that are available and how to define atomic operations; and
</li>
<li>how to create and merge branches.
</li>
</ul>
<h3>Mergeable Contents</h3>
<p>Irmin now exposes <code>Irmin.Type</code> to create new mergeable contents more
easily. For instance, the following type defines the property of
simple metrics, where <code>name</code> is a human-readable name and <code>gauge</code> is a
metric counting the number of occurences for some kind of event:</p>
<pre><code class="language-ocaml">type metric = {
  name : string;
  gauge: int64;
}
</code></pre>
<p>First of all, we need to reflect the structure of the type, to
automatically derive serialization (to and from JSON, binary encoding,
etc) functions:</p>
<pre><code class="language-ocaml">let metric_t =
  let open Irmin.Type in
  record &quot;metric&quot; (fun name gauge -&gt; { name; gauge })
  |+ field &quot;name&quot;  string (fun t -&gt; t.name)
  |+ field &quot;gauge&quot; int64    (fun t -&gt; t.gauge)
  |&gt; sealr
</code></pre>
<p><code>record</code> is used to describe a new (empty) record with a name and a
constructor; <code>field</code> describes record fields with a name a type and an
accessor function while <code>|+</code> is used to stack fields into the
record. Finally <code>|&gt; sealr</code> seals the record, e.g. once applied no more
fields can be added to it.</p>
<p>All of the types in Irmin have such a description, so they can be
easily and efficiently serialized (to disk and/or over the
network). For instance, to print a value of type <code>metric</code> as a JSON object,
one can do:</p>
<pre><code class="language-ocaml">let print m = Fmt.pr &quot;%a\\n%!&quot; (Irmin.Type.pp_json metric_t) m
</code></pre>
<p>Once this is defined, we now need to write the merge function. The
consistency model that we want to define is the following:</p>
<ul>
<li>
<p><code>name</code> : can change if there is no conflicts between branches.</p>
</li>
<li>
<p><code>gauge</code>: the number of events seen on a branch. Can be updated
either by incrementing the number (because events occured) or by
syncing with other nodes partial knowledge. This is very similar to
<a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type">conflict-free replicated datatypes</a> and related
<a href="https://en.wikipedia.org/wiki/Vector_clock">vector-clock</a> based algorithms. However, in Irmin we keep the
actual state as simple as possible: for counters, it is a single
integer -- but the user needs to provide an external 3-way merge
function to be used during merges.</p>
</li>
</ul>
<p>Similarly to the type definitions, the 3-way merge functions can
defined using &quot;merge&quot; combinators. Merge combinators for records are
not yet available (but they are planned on the roadmap), so we need to
use <code>Irmin.Merge.like</code> to map the record definition to a pair:</p>
<pre><code class="language-ocaml">let merge =
  let open Irmin.Merge in
  like metric_t (pair string counter)
    (fun x -&gt; x.name, x.gauge)
    (fun (name, gauge) -&gt; {name; gauge })
  |&gt; option
</code></pre>
<p>The final step to define a mergeable data-structure is to wrap
everything into a module satisfying the <a href="http://mirage.github.io/irmin/Irmin.Contents.S.html">Irmin.Contents.S</a>
signature:</p>
<pre><code class="language-ocaml">module Metric: Irmin.Contents.S with type t = metric = struct
  type t = metric
  let t = metric_t
  let merge = merge
  let pp = Irmin.Type.pp_json metric_t
  let of_string s =
    Irmin.Type.decode_json metric_t (Jsonm.decoder (`String s))
end
</code></pre>
<h3>Creating an Irmin Store</h3>
<p>To create a key/value store to store metrics, using the on-disk Git
format:</p>
<pre><code class="language-ocaml">module Store = Irmin_unix.Git.FS.KV(Metric)
let config = Irmin_git.config &quot;/tmp/irmin&quot;
let info fmt = Irmin_unix.info ~author:&quot;Thomas&quot; fmt
</code></pre>
<p><code>Store</code> <a href="http://mirage.github.io/irmin/Irmin.S.html">exposes</a> various functions to create and manipulate
Irmin stores. <code>config</code> is used to configure Irmin repositories based
on <code>Store</code>. In that example we decided to keep the store state in
<code>&quot;/tmp/irmin&quot;</code> (which can be inspected using the usual Git
tools). <code>info</code> is the function used to create new commit information:
<code>Irmin_unix.info</code> use the usual POSIX clock for timestamps, and can
also be tweaked to specify the author name.</p>
<p>The most common functions to create an Irmin store are
<code>Store.Repo.create</code> to create an Irmin repository and <code>Store.master</code>
to get a handler on the <code>master</code> branch in that repository. For
instance, using the OCaml toplevel:</p>
<pre><code class="language-ocaml"># open Lwt.Infix;;

# let repo = Store.Repo.v config;;
val repo : Store.Repo.t Lwt.t = &lt;abstr&gt;
# let master = repo &gt;&gt;= fun repo -&gt; Store.master repo;;
val master : Store.t Lwt.t = &lt;abstr&gt;
</code></pre>
<p><code>Store</code> also exposes the usual key/value base operations using
<a href="http://mirage.github.io/irmin/Irmin.S.html#VALfind">find</a> and
<a href="http://mirage.github.io/irmin/Irmin.S.html#VALset">set</a>. All the
operations are reflected as Git state.</p>
<pre><code class="language-ocaml">  Lwt_main.run begin
      Store.Repo.v config &gt;&gt;= Store.master &gt;&gt;= fun master -&gt;
      Store.set master
        ~info:(info &quot;Creating a new metric&quot;)
        [&quot;vm&quot;; &quot;writes&quot;] { name = &quot;write Kb/s&quot;; gauge = 0L }
      &gt;&gt;= fun () -&gt;
      Store.get master [&quot;vm&quot;; &quot;writes&quot;] &gt;|= fun m -&gt;
      assert (m.gauge = 0L);
    end
</code></pre>
<p>Note that <code>Store.set</code> is atomic: the implementation ensures that no
data is ever lost, and if someone else is writing on the same path at
the same, the operation is retried until it succeeds (see <a href="https://en.wikipedia.org/wiki/Optimistic_concurrency_control">optimistic
transaction control</a>). More complex atomic operations are also
possible: the API also exposes function to read and write subtrees
(simply called trees) instead of single values. Trees are very
efficient: they are immutable so all the reads are cached in memory
and done only when really needed; and write on disk are only done the
final transaction is commited. Trees are also stored very efficiently
in memory and on-disk as they are deduplicated. For users of previous
releases of Irmin: trees replaces the concept of views, but have a
very implementation and usage.</p>
<p>An example of a tree transaction is a custom-defined move function:</p>
<pre><code class="language-ocaml">let move t src dst =
  Store.with_tree t
    ~info:(info &quot;Moving %a to %a&quot; Store.Key.pp src Store.Key.pp dst)
    [] (fun tree -&gt;
          let tree = match tree with
            | None -&gt; Store.Tree.empty
            | Some tree -&gt; tree
          in
          Store.Tree.get_tree tree src &gt;&gt;= fun v -&gt;
          Store.Tree.remove tree src &gt;&gt;= fun _ -&gt;
          Store.Tree.add_tree tree dst v &gt;&gt;= Lwt.return_some
    )
</code></pre>
<h3>Creating and Merging Branches</h3>
<p>They are two kinds of stores in Irmin: permanent and temporary
ones. In Git-speak, these are &quot;branches&quot; and &quot;detached
heads&quot;. Permanent stores are created from branch names using
<code>Store.of_branch</code> (<code>Store.master</code> being an alias to <code>Store.of_branch Store.Branch.master</code>) while temporary stores are created from commit
using <code>Store.of_commit</code>.</p>
<p>The following example show how to clone the master branch, how to make
concurrent update to both branches, and how to merge them back.</p>
<p>First, let's define an helper function to increment the <code>/vm/writes</code>
gauge in a store <code>t</code>, using a transaction:</p>
<pre><code class="language-ocaml">let incr t =
  let path = [&quot;vm&quot;; &quot;writes&quot;] in
  Store.with_tree ~info:(info &quot;New write event&quot;) t path (fun tree -&gt;
      let tree = match tree with
        | None -&gt; Store.Tree.empty
        | Some tree -&gt; tree
      in
      (Store.Tree.find tree [] &gt;|= function
        | None   -&gt; { name = &quot;writes in kb/s&quot;; gauge = 0L }
        | Some x -&gt; { x with gauge = Int64.succ x.gauge })
      &gt;&gt;= fun m -&gt;
      Store.Tree.add tree [] m
      &gt;&gt;= Lwt.return_some
    )
</code></pre>
<p>Then, the following program create an empty gauge on <code>master</code>,
increment the metrics, then create a <code>tmp</code> branch by cloning
<code>master</code>. It then performs two increments in parallel in both
branches, and finally merge <code>tmp</code> back into <code>master</code>. The result is a
gauge which have been incremented three times in total: the &quot;counter&quot;
merge function ensures that the result counter is consistent: see
<a href="http://kcsrk.info/ocaml/irmin/crdt/2017/02/15/an-easy-interface-to-irmin-library/">KC's blog post</a> for more details about the semantic of recursive
merges.</p>
<pre><code class="language-ocaml">let () =
  Lwt_main.run begin
    Store.Repo.v config &gt;&gt;= Store.master &gt;&gt;= fun master -&gt; (* guage 0 *)
    incr master &gt;&gt;= fun () -&gt; (* gauge = 1 *)
    Store.clone ~src:master ~dst:&quot;tmp&quot; &gt;&gt;= fun tmp -&gt;
    incr master &gt;&gt;= fun () -&gt; (* gauge = 2 on master *)
    incr tmp    &gt;&gt;= fun () -&gt; (* gauge = 2 on tmp *)
    Store.merge ~info:(info &quot;Merge tmp into master&quot;) tmp ~into:master
    &gt;&gt;= function
    | Error (`Conflict e) -&gt; failwith e
    | Ok () -&gt;
      Store.get master [&quot;vm&quot;; &quot;writes&quot;] &gt;|= fun m -&gt;
      Fmt.pr &quot;Gauge is %Ld\\n%!&quot; m.gauge
  end
</code></pre>
<h3>Conclusion</h3>
<p>Irmin 1.0 is out. Defining new mergeable contents is now simpler. The
Irmin API to create stores as also been simplified, as well as
operations to read and write atomically. Finally, flexible first-class
support for immutable trees has also been added.</p>
<p>Send us feedback on the <a href="https://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">MirageOS mailing-list</a> or on the <a href="https://github.com/mirage/irmin">Irmin
issue tracker on GitHub</a>.</p>
|js};
      };
      {
        updated = {js|2017-03-01 14:00|js};
        authors =
          [
            {
              name = {js|Mindy Preston|js};
              uri = Some {js|https://github.com/yomimono|js};
              email = Some {js|mindy.preston@cl.cam.ac.uk|js};
            };
          ];
        subject = {js|Adding the Qubes target to Mirage|js};
        permalink = {js|qubes-target|js};
        body =
          {js|<p>When I got a new laptop in early 2016, I decided to try out this <a href="https://qubesos.org">QubesOS</a> all the cool kids were talking about.  QubesOS also runs a hypervisor, but it nicely supports running multiple virtual machines for typical user tasks, like looking at cat photos with a web browser, viewing a PDF, listening to music, or patching MirageOS.  QubesOS also uses Xen, which means we should be able to even <em>run</em> our MirageOS unikernels on it... right?</p>
<p>The answer is <a href="http://roscidus.com/blog/blog/2016/01/01/a-unikernel-firewall-for-qubesos/">yes, after a fashion</a>.  Thomas Leonard did the hard work of writing <a href="https://github.com/mirage/mirage-qubes">mirage-qubes</a>, a library that interfaces nicely with the QubesOS management layer and allows MirageOS unikernels to boot, configure themselves, and run as managed by the Qubes management system.  That solution is nice for generating, once, a unikernel that you're going to run all the time under QubesOS, but building a unikernel that will boot and run on QubesOS requires QubesOS-specific code in the unikernel itself.  It's very unfriendly for testing generic unikernels, and as the release manager for Mirage 3, I wanted to do that pretty much all the time.</p>
<p>The command-line <code>mirage</code> utility was made to automatically build programs against libraries that are specific to a target only when the user has asked to build for that target, which is the exact problem we have!  So let's try to get to <code>mirage configure -t qubes</code>.</p>
<h2>teach a robot to do human tricks</h2>
<p>In order for Qubes to successfully boot our unikernel, it needs to do at least two (but usually three) things:</p>
<ul>
<li>start a qrexec listener, and respond to requests from dom0
</li>
<li>start a qubes-gui listener, and respond to requests from dom0
</li>
<li>if we're going to do networking (usually we are), get the network configuration from qubesdb
</li>
</ul>
<p>There's code for doing all of these available in the <a href="https://github.com/mirage/mirage-qubes">mirage-qubes</a> library, and a nice example available at <a href="https://github.com/talex5/qubes-mirage-skeleton">qubes-mirage-skeleton</a>.  The example at qubes-mirage-skeleton shows us what we have to plumb into a MirageOS unikernel in order to boot in Qubes.  All of the important stuff is in <code>unikernel.ml</code>.  We need to pull the code that connects to RExec and GUI:</p>
<pre><code class="language-ocaml">(* Start qrexec agent, GUI agent and QubesDB agent in parallel *)
   let qrexec = RExec.connect ~domid:0 () in
   let gui = GUI.connect ~domid:0 () in
</code></pre>
<p><code>qrexec</code> and <code>gui</code> are Lwt threads that will resolve in the records we need to pass to the respective <code>listen</code> functions from the <code>RExec</code> and <code>GUI</code> modules.  We'll state the rest of the program in terms of what to do once they're connected with a couple of monadic binds:</p>
<pre><code class="language-ocaml">    (* Wait for clients to connect *)
    qrexec &gt;&gt;= fun qrexec -&gt;
    let agent_listener = RExec.listen qrexec Command.handler in
</code></pre>
<p><code>agent_listener</code> is called much later in the program.  It's not something we'll use generally in an adaptation of this code for a generic unikernel running on QubesOS -- instead, we'll invoke <code>RExec.listen</code> with a function that disregards input.</p>
<pre><code class="language-ocaml">    gui &gt;&gt;= fun gui -&gt;
    Lwt.async (fun () -&gt; GUI.listen gui);
</code></pre>
<p>We use <code>gui</code> right away, though.  <code>Lwt.async</code> lets us start an Lwt thread that the rest of our program logic isn't impacted by, but needs to be hooked into the event loop.  The function we define in this call asks <code>GUI.listen</code> to handle incoming events for the <code>gui</code> record we got from <code>GUI.connect</code>.</p>
<p><code>qubes-mirage-skeleton</code> does an additional bit of setup:</p>
<pre><code class="language-ocaml">    Lwt.async (fun () -&gt;
      OS.Lifecycle.await_shutdown_request () &gt;&gt;= fun (`Poweroff | `Reboot) -&gt;
      RExec.disconnect qrexec
    );
</code></pre>
<p>This hooks another function into the event loop: a listener which hears shutdown requests from <a href="https://github.com/mirage/mirage-platform/blob/2d044a499824c98ee2f067b71110883e9226d8cf/xen/lib/lifecycle.ml#L21">OS.Lifecycle</a> and disconnects <code>RExec</code> when they're heard.  The <code>disconnect</code> has the side effect of terminating the <code>agent_listener</code> if it's running, as documented in <a href="https://github.com/talex5/mirage-qubes/master/lib/qubes.mli#L130%22">mirage-qubes</a>.</p>
<p><code>qubes-mirage-skeleton</code> then configures its networking (we'll talk about this later) and runs a test to make sure it can reach the outside world.  Once that's finished, it calls the <code>agent_listener</code> defined above, which listens for commands via <code>RExec.listen</code>.</p>
<h2>making mirageos unikernels</h2>
<p>Building MirageOS unikernels is a three-phase process:</p>
<ul>
<li>mirage configure: generate main.ml unifying your code with the devices it needs
</li>
<li>make depend: make sure you have the libraries required to build the final artifact
</li>
<li>make: build your application against the specified configuration
</li>
</ul>
<p>In order to get an artifact that automatically includes the code above, we need to plumb the tasks above into <code>main.ml</code>, and the libraries they depend on into <code>make depend</code>, via <code>mirage configure</code>.</p>
<h2>let's quickly revisit what impl passing usually looks like</h2>
<p>Applications built to run as MirageOS unikernels are written as OCaml functors.  They're parameterized over OCaml modules providing implementations of some functionality, which is stated as a module type.  For example, here's a MirageOS networked &quot;hello world&quot;:</p>
<pre><code class="language-ocaml">module Main (N: Mirage_net_lwt.S) = struct

  let start (n : N.t)  =
    N.write n @@ Cstruct.of_string &quot;omg hi network&quot; &gt;&gt;= function
    | Error e -&gt; Log.warn (fun f -&gt; f &quot;failed to send message&quot;); Lwt.return_unit
    | Ok () -&gt; Log.info (fun f -&gt; f &quot;said hello!&quot;); Lwt.return_unit

end
</code></pre>
<p>Our program is in a module that's parameterized over the module <code>N</code>, which can be any module that matches the module type <code>Mirage_net_lwt.S</code>.  The entry point for execution is the <code>start</code> function, which takes one argument of type <code>N.t</code>.  This is the usual pattern for Mirage unikernels, powered by Functoria's <a href="/blog/introducing-functoria">invocation of otherworldly functors</a>.</p>
<p>But there are other modules which aren't explicitly passed.  Since MirageOS version 2.9.0, for example, a <code>Logs</code> module has been available to MirageOS unikernels.  It isn't explicitly passed as a module argument to <code>Main</code>, because it's assumed that all unikernels will want to use it, and so it's always made available.  The <code>OS</code> module is also always available, although the implementation will be specific to the target for which the unikernel was configured, and there is no module type to which the module is forced to conform.</p>
<h2>providing additional modules</h2>
<p>Let's look first at fulfilling the <code>qrexec</code> and <code>gui</code> requirements, which we'll have to do for any unikernel that's configured with <code>mirage configure -t qubes</code>.</p>
<p>When we want a module passed to the generated unikernel, we start by making a <code>job</code>.  Let's add one for <code>qrexec</code> to <code>lib/mirage.ml</code>:</p>
<pre><code class="language-ocaml">let qrexec = job
</code></pre>
<p>and we'll want to define some code for what <code>mirage</code> should do if it's determined from the command-line arguments to <code>mirage configure</code> that a <code>qrexec</code> is required:</p>
<pre><code class="language-ocaml">let qrexec_qubes = impl @@ object
  inherit base_configurable
  method ty = qrexec
  val name = Name.ocamlify @@ &quot;qrexec_&quot;
  method name = name
  method module_name = &quot;Qubes.RExec&quot;
  method packages = Key.pure [ package &quot;mirage-qubes&quot; ]
  method configure i =
    match get_target i with
    | `Qubes -&gt; R.ok ()
    | _ -&gt; R.error_msg &quot;Qubes remote-exec invoked for non-Qubes target.&quot;
  method connect _ modname _args =
    Fmt.strf
      &quot;@[&lt;v 2&gt;\\
       %s.connect ~domid:0 () &gt;&gt;= fun qrexec -&gt;@ \\
       Lwt.async (fun () -&gt;@ \\
       OS.Lifecycle.await_shutdown_request () &gt;&gt;= fun _ -&gt;@ \\
       %s.disconnect qrexec);@ \\
       Lwt.return (`Ok qrexec)@]&quot;
      modname modname
end
</code></pre>
<p>This defines a <code>configurable</code> object, which inherits from the <code>base_configurable</code> class defined in Mirage.  The interesting bits for this <code>configurable</code> are the methods <code>packages</code>, <code>configure</code>, and <code>connect</code>. <code>packages</code> is where the dependency on <code>mirage-qubes</code> is declared.  <code>configure</code> will terminate if <code>qrexec_qubes</code> has been pulled into the dependency graph but the user invoked another target (for example, <code>mirage configure -t unix</code>).  <code>connect</code> gives the instructions for generating the code for <code>qrexec</code> in <code>main.ml</code>.</p>
<p>You may notice that <code>connect</code>'s <code>strf</code> call doesn't refer to <code>Qrexec</code> directly, but rather takes a <code>modname</code> parameter.  Most of the modules referred to will be the result of some functor application, and the previous code generation will automatically name them; the only way to access this name is via the <code>modname</code> parameter.</p>
<p>We do something similar for <code>gui</code>:</p>
<pre><code class="language-ocaml">let gui = job

let gui_qubes = impl @@ object
  inherit base_configurable
  method ty = gui
  val name = Name.ocamlify @@ &quot;gui&quot;
  method name = name
  method module_name = &quot;Qubes.GUI&quot;
  method packages = Key.pure [ package &quot;mirage-qubes&quot; ]
  method configure i =
    match get_target i with
    | `Qubes -&gt; R.ok ()
    | _ -&gt; R.error_msg &quot;Qubes GUI invoked for non-Qubes target.&quot;
  method connect _ modname _args =
    Fmt.strf
      &quot;@[&lt;v 2&gt;\\
       %s.connect ~domid:0 () &gt;&gt;= fun gui -&gt;@ \\
       Lwt.async (fun () -&gt; %s.listen gui);@ \\
       Lwt.return (`Ok gui)@]&quot;
      modname modname
end
</code></pre>
<p>For details on what both <code>gui_qubes</code> and <code>qrexec_qubes</code> are actually doing in their <code>connect</code> blocks and why, <a href="http://roscidus.com/blog/blog/2016/01/01/a-unikernel-firewall-for-qubesos/">talex5's post on building the QubesOS unikernel firewall</a>.</p>
<h3>QRExec for nothing, GUI for free</h3>
<p>We'll need the <code>connect</code> function for both of these configurables to be run before the <code>start</code> function of our unikernel.  But we also don't want a corresponding <code>QRExec.t</code> or <code>GUI.t</code> to be passed to our unikernel, nor do we want to parameterize it over the module type corresponding to either module, since either of these would be nonsensical for a non-Qubes target.</p>
<p>Instead, we need to have <code>main.ml</code> take care of this transparently, and we don't want any of the results passed to us.  In order to accomplish this, we'll need to change the final invocation of Functoria's <code>register</code> function from <code>Mirage.register</code>:</p>
<pre><code class="language-ocaml">let qrexec_init = match_impl Key.(value target) [
  `Qubes, qrexec_qubes;
] ~default:Functoria_app.noop

let gui_init = match_impl Key.(value target) [
  `Qubes, gui_qubes;
] ~default:Functoria_app.noop

let register
    ?(argv=default_argv) ?tracing ?(reporter=default_reporter ())
    ?keys ?packages
    name jobs =
  let argv = Some (Functoria_app.keys argv) in
  let reporter = if reporter == no_reporter then None else Some reporter in
  let qubes_init = Some [qrexec_init; gui_init] in
  let init = qubes_init ++ argv ++ reporter ++ tracing in
  register ?keys ?packages ?init name jobs
</code></pre>
<p><code>qrexec_init</code> and <code>gui_init</code> will only take action if the target is <code>qubes</code>; otherwise, the dummy implementation <code>Functoria_app.noop</code> will be used.  The <code>qrexec_init</code> and <code>gui_init</code> values are added to the <code>init</code> list passed to <code>register</code> regardless of whether they are the Qubes <code>impl</code>s or <code>Functoria_app.noop</code>.</p>
<p>With those additions, <code>mirage configure -t qubes</code> will result in a bootable unikernel!  ...but we're not done yet.</p>
<h2>how do I networks</h2>
<p>MirageOS previously had two methods of IP configuration: automatically at boot via <a href="https://github.com/mirage/charrua-core">DHCP</a>, and statically at code, configure, or boot.  Neither of these are appropriate IPv4 interfaces on Qubes VMs: QubesOS doesn't run a DHCP daemon.  Instead, it expects VMs to consult the Qubes database for their IP information after booting.  Since the IP information isn't known before boot, we can't even supply it at boot time.</p>
<p>Instead, we'll add a new <code>impl</code> for fetching information from QubesDB, and plumb the IP configuration into the <code>generic_stackv4</code> function.  <code>generic_stackv4</code> already makes an educated guess about the best IPv4 configuration retrieval method based in part on the target, so this is a natural fit.</p>
<p>Since we want to use QubesDB as an input to the function that configures the IPv4 stack, we'll have to do a bit more work to make it fit nicely into the functor application architecture -- namely, we have to make a <code>Type</code> for it:</p>
<pre><code class="language-ocaml">type qubesdb = QUBES_DB
let qubesdb = Type QUBES_DB

let qubesdb_conf = object
  inherit base_configurable
  method ty = qubesdb
  method name = &quot;qubesdb&quot;
  method module_name = &quot;Qubes.DB&quot;
  method packages = Key.pure [ package &quot;mirage-qubes&quot; ]
  method configure i =
    match get_target i with
    | `Qubes -&gt; R.ok ()
    | _ -&gt; R.error_msg &quot;Qubes DB invoked for non-Qubes target.&quot;
  method connect _ modname _args = Fmt.strf &quot;%s.connect ~domid:0 ()&quot; modname
end

let default_qubesdb = impl qubesdb_conf
</code></pre>
<p>Other than the <code>type qubesdb = QUBES_DB</code> and <code>let qubesdb = Type QUBES_DB</code>, this isn't very different from the previous <code>gui</code> and <code>qrexec</code> examples.  Next, we'll need something that can take a <code>qubesdb</code>, look up the configuration, and set up an <code>ipv4</code> from the lower layers:</p>
<pre><code>let ipv4_qubes_conf = impl @@ object
    inherit base_configurable
    method ty = qubesdb @-&gt; ethernet @-&gt; arpv4 @-&gt; ipv4
    method name = Name.create &quot;qubes_ipv4&quot; ~prefix:&quot;qubes_ipv4&quot;
    method module_name = &quot;Qubesdb_ipv4.Make&quot;
    method packages = Key.pure [ package ~sublibs:[&quot;ipv4&quot;] &quot;mirage-qubes&quot; ]
    method connect _ modname = function
      | [ db ; etif; arp ] -&gt; Fmt.strf &quot;%s.connect %s %s %s&quot; modname db etif arp
      | _ -&gt; failwith (connect_err &quot;qubes ipv4&quot; 3)
  end

let ipv4_qubes db ethernet arp = ipv4_qubes_conf $ db $ ethernet $ arp
</code></pre>
<p>Notably, the <code>connect</code> function here is a bit more complicated -- we care about the arguments presented to the function (namely the initialized database, an ethernet module, and an arp module), and we'll pass them to the initialization function, which comes from <code>mirage-qubes.ipv4</code>.</p>
<p>To tell <code>mirage configure</code> that when <code>-t qubes</code> is specified, we should use <code>ipv4_qubes_conf</code>, we'll add a bit to <code>generic_stackv4</code>:</p>
<pre><code class="language-ocaml">let generic_stackv4
    ?group ?config
    ?(dhcp_key = Key.value @@ Key.dhcp ?group ())
    ?(net_key = Key.value @@ Key.net ?group ())
    (tap : network impl) : stackv4 impl =
  let eq a b = Key.(pure ((=) a) $ b) in
  let choose qubes socket dhcp =
    if qubes then `Qubes
    else if socket then `Socket
    else if dhcp then `Dhcp
    else `Static
  in
  let p = Functoria_key.((pure choose)
          $ eq `Qubes Key.(value target)
          $ eq `Socket net_key
          $ eq true dhcp_key) in
  match_impl p [
    `Dhcp, dhcp_ipv4_stack ?group tap;
    `Socket, socket_stackv4 ?group [Ipaddr.V4.any];
    `Qubes, qubes_ipv4_stack ?group tap;
  ] ~default:(static_ipv4_stack ?config ?group tap)
</code></pre>
<p>Now, <code>mirage configure -t qubes</code> with any unikernel that usees <code>generic_stackv4</code> will automatically work!</p>
<h1>So What?</h1>
<p>This means I can configure this website for the Qubes target in my development VM:</p>
<pre><code class="language-bash">4.04.0🐫  (qubes-target) mirageos:~/mirage-www/src$ mirage configure -t qubes
</code></pre>
<p>and get some nice invocations of the QRExec and GUI start code, along with the IPv4 configuration from QubesDB:</p>
<pre><code class="language-ocaml">4.04.0🐫  (qubes-target) mirageos:~/mirage-www/src$ cat main.ml
(* Generated by mirage configure -t qubes (Tue, 28 Feb 2017 18:15:49 GMT). *)

open Lwt.Infix
let return = Lwt.return
let run =
OS.Main.run

let _ = Printexc.record_backtrace true

module Ethif1 = Ethif.Make(Netif)

module Arpv41 = Arpv4.Make(Ethif1)(Mclock)(OS.Time)

module Qubesdb_ipv41 = Qubesdb_ipv4.Make(Qubes.DB)(Ethif1)(Arpv41)

module Icmpv41 = Icmpv4.Make(Qubesdb_ipv41)

module Udp1 = Udp.Make(Qubesdb_ipv41)(Stdlibrandom)

module Tcp1 = Tcp.Flow.Make(Qubesdb_ipv41)(OS.Time)(Mclock)(Stdlibrandom)

module Tcpip_stack_direct1 = Tcpip_stack_direct.Make(OS.Time)(Stdlibrandom)
  (Netif)(Ethif1)(Arpv41)(Qubesdb_ipv41)(Icmpv41)(Udp1)(Tcp1)

module Conduit_mirage1 = Conduit_mirage.With_tcp(Tcpip_stack_direct1)

module Dispatch1 = Dispatch.Make(Cohttp_mirage.Server_with_conduit)(Static1)
  (Static2)(Pclock)

module Mirage_logs1 = Mirage_logs.Make(Pclock)

let net11 = lazy (
  Netif.connect (Key_gen.interface ())
  )

let time1 = lazy (
  return ()
  )

let mclock1 = lazy (
  Mclock.connect ()
  )

let ethif1 = lazy (
  let __net11 = Lazy.force net11 in
  __net11 &gt;&gt;= fun _net11 -&gt;
  Ethif1.connect _net11
  )

let qubesdb1 = lazy (
  Qubes.DB.connect ~domid:0 ()
  )

let arpv41 = lazy (
  let __ethif1 = Lazy.force ethif1 in
  let __mclock1 = Lazy.force mclock1 in
  let __time1 = Lazy.force time1 in
  __ethif1 &gt;&gt;= fun _ethif1 -&gt;
  __mclock1 &gt;&gt;= fun _mclock1 -&gt;
  __time1 &gt;&gt;= fun _time1 -&gt;
  Arpv41.connect _ethif1 _mclock1
  )

let qubes_ipv411 = lazy (
  let __qubesdb1 = Lazy.force qubesdb1 in
  let __ethif1 = Lazy.force ethif1 in
  let __arpv41 = Lazy.force arpv41 in
  __qubesdb1 &gt;&gt;= fun _qubesdb1 -&gt;
  __ethif1 &gt;&gt;= fun _ethif1 -&gt;
  __arpv41 &gt;&gt;= fun _arpv41 -&gt;
  Qubesdb_ipv41.connect _qubesdb1 _ethif1 _arpv41
  )

let random1 = lazy (
  Lwt.return (Stdlibrandom.initialize ())
  )

let icmpv41 = lazy (
  let __qubes_ipv411 = Lazy.force qubes_ipv411 in
  __qubes_ipv411 &gt;&gt;= fun _qubes_ipv411 -&gt;
  Icmpv41.connect _qubes_ipv411
  )

let udp1 = lazy (
  let __qubes_ipv411 = Lazy.force qubes_ipv411 in
  let __random1 = Lazy.force random1 in
  __qubes_ipv411 &gt;&gt;= fun _qubes_ipv411 -&gt;
  __random1 &gt;&gt;= fun _random1 -&gt;
  Udp1.connect _qubes_ipv411
  )

let tcp1 = lazy (
  let __qubes_ipv411 = Lazy.force qubes_ipv411 in
  let __time1 = Lazy.force time1 in
  let __mclock1 = Lazy.force mclock1 in
  let __random1 = Lazy.force random1 in
  __qubes_ipv411 &gt;&gt;= fun _qubes_ipv411 -&gt;
  __time1 &gt;&gt;= fun _time1 -&gt;
  __mclock1 &gt;&gt;= fun _mclock1 -&gt;
  __random1 &gt;&gt;= fun _random1 -&gt;
  Tcp1.connect _qubes_ipv411 _mclock1
  )

let stackv4_1 = lazy (
  let __time1 = Lazy.force time1 in
  let __random1 = Lazy.force random1 in
  let __net11 = Lazy.force net11 in
  let __ethif1 = Lazy.force ethif1 in
  let __arpv41 = Lazy.force arpv41 in
  let __qubes_ipv411 = Lazy.force qubes_ipv411 in
  let __icmpv41 = Lazy.force icmpv41 in
  let __udp1 = Lazy.force udp1 in
  let __tcp1 = Lazy.force tcp1 in
  __time1 &gt;&gt;= fun _time1 -&gt;
  __random1 &gt;&gt;= fun _random1 -&gt;
  __net11 &gt;&gt;= fun _net11 -&gt;
  __ethif1 &gt;&gt;= fun _ethif1 -&gt;
  __arpv41 &gt;&gt;= fun _arpv41 -&gt;
  __qubes_ipv411 &gt;&gt;= fun _qubes_ipv411 -&gt;
  __icmpv41 &gt;&gt;= fun _icmpv41 -&gt;
  __udp1 &gt;&gt;= fun _udp1 -&gt;
  __tcp1 &gt;&gt;= fun _tcp1 -&gt;
  let config = {Mirage_stack_lwt. name = &quot;stackv4_&quot;; interface = _net11;} in
Tcpip_stack_direct1.connect config
_ethif1 _arpv41 _qubes_ipv411 _icmpv41 _udp1 _tcp1
  )

let nocrypto1 = lazy (
  Nocrypto_entropy_mirage.initialize ()
  )

let tcp_conduit_connector1 = lazy (
  let __stackv4_1 = Lazy.force stackv4_1 in
  __stackv4_1 &gt;&gt;= fun _stackv4_1 -&gt;
  Lwt.return (Conduit_mirage1.connect _stackv4_1)

  )

let conduit11 = lazy (
  let __nocrypto1 = Lazy.force nocrypto1 in
  let __tcp_conduit_connector1 = Lazy.force tcp_conduit_connector1 in
  __nocrypto1 &gt;&gt;= fun _nocrypto1 -&gt;
  __tcp_conduit_connector1 &gt;&gt;= fun _tcp_conduit_connector1 -&gt;
  Lwt.return Conduit_mirage.empty &gt;&gt;= _tcp_conduit_connector1 &gt;&gt;=
fun t -&gt; Lwt.return t
  )

let argv_qubes1 = lazy (
  let filter (key, _) = List.mem key (List.map snd Key_gen.runtime_keys) in
Bootvar.argv ~filter ()
  )

let http1 = lazy (
  let __conduit11 = Lazy.force conduit11 in
  __conduit11 &gt;&gt;= fun _conduit11 -&gt;
  Cohttp_mirage.Server_with_conduit.connect _conduit11
  )

let static11 = lazy (
  Static1.connect ()
  )

let static21 = lazy (
  Static2.connect ()
  )

let pclock1 = lazy (
  Pclock.connect ()
  )

let key1 = lazy (
  let __argv_qubes1 = Lazy.force argv_qubes1 in
  __argv_qubes1 &gt;&gt;= fun _argv_qubes1 -&gt;
  return (Functoria_runtime.with_argv (List.map fst Key_gen.runtime_keys) &quot;www&quot; _argv_qubes1)
  )

let gui1 = lazy (
  Qubes.GUI.connect ~domid:0 () &gt;&gt;= fun gui -&gt;
  Lwt.async (fun () -&gt; Qubes.GUI.listen gui);
  Lwt.return (`Ok gui)
  )

let qrexec_1 = lazy (
  Qubes.RExec.connect ~domid:0 () &gt;&gt;= fun qrexec -&gt;
  Lwt.async (fun () -&gt;
  OS.Lifecycle.await_shutdown_request () &gt;&gt;= fun _ -&gt;
  Qubes.RExec.disconnect qrexec);
  Lwt.return (`Ok qrexec)
  )

let f11 = lazy (
  let __http1 = Lazy.force http1 in
  let __static11 = Lazy.force static11 in
  let __static21 = Lazy.force static21 in
  let __pclock1 = Lazy.force pclock1 in
  __http1 &gt;&gt;= fun _http1 -&gt;
  __static11 &gt;&gt;= fun _static11 -&gt;
  __static21 &gt;&gt;= fun _static21 -&gt;
  __pclock1 &gt;&gt;= fun _pclock1 -&gt;
  Dispatch1.start _http1 _static11 _static21 _pclock1
  )

let mirage_logs1 = lazy (
  let __pclock1 = Lazy.force pclock1 in
  __pclock1 &gt;&gt;= fun _pclock1 -&gt;
  let ring_size = None in
  let reporter = Mirage_logs1.create ?ring_size _pclock1 in
  Mirage_runtime.set_level ~default:Logs.Info (Key_gen.logs ());
  Mirage_logs1.set_reporter reporter;
  Lwt.return reporter
  )

let mirage1 = lazy (
  let __qrexec_1 = Lazy.force qrexec_1 in
  let __gui1 = Lazy.force gui1 in
  let __key1 = Lazy.force key1 in
  let __mirage_logs1 = Lazy.force mirage_logs1 in
  let __f11 = Lazy.force f11 in
  __qrexec_1 &gt;&gt;= fun _qrexec_1 -&gt;
  __gui1 &gt;&gt;= fun _gui1 -&gt;
  __key1 &gt;&gt;= fun _key1 -&gt;
  __mirage_logs1 &gt;&gt;= fun _mirage_logs1 -&gt;
  __f11 &gt;&gt;= fun _f11 -&gt;
  Lwt.return_unit
  )

let () =
  let t =
  Lazy.force qrexec_1 &gt;&gt;= fun _ -&gt;
    Lazy.force gui1 &gt;&gt;= fun _ -&gt;
    Lazy.force key1 &gt;&gt;= fun _ -&gt;
    Lazy.force mirage_logs1 &gt;&gt;= fun _ -&gt;
    Lazy.force mirage1
  in run t
</code></pre>
<p>and we can build this unikernel, then <a href="https://github.com/talex5/qubes-test-mirage">send it to dom0 to be booted</a>:</p>
<pre><code class="language-bash">4.04.0🐫  (qubes-target) mirageos:~/mirage-www/src$ make depend
4.04.0🐫  (qubes-target) mirageos:~/mirage-www/src$ make
4.04.0🐫  (qubes-target) mirageos:~/mirage-www/src$ ~/test-mirage www.xen mirage-test
</code></pre>
<p>and if we check the guest VM logs for the test VM (which on my machine is named <code>mirage-test</code>, as above), we'll see that it's up and running:</p>
<pre><code class="language-bash">.[32;1mMirageOS booting....[0m
Initialising timer interface
Initialising console ... done.
Note: cannot write Xen 'control' directory
Attempt to open(/dev/urandom)!
Unsupported function getpid called in Mini-OS kernel
Unsupported function getppid called in Mini-OS kernel
2017-02-28 18:29:54 -00:00: INF [net-xen:frontend] connect 0
2017-02-28 18:29:54 -00:00: INF [qubes.db] connecting to server...
gnttab_stubs.c: initialised mini-os gntmap
2017-02-28 18:29:54 -00:00: INF [qubes.db] connected
2017-02-28 18:29:54 -00:00: INF [net-xen:frontend] create: id=0 domid=2
2017-02-28 18:29:54 -00:00: INF [net-xen:frontend]  sg:true gso_tcpv4:true rx_copy:true rx_flip:false smart_poll:false
2017-02-28 18:29:54 -00:00: INF [net-xen:frontend] MAC: 00:16:3e:5e:6c:0e
2017-02-28 18:29:54 -00:00: INF [ethif] Connected Ethernet interface 00:16:3e:5e:6c:0e
2017-02-28 18:29:54 -00:00: INF [arpv4] Connected arpv4 device on 00:16:3e:5e:6c:0e
2017-02-28 18:29:54 -00:00: INF [udp] UDP interface connected on 10.137.3.16
2017-02-28 18:29:54 -00:00: INF [tcpip-stack-direct] stack assembled: mac=00:16:3e:5e:6c:0e,ip=10.137.3.16
2017-02-28 18:29:56 -00:00: INF [dispatch] Listening on http://localhost/
</code></pre>
<p>And if we do a bit of firewall tweaking in <code>sys-firewall</code> to grant access from other VMs:</p>
<pre><code class="language-bash">[user@sys-firewall ~]$ sudo iptables -I FORWARD -d 10.137.3.16 -i vif+ -j ACCEPT
</code></pre>
<p>we can verify that things are as we expect from any VM that has the appropriate software -- for example:</p>
<pre><code class="language-bash">4.04.0🐫  (qubes-target) mirageos:~/mirage-www/src$ wget -q -O - ht.137.3.16|head -1
&lt;!DOCTYPE html&gt;
</code></pre>
<h1>What's Next?</h1>
<p>The implementation work above leaves a lot to be desired, noted in the <a href="https://github.com/mirage/mirage/pull/553#issuecomment-231529011">comments to the original pull request</a>.  We welcome further contributions in this area, particularly from QubesOS users and developers!  If you have questions or comments, please get in touch on the <a href="https://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mirageos-devel mailing list</a> or on our IRC channel at #mirage on irc.freenode.net !</p>
|js};
      };
      {
        updated = {js|2017-02-27 14:00|js};
        authors =
          [
            {
              name = {js|Hannes Mehnert|js};
              uri = Some {js|https://github.com/hannesm|js};
              email = Some {js|hm519@cam.ac.uk|js};
            };
          ];
        subject = {js|Size matters: how Mirage got smaller and less magical|js};
        permalink = {js|mirage-3-smaller|js};
        body =
          {js|<p>In this article, some technical background and empirical evidence is given how
we reduced the lines of code in Mirage3, which has about 25% fewer lines of
code than Mirage2, while providing <a href="https://mirage.io/blog/announcing-mirage-30-release">more features</a>.</p>
<p>Mirage does a fair amount of code generation since its initial release to extend
target-agnostic unikernels to target-specific virtual machine images (or Unix
binaries).
Until Mirage 2.7, string concatenation <a href="https://github.com/mirage/mirage/blob/v2.6.1/lib/mirage.ml">was used
heavily</a>.  Since the
Mirage 2.7.0 release (February 2016), it is based on
<a href="https://mirage.io/blog/introducing-functoria">functoria</a>, &quot;a DSL to describe a
set of modules and functors, their types and how to apply them in order to
produce a complete application&quot;.
The code generated by Mirage3 is less complex than the Mirage2 one and contains up to 45% fewer
lines of code.</p>
<h2>Generating code considered harmful</h2>
<p>Code generated by a program with intricate control flow and automatically
generated identifier names is difficult to understand by a human - in case the
generated code is incorrect and needs to be debugged (or the compiler chokes on
it with an error message pointing in the middle of intricate generated code).
It is also a burden on the developer, since generated code should not be part of
the version control system, thus the build system needs to include another step.
If the code generator is buggy, or not easily extendible for new features,
developers may want to manually modify the generated code - which then turns
into a release nightmare, since you need to maintain a set of patches on top of
generated code, while the code generator may is developed alongside.  Generating
code is best avoided - maybe there is a feature in the programming language to
solve the boilerplate without code generators.</p>
<p>Having said this, there's nothing wrong with LISP macros or MetaOCaml.</p>
<p>Mirage uses code generation to complete backend-agnostic unikernels with the
required boilerplate to compile for a specific backend - by selecting the
network device driver, the console, the network stack, and other devices -
taking user-supplied configuration arguments into account.  In Mirage, the OCaml
TCP/IP stack requires any network device which implements the
<a href="http://docs.mirage.io/mirage-net/Mirage_net/module-type-S/index.html"><code>Mirage_net.S</code></a>
module type.</p>
<p>At the end of the day, some mechanism needs to be in place which links the
<a href="https://github.com/mirage/mirage-net-solo5">mirage-net-solo5</a> library if
compiling for Solo5 (or
<a href="https://github.com/mirage/mirage-net-xen">mirage-net-xen</a> if compiling for xen,
or <a href="https://github.com/mirage-net-unix">mirage-net-unix</a> for Unix, or
<a href="https://github.com/mirage/mirage-net-macosx">mirage-net-macosx</a> for MacOSX).
This can be left to each unikernel developer, which would require having the
same boilerplate code all over, which needs to be updated if a new backend
becomes available (Mirage2 knew about Xen, Unix, and MacOSX, Mirage3 extends
this with Solo5 and Qubes).  Instead, the mirage tool generates this boilerplate
by knowing about all supported devices, and which library a unikernel has to
link for a device depending on the target and command line arguments.
That's not exactly the ideal solution.  But it works good enough for us right
now (<a href="https://github.com/mirage/mirage/pull/750">more or less</a>).  A single place - the mirage tool - needs to be extended whenever a new backend becomes
available.</p>
<h2>Device initialisation - <code>connect</code></h2>
<p>Devices may depend on each other, e.g. a TCP stack requires a monotonic clock and a
random number generator, which influences the initialisation order.  Mirage
generates the device initialisation startup code based on the configuration and
data dependencies (which hopefully form an acyclic graph).  Mirage2 allowed to
handle initialisation errors (the type of <code>connect</code> used to be <code>unit -&gt; [ `Ok of t | `Error of error ] io</code>), but calls to <code>connect</code> were automatically
generated, and the error handler always spit out an error message and exited.
Becaus the <code>error</code> was generic, Mirage2 didn't know how to properly print it,
and instead failed with some incomprehensible error message.  Pretty printing
errors is solved in Mirage3 by our <a href="https://github.com/mirage/mirage/pull/743">re-work of errors</a>, which now use the <code>result</code>
type, are extendible, and can be pretty printed.  Calls to <code>connect</code> are
automatically generated, and handling errors gracefully is out of scope for a
unikernel -- where should it get the other 2 network devices promised at
configuration time from, if they're not present on the (virtual) PCI bus?</p>
<p>The solution we <a href="https://lists.xenproject.org/archives/html/mirageos-devel/2016-09/msg00050.html">discussed</a>
and <a href="https://github.com/mirage/mirage/pull/602">implemented</a> (also in <a href="https://github.com/mirage/functoria/pull/71">functoria</a>) was to always fail hard (i.e. crash) in <code>connect : unit -&gt; t</code>.  This lead to a series of patches for all implementors of <code>connect</code>,
where lots of patches removed control flow complexity (and less complex test
cases, see e.g.
<a href="https://github.com/mirage/mirage-net-unix/pull/27/files">mirage-net-unix</a>, or
<a href="https://github.com/mirage/mirage-tcpip/pull/251/files">tcpip</a>).  Lots of common
boilerplate (like <code>or_error</code>, which throws an exception if <code>connect</code> errored)
could be removed.</p>
<p>Comparing the generated <code>main.ml</code> between Mirage 2.9.1 and 3.0.0 for various
unikernels on both unix and xen code reductions up to 45% (<a href="http://www.cl.cam.ac.uk/~hm519/mirage-2.9.1-3.0.0-diffs/">diffs are
here</a>)</p>
<ul>
<li>console (device-usage) xen: +35 -41 (now 81) unix: +32 -39 (now 80)
</li>
<li>block (device-usage) xen: +36 -45 (now 87) unix: +34 -44 (now 86)
</li>
<li>kv_ro (device-usage) xen: +34 -59 (now 75) unix: +39 -51 (now 86)
</li>
<li>network (device-usage) xen: +82 -134 (now 178) unix: +79 -133 (now 177)
</li>
<li>conduit_server (device-usage) xen: +86 -152 (now 200) unix: +84 -213 (now 199)
</li>
<li>dhcp (applications) xen: +44 -51 (now 93) unix: +41 -49 (now 92)
</li>
<li>dns (applications) xen: +86 -143 (now 190) unix: +83 -141 (now 189)
</li>
<li>static_website_tls (applications) xen: +97 -176 (now 230) unix: +108 -168 (now 237)
</li>
<li>nqsb.io xen: +122 -171 (now 223) unix: +65 -85 (now 133)
</li>
<li>btc-pinata xen: +119 -155 (now 217) unix: +64 -73 (now 127)
</li>
<li>canopy xen: +106 -180 (now 245) unix: +61 -106 (now 159)
</li>
</ul>
<h2>Workflow, phase separation, versioned opam dependencies</h2>
<p>The workflow to build a unikernel used to be <code>mirage configure</code> followed by
<code>make</code>.  During the configure phase, a <code>Makefile</code> was generated with the right
build and link commands (depending on configuration target and other
parameters).  Mirage2 installed opam packages and system packages as a side
effect during configuration.  This lead to several headaches: you needed to have the
target-specific libraries installed while you were configuring (you couldn't
even test the configuration for xen if you didn't have xen headers and support
libraries installed).  Reconfiguration spawned yet another <code>opam</code> process (which
even if it does not install anything since everything required is already
installed, takes some time since the solver has to evaluate the universe) -
unless the <code>--no-opam</code> option was passed to <code>mirage configure</code>.</p>
<p>A second issue with the Mirage2 approach was that dependent packages were listed
in the unikernel <code>config.ml</code>, and passed as string to opam.  When version
constraints were included, this lead either shell (calling out <code>opam</code>) or make
(embedding the packages in the Makefile) or both to choke.  Being able to
express version constraints for dependencies in <code>config.ml</code> was one of the most
wanted features for Mirage3.  It is crucial for further development (to continue
allowing API breakage and removing legacy): a unikernel author, and the mirage
tool, can now embed versioned dependencies onto device interfaces.  Instead of a
garbled error message from mirage trying to compile a unikernel where the
libraries don't fit the generated code, opam will inform which updates are
necessary.</p>
<p>In a <a href="https://github.com/mirage/mirage/pull/691">first rampage</a> (<a href="https://github.com/mirage/functoria/pull/82">functoria</a>) instead of
manual executions of <code>opam</code> processes, an opam package file was generated by
mirage at configuration time for the given target.  This allowed to express
version constraints in each <code>config.ml</code> file (via the <code>package</code> function).  This
change also separated the configuration phase, the dependency installation
phase, and the build phase - which included delayed invocations of <code>pkg-config</code>
to pass parameters to <code>ld</code>.  A mess, especially if your goal is to generate
Makefiles which run both on GNU make and BSD make.</p>
<p>A <a href="https://github.com/mirage/mirage/pull/703">second approach</a> (<a href="https://github.com/mirage/functoria/pull/84">functoria</a>) digged a bit
deeper down the rabbit hole, and removed complex selection and adjustment of
strings to output the Makefile, by implementing this logic in OCaml (and calling
out to <code>ocamlbuild</code> and <code>ld</code>).  Removing an uneeded layer of code generation is
easier to read and understand, less code, and includes stronger guarantees.
More potential errors are caught during compile time, instead of generating
(possible ill-formed) Makefiles.  <a href="http://erratique.ch/software/bos">Bos</a> is a
concise library interacting with basic operating system services, and solves
once and for all common issues in that area, such as properly escaping of
arguments.</p>
<p>Mirage3 contains, instead of a single <code>configure_makefile</code> function which
generated the entire makefile, the build and link logic is separated into
functions, and only a simplistic makefile is generated which invokes <code>mirage build</code> to build the unikernel, and expects all dependent libraries to be
installed (e.g. using <code>make depend</code>, which invokes <code>opam</code>) -- no need for
delaying <code>pkg-config</code> calls anymore.</p>
<p>This solution has certainly less complex string concatenation, and mirage has
now a clearer phase distinction - configure, depend, compile &amp; link.  (This
workflow (still) <a href="https://github.com/mirage/mirage/issues/694">lacks a provisioning
step</a> (e.g. private key material,
if provided as static binary blob, needs to be present during compilation atm),
but can easily be added later.)  There are drawbacks: the mirage utility is now
needed during compilation and linking, and needs to preserve command line
arguments between configuration and build phase.  Maybe the build step should be
in the opam file, then we would need to ensure unique opam package names and we
would need to communicate to the user where the binary got built and installed.</p>
<h2>Other functionality removed or replaced</h2>
<p>The first commit to mirage is from 2004, back then opam was an infant.  Mirage2
ensured that a <a href="https://github.com/mirage/mirage/blob/v2.9.1/lib/mirage.ml#L1462-L1487">not-too-ancient version of
OCaml</a>
is installed (<a href="https://github.com/mirage/functoria/blob/1.1.1/lib/functoria_misc.ml#L298-L309">functoria contained a similar piece of
code</a>).
Mirage3 relies on opam to require a certain OCaml version (at the moment 4.03).</p>
<p>Mirage and functoria were developed while support libraries were not yet
available - worth mentioning <a href="http://erratique.ch/software/bos">bos</a> (mentioned
above), <a href="http://erratique.ch/software/fpath">fpath</a>,
<a href="http://erratique.ch/software/logs">logs</a>, and
<a href="http://erratique.ch/software/astring">astring</a>.  Parts of those libraries were
embedded in functoria, and are now replaced by the libraries. (See
<a href="https://github.com/mirage/mirage/pull/703">mirage#703</a> and
<a href="https://github.com/mirage/functoria/pull/84">functoria#84</a> in case you want to
know the details.)</p>
<p>Functoria support for OCaml <code>&lt;4.02</code> has been
<a href="https://github.com/mirage/functoria/pull/75">dropped</a>, also
<a href="https://github.com/mirage/functoria/pull/77">astring</a> is now in use.
Mirage support for OCaml <code>&lt;4.01</code> has been
<a href="https://github.com/mirage/mirage/blob/v2.9.1/lib/mirage.ml#L1318-L1355">dropped</a>
from Mirage.</p>
<p>Some C bits and pieces, namely <code>str</code>, <code>bignum</code>, and <code>libgcc.a</code>, are no longer linked and part
of every unikernel.  This is documented in
<a href="https://github.com/mirage/mirage/pull/544">mirage#544</a> and
<a href="https://github.com/mirage/mirage/issues/663">mirage#663</a>.</p>
<h2>Conclusion</h2>
<p>The overall statistics of Mirage3 look promising: more libraries, more
contributors, less code, uniform error treatment, unified logging support.  Individual unikernels
contain slightly less boilerplate code (as shown
<a href="http://www.cl.cam.ac.uk/~hm519/mirage-2.9.1-3.0.0-diffs/">by these unified diffs</a>).</p>
<p>The binary sizes of the above mentioned examples (mirage-skeleton, nqsb, Canopy,
pinata) between Mirage2 and Mirage3 results on both Unix and Xen only in small
differences (in the range of kilobytes).  We are working on a <a href="https://github.com/mirage/mirage/issues/685">performance harness</a>
to evaluate the performance of
<a href="https://blogs.janestreet.com/flambda/">flambda</a> intermediate language in OCaml
and <a href="https://github.com/ocaml/ocaml/pull/608">dead code elimination</a>.  These should
decrease the binary size and improve the performance.</p>
|js};
      };
      {
        updated = {js|2017-02-23 17:00|js};
        authors =
          [
            {
              name = {js|Mindy Preston|js};
              uri = Some {js|https://github.com/yomimono|js};
              email = Some {js|mindy.preston@cl.cam.ac.uk|js};
            };
          ];
        subject = {js|Announcing MirageOS 3.0.0|js};
        permalink = {js|announcing-mirage-30-release|js};
        body =
          {js|<p>We're excited to announce MirageOS 3.0! MirageOS is a modern, modular library operating system that allows the creation of small, secure, legacy-free services. MirageOS applications can be compiled to run as self-contained virtual machines (a few MB in size) on Xen or KVM hosts, FreeBSD's bhyve, or even as regular Unix processes (allowing access to regular debugging tools).  The system libraries themselves can be reused in traditional applications, just like any other software library.</p>
<p><a href="https://github.com/mirage/mirage/releases/tag/v3.0.0">Full release notes are available on GitHub</a>.  If you're interested in getting started with MirageOS 3 right away, you might be interested in the <a href="https://mirage.io/wiki/hello-world">revamped guide to getting started</a>, <a href="https://github.com/mirage/mirage-skeleton">a small collection of example unikernels</a>, or the <a href="https://mirage.io/wiki/mirage2-to-mirage3">porting guide for updating Mirage 2.x unikernels to Mirage 3</a>.</p>
<p>Here's a summary of the things in MirageOS 3 that we're most excited about:</p>
<h3>Solo5</h3>
<p>MirageOS 3.0 is the first release that integrates the solo5 targets, <code>virtio</code> and <code>ukvm</code>, fully with the <code>mirage</code> front-end tool.  Now you can <code>mirage configure -t ukvm</code>, build a unikernel, and run directly with the generated <code>ukvm-bin</code>!  We've updated the &quot;hello world&quot; tutorial to reflect our excitement about <code>ukvm</code> -- the <code>ukvm</code> target is considerably easier to interface with and configure than <code>xen</code> was, and for a lot of users this will be a clearer path toward operational deployment of unikernels.</p>
<p>For a lot more information on the Solo5 targets, see <a href="/blog/introducing-solo5">the earlier blog post announcing solo5</a>, <a href="https://www.usenix.org/conference/hotcloud16/workshop-program/presentation/williams">Unikernel Monitors: Extending Minimalism Outside of the Box</a>, and <a href="https://github.com/solo5/solo5/tree/master/README.md">the very readable solo5 repository README</a>.  You can also read how to <a href="https://hannes.nqsb.io/Posts/Solo5">run solo5 unikernels on FreeBSD via bhyve</a>.</p>
<h3>Playing More Nicely with OPAM</h3>
<p>MirageOS 3 has a much richer interface for dealing with the package manager and external library dependencies.  A user can now specify a version or range of versions for a package dependency, and the <code>mirage</code> front-end tool will construct a custom <code>opam</code> file including both those package dependencies and the ones automatically generated from <code>mirage configure</code>.  <code>mirage</code> will also consider version constraints for its own packages -- from now on, <code>opam</code> should notice that releases of <code>mirage</code> are incompatible with your unikernel.</p>
<p>For more information on dealing with packages and dependencies, the documentation for <a href="http://docs.mirage.io/functoria/Functoria/index.html#pkg">the Functoria.package function</a> will likely be of use.  <a href="https://github.com/mirage/mirage-skeleton/blob/mirage-dev/device-usage/prng/config.ml">The PRNG device-usage example in mirage-skeleton</a> demonstrates some useful invocations of <code>package</code>.</p>
<h3>Amazing Docs</h3>
<p>Thanks to a lot of hard work, a fully interlinked set of module documentation is now automatically generated by <code>odig</code> and available for your reading pleasure at <a href="http://docs.mirage.io">the MirageOS central documentation repository</a>.  While documentation was previously available for most modules, it was scattershot and often required having several disconnected pages open simultaneously.  We hope you'll find the new organization more convenient.  The documentation generation system is still in beta, so please report <a href="https://github.com/ocaml-doc/odoc/issues">issues upstream</a> if you run across rendering issues or have other feedback.</p>
<h3>Result-y Errors</h3>
<p>The module types provided by MirageOS 3 replace the previous error paradigm (a combination of exceptions and directly returning polymorphic variants) with one that uses <a href="https://github.com/ocaml/ocaml/pull/147">the Result module included in OCaml 4.03 and up</a>.  A notable exception is when problems occur during the unikernel's initialization (i.e., in <code>connect</code> functions), where unikernels will now fail hard as soon as they can.  The goal of these changes is to surface errors when the application cares about them, and to not present any uninitialized or unstable state to an application at start time.</p>
<p>The MirageOS 3 module types define a core set of likely errors for each module type (see <a href="http://docs.mirage.io/mirage-flow/Mirage_flow/module-type-S/index.html">the mirage-flow module type</a> for an example), which can be extended by any given implementation.  Module types now specify that each implementation must include a pretty-printer that can handle all emitted error types.  Functions that return a <code>success</code> type when they run as expected return a <code>(success, error) Result.t</code>, which the caller can print with <code>pp_error</code> if the value is an <code>Error</code>.</p>
<p>For more background on the result type, see the <a href="http://erratique.ch/software/rresult">Rresult library</a> which defines further useful operations on <code>Result.t</code> and is used widely in MirageOS libraries.  <a href="https://mirage.io/wiki/mirage-3.0-errors">A more in-depth explanation of errors</a> in Mirage 3 is also available.</p>
<h3>Logs Where You Want Them</h3>
<p>MirageOS version 2.9.0 included automatic support for logging via the <code>Logs</code> and <code>Mirage_logs</code> library, but by default logs were always printed to the console and changing the log reporter was cumbersome.  In MirageOS 3, you can send logs to a consumer of syslog messages with <code>syslog_udp</code>, <code>syslog_tcp</code>, or with the full authentication and encryption provided by <code>ocaml-tls</code> using <code>syslog_tls</code>.  For more information, see <a href="https://hannes.nqsb.io/Posts/Syslog">the excellent writeup at hannes.nqsb.io</a>.</p>
<h3>Disaggregated Module Type Definitions</h3>
<p>Breaking all of the MirageOS 3.0 APIs showed us that keeping them all in the same place made updates really difficult.  There's now an additional set of packages which contain the definitions for each set of module types (e.g. <a href="https://github.com/mirage/mirage-fs">mirage-fs</a> for the <code>FS</code> module type, <a href="https://github.com/mirage/mirage-block">mirage-block</a> for the <code>BLOCK</code> module type, etc).  A few module types had some additional useful code that was nicely functorized over the module type in question, so we've bundled that code in the module type packages as well.  Documentation for all of the module type packages is available at <a href="http://docs.mirage.io">the Mirage documentation hub</a>.</p>
<p>We hope that this change combined with the <code>opam</code> workflow changes above will result in <em>much</em> less painful API changes in the future, as it will be possible for unikernel authors to target specific versions more readily.</p>
<h3>Clockier Clocks, Timelier Time</h3>
<p>In older MirageOS versions, we noticed that we were often having to deduce a span of time from having taken two wall-clock samples of the current time.  In MirageOS 3, you have your choice of two types of clock - <code>MCLOCK</code>, which provides a monotonically increasing clock reflecting the time elapsed since the clock started, and <code>PCLOCK</code>, which provides a traditional POSIX wall-clock time.  Most previous users of <code>CLOCK</code> were able to migrate to the more-honest, less-complicated <code>MCLOCK</code>.  For an example of both clocks, see <a href="https://github.com/mirage/mirage-skeleton/blob/mirage-dev/device-usage/clock/unikernel.ml">the speaking clock</a>.  You may also be interested in <a href="https://github.com/mirage/mirage-tcpip/pull/232/files">an example of converting existing code from <code>CLOCK</code> to <code>MCLOCK</code></a>.</p>
<p><code>MCLOCK</code> provides a nice interface for dealing with time at a nanosecond granularity.  The <code>TIME</code> module type has been updated to expect an <code>int64</code> number of nanoseconds, rather than a float, as an argument to its function <code>sleep</code>.  For those of us who don't think in nanoseconds, the <a href="https://github.com/hannesm/duration">Duration</a> library provides convenient functions for translating from and to more familiar units like seconds.</p>
<h3>Build System Shift</h3>
<p>Mirage 3.0 has many, many more packages than before, and so we turned to <a href="http://ocamllabs.io">OCaml Labs</a> to help us to <a href="http://ocamllabs.io/projects/2017/02/23/topkg.html">scale up our package management</a>. In many but not all MirageOS packages, we've replaced <code>oasis</code> with <code>topkg</code>, the &quot;transitory OCaml software packager&quot;. <code>topkg</code> is a lighter layer over the underlying <code>ocamlbuild</code>.  Using <code>topkg</code> has allowed us to remove several thousand lines of autogenerated code across the MirageOS package universe, and let our release manager automate a significant amount of the MirageOS 3 release process.  We hope to continue benefitting from the ease of using <code>topkg</code> and <code>topkg-care</code>.</p>
<p>Not all packages are using <code>topkg</code> yet -- if you see one that isn't, feel free to submit a pull request!</p>
<h3>Less Code, Better Behavior</h3>
<p>There's more in MirageOS 3 than we can fit in one blog post without our eyes glazing over.  The release notes for <code>mirage</code> version 3.0.0 are a nice summary, but you might also be interested in the full accounting of changes for every package released as a part of the MirageOS 3 effort; links for each library are available at the end of this post.</p>
<p>Across the package universe, a net several thousand lines of code were <em>removed</em> as part of MirageOS 3.  Many were autogenerated build-time support files removed in the transition from <code>oasis</code> to <code>topkg</code>.  Others were small support modules like <code>Result</code>, which had previously been replicated in many places and were replaced by a reference to a common implementation.  Some large implementations (like the DHCP client code in <code>mirage-tcpip</code>) were replaced by smaller, better implementations in common libraries (like <code>charrua-core</code>).</p>
<p>For example, <a href="https://github.com/mirage/ocaml-fat/compare/0.11.0...0.12.0">ocaml-fat</a> had 1,280 additions and 10,265 deletions for a net of -8,985 lines of code; version 0.12.0 jettisoned a custom in-memory block device in favor of using the in-memory block device provided by <code>Mirage_block_lwt.Mem</code>, removed several thousand lines of autogenerated OASIS code, removed several custom error-case polymorphic variants, and lost a custom <code>result</code> module.  The <a href="https://github.com/mirage/mirage/compare/v2.9.1...v3.0.0">mirage repository itself</a> netted -8,490 lines of code while adding all of the features above!</p>
<p>A number of improvements were made to <code>mirage</code> to limit the number of unnecessary build artifacts and reduce the amount of unnecessary code linked into unikernels.  Modules you're unlikely to use like <code>Str</code> are no longer included in the OCaml runtime.  MirageOS 3 is also the first to drop support for OCaml 4.02.3, meaning that all supported compilers support the <code>flambda</code> compiler extension and a number of related optimization opportunities.</p>
<p>Very many people were involved in making the MirageOS package universe smaller and better than it was before.  We'd like to thank, in a particular alphabetical order, the following people who contributed code, suggestions, bug reports, comments, mailing lists questions and answers, and other miscellaneous help:</p>
<ul>
<li>Aaron Cornelius
</li>
<li>Amir Chaudhry
</li>
<li>Andrew Stuart
</li>
<li>Anil Madhavapeddy
</li>
<li>Ashish Agarwal
</li>
<li>Balraj Singh
</li>
<li>Cedric Cellier
</li>
<li>Christiano Haesbaert
</li>
<li>Daniel Bünzli
</li>
<li>Dan Williams
</li>
<li>Dave Scott
</li>
<li>David Kaloper
</li>
<li>David Sheets
</li>
<li>Enguerrand Decorne
</li>
<li>Eugene Bagdasaryan
</li>
<li>Federico Gimenez
</li>
<li>Gabriel de Perthuis
</li>
<li>Gabriel Jaldon
</li>
<li>Gabriel Radanne
</li>
<li>Gemma Gordon
</li>
<li>Hannes Mehnert
</li>
<li>Ian Campbell
</li>
<li>Jochen Bartl
</li>
<li>John P. McDermott
</li>
<li>Jon Ludlam
</li>
<li>Kia
</li>
<li>Leo White
</li>
<li>Leonid Rozenberg
</li>
<li>Liang Wang
</li>
<li>Madhuri Yechuri
</li>
<li>Magnus Skjegstad
</li>
<li>Martin Lucina
</li>
<li>Matt Gray
</li>
<li>Mindy Preston
</li>
<li>Nick Betteridge
</li>
<li>Nicolas Ojeda Bar
</li>
<li>Nik Sultana
</li>
<li>Pablo Polvorin
</li>
<li>Petter A. Urkedal
</li>
<li>Qi LI
</li>
<li>Ramana Venkata
</li>
<li>Ricardo Koller
</li>
<li>Richard Mortier
</li>
<li>Rudi Grinberg
</li>
<li>Sean Grove
</li>
<li>Takayuki Imada
</li>
<li>Thomas Gazagnaire
</li>
<li>Thomas Leonard
</li>
<li>Vincent Bernardoff
</li>
<li>Vittorio Cozzolino
</li>
<li>GitHub user waldyrious
</li>
<li>Wassim Haddad
</li>
<li>Jeremy Yallop
</li>
</ul>
<p>Please let us know if you notice someone (including yourself) is missing so we can add them and apologize!  We're happy to remove or change your listed name if you'd prefer as well.  Names were taken from metadata on commit messages and e-mail headers.</p>
<ul>
<li>For a summary of changes in each repository that released code for MirageOS 3, please see the following list:
</li>
<li><a href="https://github.com/mirage/mirage-clock/compare/v1.1...1.2.0">changes in mirage-clock between v1.1 and 1.2.0</a>:  51 files changed, 788 insertions(+), 381 deletions(-)
</li>
<li><a href="http://github.com/mirage/ocaml-vchan/compare/v2.2.0...v2.3.0">changes in ocaml-vchan between v2.2.0 and v2.3.0</a>:  14 files changed, 4384 insertions(+), 3553 deletions(-)
</li>
<li><a href="https://github.com/haesbaert/charrua-core/compare/v0.3...v0.4">changes in charrua-core between v0.3 and v0.4</a>:  14 files changed, 760 insertions(+), 231 deletions(-)
</li>
<li><a href="https://github.com/hannesm/arp/compare/0.1.1...0.2.0">changes in arp between 0.1.1 and 0.2.0</a>:  23 files changed, 302 insertions(+), 430 deletions(-)
</li>
<li><a href="https://github.com/hannesm/logs-syslog/compare/0.0.2...0.1.0">changes in logs-syslog between 0.0.2 and 0.1.0</a>:  25 files changed, 277 insertions(+), 361 deletions(-)
</li>
<li><a href="https://github.com/MagnusS/mirage-vnetif/compare/0.2.0...v0.3">changes in mirage-vnetif between 0.2.0 and v0.3</a>:  35 files changed, 669 insertions(+), 8551 deletions(-)
</li>
<li><a href="https://github.com/mirage/functoria/compare/1.1.0...2.0.1">changes in functoria between 1.1.0 and 2.0.1</a>:  46 files changed, 1107 insertions(+), 9666 deletions(-)
</li>
<li><a href="https://github.com/mirage/mirage-block/compare/v0.2...1.0.0">changes in mirage-block between v0.2 and 1.0.0</a>:  42 files changed, 1194 insertions(+), 925 deletions(-)
</li>
<li><a href="https://github.com/mirage/mirage-block-ramdisk/compare/v0.2...v0.3">changes in mirage-block-ramdisk between v0.2 and v0.3</a>:  18 files changed, 440 insertions(+), 305 deletions(-)
</li>
<li><a href="https://github.com/mirage/mirage-block-solo5/compare/v0.1.1...v0.2.1">changes in mirage-block-solo5 between v0.1.1 and v0.2.1</a>:  23 files changed, 187 insertions(+), 7854 deletions(-)
</li>
<li><a href="https://github.com/mirage/mirage-block-unix/compare/v2.5.0...v2.6.0">changes in mirage-block-unix between v2.5.0 and v2.6.0</a>:  9 files changed, 76 insertions(+), 40 deletions(-)
</li>
<li><a href="https://github.com/mirage/mirage-block-xen/compare/v1.4.0...v1.5.0">changes in mirage-block-xen between v1.4.0 and v1.5.0</a>:  11 files changed, 4261 insertions(+), 3440 deletions(-)
</li>
<li><a href="https://github.com/mirage/mirage-bootvar-solo5/compare/v0.1.1...v0.2.0">changes in mirage-bootvar-solo5 between v0.1.1 and v0.2.0</a>:  24 files changed, 78 insertions(+), 7842 deletions(-)
</li>
<li><a href="https://github.com/mirage/mirage-bootvar-xen/compare/v0.3.2...0.4.0">changes in mirage-bootvar-xen between v0.3.2 and 0.4.0</a>:  24 files changed, 98 insertions(+), 8068 deletions(-)
</li>
<li><a href="https://github.com/mirage/mirage-channel/compare/v1.1.1...v3.0.0">changes in mirage-channel between v1.1.1 and v3.0.0</a>:  22 files changed, 511 insertions(+), 485 deletions(-)
</li>
<li><a href="https://github.com/mirage/mirage-console/compare/v2.1.3...2.2.0">changes in mirage-console between v2.1.3 and 2.2.0</a>:  63 files changed, 1364 insertions(+), 9188 deletions(-)
</li>
<li><a href="https://github.com/mirage/mirage-console-solo5/compare/v0.1.1...v0.2.0">changes in mirage-console-solo5 between v0.1.1 and v0.2.0</a>:  26 files changed, 164 insertions(+), 7814 deletions(-)
</li>
<li>mirage-device is new in MirageOS 3:  13 files changed, 169 insertions(+)
</li>
<li><a href="https://github.com/mirage/mirage-entropy/compare/0.3.0...0.4.0">changes in mirage-entropy between 0.3.0 and 0.4.0</a>:  34 files changed, 533 insertions(+), 8181 deletions(-)
</li>
<li><a href="https://github.com/mirage/mirage-flow/compare/v1.1.0...1.2.0">changes in mirage-flow between v1.1.0 and 1.2.0</a>:  48 files changed, 1254 insertions(+), 8865 deletions(-)
</li>
<li><a href="https://github.com/mirage/mirage-fs/compare/v0.6.0...1.0.0">changes in mirage-fs between v0.6.0 and 1.0.0</a>:  27 files changed, 476 insertions(+), 244 deletions(-)
</li>
<li><a href="https://github.com/mirage/mirage-fs-unix/compare/v1.2.1...1.3.0">changes in mirage-fs-unix between v1.2.1 and 1.3.0</a>:  41 files changed, 1075 insertions(+), 9477 deletions(-)
</li>
<li><a href="https://github.com/mirage/mirage/compare/v2.9.1...v3.0.0">changes in mirage between v2.9.1 and v3.0.0</a>:  77 files changed, 2332 insertions(+), 11037 deletions(-)
</li>
<li><a href="https://github.com/mirage/mirage-http/compare/2.5.3...3.0.0">changes in mirage-http between 2.5.3 and 3.0.0</a>:  14 files changed, 75 insertions(+), 49 deletions(-)
</li>
<li>mirage-kv is new in MirageOS 3:  18 files changed, 282 insertions(+)
</li>
<li><a href="https://github.com/mirage/mirage-logs/compare/v0.2...0.3.0">changes in mirage-logs between v0.2 and 0.3.0</a>:  30 files changed, 563 insertions(+), 8250 deletions(-)
</li>
<li>mirage-net is new in MirageOS 3:  18 files changed, 345 insertions(+)
</li>
<li><a href="https://github.com/mirage/mirage-net-macosx/compare/1.2.0...1.3.0">changes in mirage-net-macosx between 1.2.0 and 1.3.0</a>:  15 files changed, 184 insertions(+), 181 deletions(-)
</li>
<li><a href="https://github.com/mirage/mirage-net-solo5/compare/v0.1.1...v0.2.0">changes in mirage-net-solo5 between v0.1.1 and v0.2.0</a>:  27 files changed, 266 insertions(+), 7969 deletions(-)
</li>
<li><a href="https://github.com/mirage/mirage-net-unix/compare/v2.2.3...2.3.0">changes in mirage-net-unix between v2.2.3 and 2.3.0</a>:  26 files changed, 365 insertions(+), 8133 deletions(-)
</li>
<li><a href="https://github.com/mirage/mirage-net-xen/compare/v1.4.2...v1.7.0">changes in mirage-net-xen between v1.4.2 and v1.7.0</a>:  47 files changed, 6279 insertions(+), 4059 deletions(-)
</li>
<li><a href="https://github.com/mirage/mirage-platform/compare/v2.6.0...v3.0.0">changes in mirage-platform between v2.6.0 and v3.0.0</a>:  36 files changed, 7897 insertions(+), 7449 deletions(-)
</li>
<li>mirage-protocols is new in MirageOS 3:  18 files changed, 780 insertions(+)
</li>
<li>mirage-random is new in MirageOS 3:  16 files changed, 172 insertions(+)
</li>
<li><a href="https://github.com/mirage/mirage-solo5/compare/v0.1.1...v0.2.0">changes in mirage-solo5 between v0.1.1 and v0.2.0</a>:  69 files changed, 1411 insertions(+), 9130 deletions(-)
</li>
<li>mirage-stack is new in MirageOS 3:  16 files changed, 254 insertions(+)
</li>
<li><a href="https://github.com/mirage/mirage-tcpip/compare/v2.8.1...v3.0.0">changes in mirage-tcpip between v2.8.1 and v3.0.0</a>:  228 files changed, 15376 insertions(+), 13301 deletions(-)
</li>
<li>mirage-time is new in MirageOS 3:  15 files changed, 198 insertions(+)
</li>
<li><a href="https://github.com/mirage/ocaml-conduit/compare/v0.15.0...v0.14.5">changes in ocaml-conduit between v0.15.0 and v0.14.5</a>:  14 files changed, 59 insertions(+), 76 deletions(-)
</li>
<li><a href="https://github.com/mirage/ocaml-crunch/compare/v1.4.1...2.0.0">changes in ocaml-crunch between v1.4.1 and 2.0.0</a>:  34 files changed, 576 insertions(+), 8196 deletions(-)
</li>
<li><a href="https://github.com/mirage/ocaml-dns/compare/v0.18.1...v0.19.0">changes in ocaml-dns between v0.18.1 and v0.19.0</a>:  24 files changed, 5526 insertions(+), 3824 deletions(-)
</li>
<li><a href="https://github.com/mirage/ocaml-fat/compare/0.11.0...0.12.0">changes in ocaml-fat between 0.11.0 and 0.12.0</a>:  80 files changed, 3239 insertions(+), 12224 deletions(-)
</li>
<li><a href="https://github.com/mirage/ocaml-freestanding/compare/v0.2.0...v0.2.1">changes in ocaml-freestanding between v0.2.0 and v0.2.1</a>:  3 files changed, 7 insertions(+), 1 deletion(-)
</li>
<li><a href="https://github.com/mirage/ocaml-qcow/compare/v0.8.0...v0.8.1">changes in ocaml-qcow between v0.8.0 and v0.8.1</a>:  2 files changed, 5 insertions(+), 2 deletions(-)
</li>
<li><a href="https://github.com/mirleft/ocaml-nocrypto/compare/v0.5.3...v0.5.4">changes in ocaml-nocrypto between v0.5.3 and v0.5.4</a>:  44 files changed, 513 insertions(+), 576 deletions(-)
</li>
<li><a href="https://github.com/mirleft/ocaml-tls/compare/0.7.1...0.8.0">changes in ocaml-tls between 0.7.1 and 0.8.0</a>:  43 files changed, 415 insertions(+), 695 deletions(-)
</li>
<li><a href="https://github.com/pqwy/mirage-os-shim/compare/v0.0.1...v3.0.0">changes in mirage-os-shim between v0.0.1 and v3.0.0</a>:  11 files changed, 62 insertions(+), 143 deletions(-)
</li>
<li><a href="https://github.com/pqwy/ocb-stubblr/compare/v0.1.0...v0.1.1">changes in ocb-stubblr between v0.1.0 and v0.1.1</a>:  3 files changed, 21 insertions(+), 11 deletions(-)
</li>
<li><a href="https://github.com/solo5/solo5/compare/v0.1.1...v0.2.0">changes in solo5 between v0.1.1 and v0.2.0</a>:  102 files changed, 5554 insertions(+), 9421 deletions(-)
</li>
<li><a href="https://github.com/talex5/mirage-qubes/compare/v0.3...0.4">changes in mirage-qubes between v0.3 and 0.4</a>:  28 files changed, 318 insertions(+), 1074 deletions(-)
</li>
<li><a href="https://github.com/yomimono/charrua-client/compare/0.0.1...0.1.0">changes in charrua-client between 0.0.1 and 0.1.0</a>:  24 files changed, 492 insertions(+), 442 deletions(-)
</li>
</ul>
|js};
      };
      {
        updated = {js|2016-7-18 16:00|js};
        authors =
          [
            {
              name = {js|Gemma Gordon|js};
              uri = Some {js|https://github.com/GemmaG|js};
              email = Some {js|gg417@cl.cam.ac.uk|js};
            };
            {
              name = {js|Anil Madhavapeddy|js};
              uri = Some {js|http://anil.recoil.org|js};
              email = Some {js|anil@recoil.org|js};
            };
          ];
        subject = {js|MirageOS Summer 2016 hack retreat roundup|js};
        permalink = {js|2016-summer-hackathon-roundup|js};
        body =
          {js|<p><a href="https://www.flickr.com/photos/138528518@N02/sets/72157671241464475"><img src="/graphics/cambridge2016-hackathon.jpg" align="right" width="250px" /></a>
Our first Cambridge-based MirageOS hack retreat took place yesterday - and what a fantastic day it was! The torrential rain may have halted our punting plans, but it didn't stop progress in the Old Library! Darwin College was a fantastic venue, complete with private islands linked by picturesque wooden bridges and an unwavering wifi connection.</p>
<p>People naturally formed groups to work on similar projects, and we had a handful of brand new users keen to get started with OCaml and Mirage.  The major tasks that emerged were:</p>
<ul>
<li><strong>new hypervisor target</strong>: the integration of the Solo5 KVM-based hypervisor backend, bringing the number of officially supported targets up to 3 (Xen, Unix and KVM)
</li>
<li><strong>build system template</strong>: establishing a new <a href="https://erratique.ch/software/topkg">topkg</a>  template for MirageOS libraries, to prepare us for building a unified API documentation bundle that works across all the entire project.
</li>
<li><strong>CPU portability</strong>: improving ARM support via a better base OS image.
</li>
<li><strong>libraries breadth</strong>: hacking on all the things to fill in the blanks, such as btree support for bare-metal <a href="https://github.com/mirage/irmin">Irmin</a>, or a peer-to-peer layer for the <a href="https://github.com/docker/datakit">DataKit</a>.
</li>
</ul>
<p>We'll write about all of this in more detail, but for now here are the hack retreat notes hot off the press...</p>
<h3>Solo5/MirageOS integration (KVM-based backend)</h3>
<p>Progress on the Solo5 project has been steaming ahead <a href="https://mirage.io/blog/introducing-solo5">since January</a>, and this was the perfect opportunity to get everyone together to plan its integration with MirageOS. <a href="http://researcher.ibm.com/researcher/view.php?person=us-djwillia">Dan Williams</a> from IBM Research flew over to join us for the week, and <a href="https://github.com/mato">Martin Lucina</a> headed to Cambridge to prepare for the upstreaming of the recent Solo5 work. This included deciding on naming and ownership of the repositories, detailing the relationships between repositories and getting ready to publish the mirage-solo5 packages to OPAM. <a href="http://somerandomidiot.com">Mindy Preston</a>, our MirageOS 3.0 release manager, and <a href="http://anil.recoil.org">Anil Madhavapeddy</a> and <a href="http://gazagnaire.org">Thomas Gazagnaire</a> (OPAM minions) were on hand to help plan this smoothly.</p>
<p>See their updates from the day on <a href="http://canopy.mirage.io/Posts/Solo5">Canopy</a> and related blog posts:</p>
<ul>
<li><a href="https://mirage.io/blog/introducing-solo5">Introducing Solo 5</a>
</li>
<li>Unikernel Monitors HotCloud 2016 <a href="https://www.usenix.org/system/files/conference/hotcloud16/hotcloud16_williams.pdf">paper</a> and <a href="https://www.usenix.org/sites/default/files/conference/protected-files/hotcloud16_slides_williams.pdf">slides</a>
</li>
<li><a href="https://github.com/Solo5/solo5/issues/36">upstreaming GitHub issue</a> and <a href="https://github.com/Solo5/solo5/issues/61">FreeBSD support tracking issue</a> from Hannes Mehnert.
</li>
</ul>
<h3>Onboarding new MirageOS/OCaml users</h3>
<p>Our tutorials and onboarding guides <em>really</em> needed a facelift and an update, so <a href="https://ocaml.io/w/User:GemmaG">Gemma Gordon</a> spent the morning with some of our new users to observe their installation process and tried to pinpoint blockers and areas of misunderstanding. Providing the simple, concise instructions needed in a guide together with alternatives for every possible system and version requirement is a tricky combination to get right, but we made some <a href="https://github.com/mirage/mirage-www/pull/468">changes</a> to the <a href="https://mirage.io/wiki/install">installation guide</a> that we hope will help. The next task is to do the same for our other popular tutorials, reconfigure the layout for easy reading and centralise the information as much as possible between the OPAM, MirageOS and OCaml guides. Thank you to Marwan Aljubeh for his insight into this process.</p>
<p>Other industrial users are also steaming ahead with their own MirageOS deployments. <a href="http://amirchaudhry.com">Amir Chaudhry</a> spent the hackathon blogging about <a href="http://unikernel.org/blog/2016/unikernel-nfv-platform">NFV Platforms with MirageOS unikernels</a>, which details how Ericsson Silicon Valley has been using MirageOS to build lightweight routing kernels.</p>
<h3>Packaging</h3>
<p>Thomas Gazagnaire was frenetically converting <code>functoria</code>, <code>mirage</code>, <code>mirage-types</code> and <code>mirage-console</code> to use <a href="https://github.com/dbuenzli/topkg">topkg</a>, and the feedback prompted fixes and a new release from Daniel Buenzli.</p>
<ul>
<li><a href="https://github.com/mirage/functoria/pull/64">Functoria #64</a>
</li>
<li><a href="https://github.com/mirage/mirage/pull/558">Mirage #558</a>
</li>
<li><a href="https://github.com/mirage/mirage-console/pull/41">Mirage-console #41</a>
</li>
</ul>
<h3>ARM and Cubieboards</h3>
<p>Ian Campbell implemented a (slightly hacky) way to get Alpine Linux onto some Cubieboard2 boxes and <a href="https://gist.github.com/ijc25/612b8b7975e9461c3584b1402df2cb34">provided notes</a> on his process, including how to tailor the base for KVM and Xen respectively.</p>
<p>Meanwhile, Qi Li worked on testing and adapting <a href="https://github.com/yomimono/simple-nat">simple-nat</a> and <a href="https://github.com/yomimono/mirage-nat">mirage-nat</a> to provide connectivity control for unikernels on ARM Cubieboards to act as network gateways.</p>
<ul>
<li><a href="https://github.com/yomimono/simple-nat/tree/ethernet-level-no-irmin">Simple-NAT ethernet branch</a>
</li>
<li><a href="https://github.com/yomimono/mirage-nat/tree/depopt_irmin">Mirage NAT with optional Irmin branch</a>
</li>
</ul>
<p><a href="https://www.cl.cam.ac.uk/~hm519/">Hannes Mehnert</a> recently published a purely functional <a href="https://github.com/hannesm/arp">ARP package</a> and continued refining it (with code coverage via <a href="https://github.com/aantron/bisect_ppx">bisect-ppx</a>) during the hackathon.</p>
<h3>MirageOS 3.0 API changes</h3>
<p>Our MirageOS release manager, Mindy Preston, was on hand to talk with everyone about their PRs in preparation for the 3.0 release along with some patches for deprecating out of date code.  There has been a lot of discussion on the <a href="https://lists.xenproject.org/archives/html/mirageos-devel/2016-07/msg00000.html">development list</a>.  One focus was to address time handling properly in the interfaces: Matthew Gray came up from London to finish up his extensive revision of the <a href="https://github.com/mirage/mirage/issues/442">CLOCK</a> interface, and Hannes developed a new <a href="https://github.com/hannesm/duration">duration</a> library to handle time unit conversions safely and get rid of the need for floating point handling.  We are aiming to minimise the dependency on floating point handling in external interfaces to simplify compilation to very embedded hardware that only has soft floats (particularly for something as ubiquitous as time handling).</p>
<h3>Error logging</h3>
<p>Thomas Leonard continued with the work he started in Marrakech by <a href="https://github.com/mirage/functoria/pull/55">updating the error reporting patches</a> (also <a href="https://github.com/mirage/mirage-dev/pull/107">here</a>) to work with the latest version of MirageOS (which has a different logging system based on Daniel Buenzlis <a href="http://erratique.ch/software/logs">Logs</a>). See the <a href="http://canopy.mirage.io/Posts/Errors">original post</a> for more details.</p>
<h3>Ctypes 0.7.0 release</h3>
<p>Jeremy released the foreign function interface library <a href="https://github.com/ocamllabs/ocaml-ctypes/releases/tag/0.7.0">Ctypes 0.7.0</a> which, along with bug fixes, adds the following features:</p>
<ul>
<li>Support for bytecode-only architectures (<a href="https://github.com/ocamllabs/ocaml-ctypes/issues/410">#410</a>)
</li>
<li>A new <code>sint</code> type corresponding to a full-range C integer and updated errno support for its use (<a href="https://github.com/ocamllabs/ocaml-ctypes/issues/411">#411</a>)
</li>
</ul>
<p>See the full changelog <a href="https://github.com/ocamllabs/ocaml-ctypes/blob/master/CHANGES.md">online</a>.</p>
<h3>P2P key-value store over DataKit</h3>
<p>KC Sivaramakrishnan and Philip Dexter took on the challenge of grabbing the Docker <a href="https://github.com/docker/datakit">DataKit</a> release and started building a distributed key-value store that features flexible JSON synching and merging.  Their raw notes are in a <a href="https://gist.github.com/kayceesrk/d3edb2da0aa9a3d40e9e3f838b67bd1a">Gist</a> -- get in touch with them if you want to help hack on the sync system backed by Git.</p>
<h3>Developer experience improvements</h3>
<p>The OCaml Labs undergraduate interns are spending their summers working on user improvements and CI logs with MirageOS, and used the time at the hackathon to focus on these issues.</p>
<p>Ciaran Lawlor is working on an editor implementation, specifically getting the <a href="https://github.com/andrewray/iocaml">IOcaml kernel</a> working with the <a href="https://github.com/nteract/hydrogen">Hydrogen</a> plugin for the Atom editor. This will allow developers to run OCaml code directly in Atom, and eventually interactively build unikernels!</p>
<p>Joel Jakubovic used <a href="https://github.com/inhabitedtype/angstrom">Angstrom</a> (a fast parser combinator library developed by Spiros Eliopoulos) to ANSI escape codes, usually displayed as colours and styles into HTML for use in viewing CI logs.</p>
<h3>Windows Support</h3>
<p>Most of the Mirage libraries already work on Windows thanks to lots of work in the wider OCaml community, but other features don't have full support yet.</p>
<p><a href="http://dave.recoil.org">Dave Scott</a> from Docker worked on <a href="https://github.com/djs55/ocaml-wpcap">ocaml-wpcap</a>: a <a href="https://github.com/ocamllabs/ocaml-ctypes">ctypes</a> binding to the Windows <a href="http://www.winpcap.org">winpcap.dll</a> which lets OCaml programs send and receive ethernet frames on Windows. The ocaml-wpcap library will hopefully let us run the Mirage TCP/IP stack and all the networking applications too.</p>
<p>David Allsopp continued his OPAM-Windows support by fine-tuning the 80 native Windows OCaml versions - these will hopefully form part of OPAM 2.0. As it turns out, he's not the only person still interested in being able to run OCaml 3.07...if you are, get in touch!</p>
<h3>General Libraries and utilities</h3>
<p><a href="https://github.com/OlivierNicole">Olivier Nicole</a> is working on an implementation of macros in OCaml and started working on the
HTML and XML templates using this system. The objective is to have the same
behaviour as the <code>Pa_tyxml</code> syntax extension, but in a type-safe and more
maintainable way without requiring PPX extensions. This project could be
contributed to the development of <a href="http://ocsigen.org">Ocsigen</a> once implemented.</p>
<p>Nick Betteridge teamed up with Dave Scott to look at using
<a href="https://github.com/djs55/ocaml-btree">ocaml-btree</a> as a backend for Irmin/xen
and spent the day looking at different approaches.</p>
<p>Anil Madhavapeddy built a Docker wrapper for the CI system and spun up a big cluster
to run OPAM bulk builds.  Several small utilities like <a href="https://github.com/avsm/jsontee">jsontee</a> and
an immutable <a href="https://github.com/avsm/opam-log-server">log collection server</a> and
<a href="https://github.com/avsm/opam-bulk-builder">bulk build scripts</a> will be released in the
next few weeks once the builds are running stably, and be re-usable by other OPAM-based
projects to use for their own tests.</p>
<p><a href="https://github.com/Chris00">Christophe Troestler</a> is spending a month at
<a href="https://ocaml.io">OCaml Labs</a> in Cambridge this summer, and spent the hack day
working on implementing a library to allow seamless application switching from
HTTP to FastCGI. Christophe has initiated work on a client and server for this
protocol using <a href="https://github.com/mirage/ocaml-cohttp">CoHTTP</a> so that it is
unikernel-friendly.</p>
|js};
      };
      {
        updated = {js|2016-6-29 16:00|js};
        authors =
          [
            {
              name = {js|Gemma Gordon|js};
              uri = Some {js|https://github.com/GemmaG|js};
              email = Some {js|gg417@cl.cam.ac.uk|js};
            };
            {
              name = {js|Anil Madhavapeddy|js};
              uri = Some {js|http://anil.recoil.org|js};
              email = Some {js|anil@recoil.org|js};
            };
          ];
        subject =
          {js|MirageOS Summer 2016 hack retreat announcement, and talk roundup|js};
        permalink = {js|2016-summer-hackathon|js};
        body =
          {js|<p>As summer starts to shine over an obstinately rainy England, we are organising
the second MirageOS hack retreat in Cambridge!  It will be held on <strong>Weds 13th
July</strong> at the lovely <a href="https://www.darwin.cam.ac.uk">Darwin College</a> from
9am-11pm, with snacks, teas, coffees and a servery lunch provided (thanks to
sponsorship from <a href="http://docker.com">Docker</a> and <a href="https://ocaml.io">OCaml Labs</a>).</p>
<p><strong>Anyone is welcome at all skill levels</strong>, but we'd appreciate you filling out the
<a href="http://doodle.com/poll/ngbbviwyb9e65uiw">Doodle</a> so that we can plan
refreshments.  We will be working on a variety of projects from improving ARM
support, to continuous integration tests, the new Solo5 backend and improving
the suite of protocol libraries.  If you have something in particular that
interests you, please drop a note to the <a href="/community">mailing list</a> or check
out the full list of <a href="https://github.com/mirage/mirage-www/wiki/Pioneer-Projects">Pioneer Projects</a>.</p>
<p>Some other events of note recently:</p>
<ul>
<li>
<p>After several years of scribing awesome notes about our development, Amir has handed over the reigns to <a href="https://github.com/engil">Enguerrand</a>.
Enguerrand joined OCaml Labs as an intern, and has built an IRC-to-Git logging bot which records our meetings over IRC and commits them
directly to a <a href="https://github.com/hannesm/canopy-data">repository</a> which is <a href="http://canopy.mirage.io/irclogs">available online</a>.  Thanks Amir
and Enguerrand for all their hard work on recording the growing amount of development in MirageOS.  <a href="https://ocaml.io/w/User:GemmaG">Gemma Gordon</a>
has also joined the project and been coordinating the <a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">meetings</a>.  The next one is in a
few hours, so please join us on <code>#mirage</code> on Freenode IRC at 4pm British time if you would like to participate or are just curious!</p>
</li>
<li>
<p>Our participation in the <a href="https://wiki.gnome.org/Outreachy/2016/MayAugust">Outreachy</a> program for 2016 has begun, and the irrepressible
<a href="http://www.gina.codes">Gina Marie Maini</a> (aka <a href="http://twitter.com/wiredsis">wiredsister</a>) has been hacking on syslogd, mentored by <a href="http://somerandomidiot.com">Mindy Preston</a>.
She has already started blogging (<a href="http://www.gina.codes/ocaml/2016/06/06/syslog-a-tale-of-specifications.html">about syslog</a> and <a href="http://www.gina.codes/ocaml/2016/02/14/dear-ocaml-i-love-you.html">OCaml love</a>), as well as <a href="http://hanselminutes.com/531/living-functional-programming-with-ocaml-and-gina-marie-maini">podcasting with the stars</a>.  Welcome to the crew, Gina!</p>
</li>
<li>
<p>The new <a href="https://docs.docker.com/engine/installation/mac/">Docker for Mac</a> and <a href="https://docs.docker.com/engine/installation/windows/">Docker for Windows</a> products have entered open beta! They use a number of libraries from MirageOS (including most of the network stack) and provide a fast way of getting started with containers and unikernel builds on Mac and Windows.  You can find talks about it at the recent <a href="https://ocaml.io/w/Blog:News/FP_Meetup:_OCaml,_Facebook_and_Docker_at_Jane_Street">JS London meetup</a> and my <a href="http://www.slideshare.net/AnilMadhavapeddy/advanced-docker-developer-workflows-on-macos-x-and-windows">slides</a>  I also spoke at OSCON 2016 about it, but those videos aren't online yet.</p>
</li>
</ul>
<p>There have also been a number of talks in the past couple of months about MirageOS and its libraries:</p>
<ul>
<li><a href="http://researcher.watson.ibm.com/researcher/view.php?person=us-djwillia">Dan Williams</a> from IBM Research delivered a paper at <a href="https://www.usenix.org/conference/hotcloud16/workshop-program/presentation/williams">USENIX HotCloud 2016</a> about <a href="https://www.usenix.org/system/files/conference/hotcloud16/hotcloud16_williams.pdf">Unikernel Monitors</a>. This explains the basis of his work on <a href="https://mirage.io/blog/introducing-solo5">Solo5</a>, which we are currently integrating into MirageOS as a KVM-based boot backend to complement the Xen port.  You can also find his <a href="https://www.usenix.org/sites/default/files/conference/protected-files/hotcloud16_slides_williams.pdf">talk slides</a> online.
</li>
<li><a href="https://twitter.com/amirmc">Amir Chaudhry</a> has given several talks and demos recently: check out his slides and detailed
writeups about <a href="http://amirchaudhry.com/gluecon2016">GlueCon 2016</a> and <a href="http://amirchaudhry.com/craftconf2016">CraftConf 2016</a> in particular,
as they come with instructions on how to reproduce his Mirage/ARM on-stage demonstrations of unikernels.
</li>
<li><a href="https://twitter.com/sgrove">Sean Grove</a> is speaking at <a href="http://polyconf.com">Polyconf 2016</a> next week in Poland.  If you are in the region, he would love to meet up with you as well -- his talk abstract is below
</li>
</ul>
<blockquote>
<p>With libraries like Mirage, <code>js_of_ocaml</code>, &amp; ARM compiler output OCaml apps can operate at such a low level
we don't even need operating systems on the backend anymore (removing 15 <em>million</em> lines of memory-unsafe code)</p>
<ul>
<li>while at the same time, writing UI's is easier &amp; more reliable than ever before, with lightweight type-checked
code sharing between server, browser clients, &amp; native mobile apps. We'll look at what's enabled by new tech
like Unikernels, efficient JS/ARM output, &amp; easy host interop.
</li>
</ul>
</blockquote>
|js};
      };
      {
        updated = {js|2016-5-4 16:00|js};
        authors =
          [
            {
              name = {js|Gemma Gordon|js};
              uri = Some {js|https://github.com/GemmaG|js};
              email = Some {js|gg417@cl.cam.ac.uk|js};
            };
          ];
        subject = {js|MirageOS Spring 2016 hack retreat!|js};
        permalink = {js|2016-spring-hackathon|js};
        body =
          {js|<p>We're looking forward to the next MirageOS hack retreat already!  We've collected some reports from those who were present at our <a href="http://retreat.mirage.io">2016 Spring hack retreat</a> to share our excitement!  Thanks to the folks who put in the time and effort to organize the event and our wonderful hosts, and a huge thanks to everyone who documented their hack retreat experience!</p>
<p>More information is also available at <a href="http://canopy.mirage.io">the Canopy site developed and used for information sharing during the hack retreat</a>!</p>
<h2>Trip Report</h2>
<p><em>by David Kaloper</em></p>
<p><img src="/graphics/2016-hackathon/roof_flash.jpg" alt="roof-flash" /></p>
<p>Last month, the MirageOS community saw its first community-organized, international
[hackathon][hweb]. It took place between 11th and 16th March 2016. The venue?
[Rihad Priscilla][priscilla], Marrakech, Morocco.</p>
<p>The place turned out to be ideal for a community building exercise. A city
bursting with life, scents and colors, a relaxed and friendly hostel with plenty
of space, warm and sunny weather -- all the elements of a good get-together
were there. This is where some 25 hackers from all over the world convened, with
various backgrounds and specialties, all sharing an interest in MirageOS.</p>
<p>Not wanting to limit ourselves to breaking only those conventions, we added another layer: the
hackathon was set up as a classical anti-conference, with a bare minimum of
structure, no pre-defined program, and a strong focus on one-on-one work,
teaching, and collaboration.</p>
<p>As this was the first hackathon, this time the focus was on building up the nascent
community that already exists around MirageOS. Faces were put to online handles, stories were
exchanged, and connections were forged. Meeting in person helped bring a new
level of cohesion to the online community around the project, as witnessed by
the flurry of online conversations between people that were present, and have continued after
the event ended.</p>
<p>One particularly useful (however inglorious) activity proved to be introducing
people to the tool chain. Even though the MirageOS website has a
[documentation][mirage-docs] section with various documents on the architecture
of the project, technical blog posts and a series of examples to get newcomers
started, a number of people found it difficult to juggle all the concepts and
tools involved. Where is the line dividing <code>ocamlfind</code> from <code>opam</code> and what
exactly constitutes an OCaml library? What is the correct way to declare
dependencies not covered by the declarative configuration language? When should
one use <code>add_to_opam_packages</code>, and when <code>add_to_ocamlfind_libraries</code>? Will the
<code>mirage</code> tool take care of installing missing packages so declared?</p>
<p>Although these questions either have answers scattered throughout the docs, or
are almost obvious to an experienced MirageOS developer, such getting-started
issues proved to be an early obstacle for a number of hackathon participants.
While our project documentation certainly could -- and will! -- be improved with
the perspective of a new developer in mind, this was an opportunity to help
participants get a more comprehensive overview of the core tooling in an
efficient, one-to-one setting. As a result, we saw a number of developers go
from trying to get the examples to compile to making their own unikernels within
a day, something pretty awesome to witness!</p>
<p>Another fun thread was dogfooding the network stack. Network itself was provided
by our venue Priscilla, but we brought our own routers and access points. DHCP on site was
served by [Charrua][charrua], which stood up to the task admirably. We were able
to access arbitrary domains on the Internet, almost all of the time!</p>
<p>A group of hackers had a strong web background, and decided to focus their
efforts there. Perhaps the most interesting project to come out of this is
[Canopy][canopy]. Canopy is best described as the first dynamic offering in the
space of static web site generators! It combines [Irmin][irmin] with
[TyXML][tyxml], [COW][cow], and [Mirage HTTP][mirage-http], to create a simple,
one-stop solution for putting content on the web. A Canopy unikernel boots,
pulls a series of markdown files from a git repository, renders them, and serves
them via HTTP. Expect more to come in this space, as Canopy has already proved
to be a handy tool to simply put something on the web.</p>
<p>At the same time, the atmosphere was conducive for discussing how OCaml
in general, and MirageOS in particular, fits in the web development ecosystem.
As a language originally honed in different contexts, it's the opinion of a number
of practicing web developers that the current OCaml ecosystem is not as
conducive to supporting their day-to-day work as it could be. These brainstorming
sessions led to a [writeup][adoption-manifesto] which tries to summarize the
current state and plot the course forward.</p>
<p>Another group of hackers was more focused on security and privacy
technology. MirageOS boasts its own cryptographic core and a TLS stack,
providing a solid base for development of cryptographic protocols. We saw
coordinated work on improving the [cryptographic layer][nocrypto-pr];
implementations of a few key-derivation functions ([Scrypt][scrypt] and
[PBKDF][pbkdf]); and even a beginning of an [IKEv2][ikev2] implementation.</p>
<p>A further common topic was networking, which is not entirely surprising for a
network-centric unikernel platform. Amidst the enthusiasm, hackers in attendance
started several projects related to general networking. These include a
[SWIM][swim] membership protocol implementation, the beginnings of
[telnet][telnet] for Mirage, [SOCKS4][socks] packet handling,
[DNS wildcard][dns-wcard] matching, Charrua updates, and more.</p>
<p>In between these threads of activity, people used the time to get general
MirageOS work done. This resulted in lots of progress including: making
[AFL][afl], already supported by OCaml, run against MirageOS unikernels; a
comprehensive update of error reporting across the stack; a concentrated push to
move away from Camlp4 and adopt PPX; and producing a prototype unikernel
displaying rich terminal output via telnet.</p>
<p>Partially motivated by the need to improve the experience of building and
running unikernels, a number of hackers worked on improvements to [error
reporting][syslog] and [logging][log-pr]. Improving the experience when things
go wrong will be an important part of helping folks make unikernels with
MirageOS.</p>
<p>For more, and less structured, details of what went on, check out the
[blog][event-blog] some of us kept, or the [meeting notes][meeting-notes] from
the few short morning meetings we had.</p>
<p>It seems that when surrounded by like-minded, skilled people, in a pleasant
atmosphere, and with absolutely nothing to do, people's curiosity will reliably
kick in. In between lieing in the sun (sunscreen was a hot commodity!), sinking
into the [midday heat][midday-heat], and talking to other hackers, not a single
person failed to learn, practice, or produce something new.</p>
<p>In this way, the first MirageOS hackathon was a resounding success. Friendships
were forged, skills shared, and courses plotted. And although the same venue has
already been booked for the next year's event, there is ongoing chit-chat about
cutting the downtime in half with a summer edition!</p>
<p><img src="/graphics/2016-hackathon/heat.jpg" alt="heat" /></p>
<h2>[hweb]: http://retreat.mirage.io/
[priscilla]: http://queenofthemedina.com/en/index.html
[mirage-docs]: https://mirage.io/docs
[charrua]: https://github.com/haesbaert/charrua-core
[canopy]: https://github.com/Engil/Canopy
[irmin]: https://github.com/mirage/irmin
[tyxml]: http://ocsigen.org/tyxml
[cow]: https://github.com/mirage/ocaml-cow
[mirage-http]: https://github.com/mirage/mirage-http
[adoption-manifesto]: https://github.com/fxfactorial/an-ocaml-adoption-manifesto
[nocrypto-pr]: https://github.com/mirleft/ocaml-nocrypto/pull/93
[scrypt]: https://github.com/abeaumont/ocaml-scrypt-kdf
[pbkdf]: https://github.com/abeaumont/ocaml-pbkdf
[ikev2]: https://github.com/isakmp/ike
[swim]: https://github.com/andreas/mirage-swim
[telnet]: https://github.com/hannesm/telnet
[socks]: https://github.com/cfcs/ocaml-socks
[dns-wcard]: https://github.com/cfcs/ocaml-wildcard
[afl]: http://lcamtuf.coredump.cx/afl/
[event-blog]: http://canopy.mirage.io/
[meeting-notes]: https://github.com/ocamllabs/activity/wiki/MirageOS-Hackathon
[midday-heat]: https://twitter.com/rudenoise/status/709453313553596416
[syslog]: https://github.com/verbosemode/syslogd-mirage
[log-pr]: https://github.com/mirage/mirage-dev/pull/107</h2>
<h2>MirageOS hackathon in Marrakech</h2>
<p><em>Text and images by Enguerrand Decorne</em></p>
<h3>Setting up and settling in</h3>
<p>The first <a href="https://mirage.io/">MirageOS hackathon</a> was held from March 11th-16th 2016, at <a href="http://queenofthemedina.com/en/index.html">Priscilla, Queen of the Medina</a>, Marrakech. It successfully gathered around 30 Mirage enthusiasts, some already familiar with the MirageOS ecosystem, and others new to the community. People travelled from Europe and further afield for a week of sun, tajine and hacking.</p>
<p><img src="/graphics/2016-hackathon/main_room.jpg" alt="Main room" title="The main room" /></p>
<p>Getting to the guesthouse <a href="https://www.youtube.com/watch?v=zgzwmyxlKBE">was an adventure</a>, and once there we prepared by quickly setting up a nice internet hotspot then organised groups to head to the souk to meet new arrivals.
Soon enough the guest house was filled with people, and various new projects and ideas began to emerge. Having a few books and experienced OCaml developers around helped the OCaml newcomers get stuck in, and it didn't take long to get their first unikernel or OCaml library up and running. Daily meetings were arranged at noon on the rooftop in order to allow the exchange of project ideas and questions, and we used the <a href="http://canopy.mirage.io/Index">hackathon notepad</a> to loosely pair projects and people together. Our <a href="https://mirage.io/blog/introducing-charrua-dhcp">DHCP server</a> enabled extensive dogfooding and successfully fulfilled our project-testing needs.</p>
<p>Participants found a wide range of activities to keep themselves occupied during the event: contributing to the <a href="https://github.com/mirage/mirage-www/wiki/Pioneer-Projects">MirageOS Pioneer Projects</a>, starting new projects and libraries, improving the MirageOS ecosystem and core components, discussing new ideas... or simply enjoying the sun, delicious tajine, or walking around Marrakech itself. Some expeditions were also (non)organised during the week, allowing sightseeing of the nicest local spots, or negotiating with local stallholders to get the best prices on souvenirs and fresh fruits to enjoy during hard hacking sessions.</p>
<p><img src="/graphics/2016-hackathon/food.jpg" alt="Food" title="Some more food" /></p>
<h3>My week inside the camel's nest</h3>
<p>A few days before heading up to Marrakech (in a very non-organised fashion, having been offered a hackathon place only two days before!) the idea of writing some kind of notebook using Mirage had been floating around - we wanted to be able to allow people inside the hackathon to exchange ideas, and those not physically present to be kept updated about progress. I decided to write a simple blog unikernel, <a href="https://github.com/Engil/Canopy/">Canopy</a> which relies on <a href="https://github.com/mirage/irmin">Irmin's</a> capabilities to synchronise remote git repositiories. By describing new pages in a format similar to Jekyll (and using Markdown) on a git repository, new content pushed there would be pulled to the website and displayed there nicely. This allowed every participant to report on their current projects, and see the content displayed on the notepad after a simple <code>git push</code>.</p>
<p>The project was well received and new ideas started to emerge in order to turn it into a CMS enabling users to easily describe new website with a simple git repository. A huge thank you to <a href="https://github.com/mmaker">Michele</a> for his awesome contributions, as well as everyone involved with answering questions about the Mirage ecosystem along the way. This project also allowed me to dive a little further inside various libraries, report a few issues, discuss features and discover new concepts... A week well spent that I would be glad to repeat at the next MirageOS hackathon :)</p>
<h3>Conclusion</h3>
<p><img src="/graphics/2016-hackathon/rooftop.jpg" alt="Rooftop" title="Rooftop view" /></p>
<p>This hackathon was a huge success and allowed the MirageOS community to combine sun and high productivity in a crazy yet very relaxing week. We hope (and plan) to see more events like this, so anyone interested in OCaml, Mirage - expert or not - is more than welcome to join us next time!</p>
<h2><img src="/graphics/2016-hackathon/cats.jpg" alt="Cats" title="And obviously… Marrakech's cats!" /></h2>
<h2>MirageOS + OCaml Newcomers</h2>
<p><em>by Alfredo and Sonia</em></p>
<p>Our experience in Marrakesh was great. We really enjoyed the place,
the weather, the food, the people and the atmosphere! I think the
setting was a great win, there was lot of open space where you could
find a quiet spot for yourself to concentrate while programming,
as well as a place with lots of people coding, or a place where you
could be talking about anything while enjoying the sun, or just hang
out and get lost for a while in the nice Marrakesh's old city.</p>
<p>We had already learnt some OCaml, but we both are quite new to both
OCaml and MirageOS, so we decided to work on a project with low entry
barrier so we could get in the loop more easily. Nevertheless we had to
invest some time getting more familiar with the specifics of the OCaml
environment (libraries, packaging, testing frameworks, etc.). Hannes
kindly helped us getting started, showing us a library (<code>ocaml-hkdf</code>) we
could use to understand this all better, and from here we could start
writing some code. Having most of the authors (Thomas, David,
Hannes...) of the libraries we used (<code>nocrypto</code>, <code>cstruct</code>, <code>alcotest</code>,
<code>opam</code>...) there with us was also a win. Finally we managed to release a
pair of libraries with key derivation functions (<code>ocaml-pbkdf</code> and
<code>ocaml-scrypt-kdf</code>), so we are quite happy with the outcome.</p>
<h2>The only downside of the hackathon we can think of, if any, is that we
didn't get too deep into the MirageOS specifics (something we are
surely willing to fix!), but we wanted to stay focused to keep
productive and had enough new things to learn.</h2>
<h2>Hackathon Projects</h2>
<p><em>by Ximin Luo</em></p>
<p>Here's a list of things I did during the hackathon:</p>
<ul>
<li>Read into ocaml-tls and ocaml-otr implementations, as well as David's &quot;nqsb&quot; TLS paper
</li>
<li>Talked with David about developing a general pattern for implementing protocols, that allows one to compose components more easily and consistently. He pointed me to many resources that I could learn from and build on top of.
</li>
<li>Read documents on &quot;Extensible Effects&quot;, &quot;Freer Monads&quot; and &quot;Iteratee pattern&quot; by Oleg Kiselyov.
</li>
<li>Read documents and source code of the Haskell Pipes library by Gabriel Gonzalez.
</li>
<li>Sent some PRs to Hannes' jackline IM client, for better usability under some graphical environments.
</li>
<li>Showed some people my ocaml-hello &quot;minimal build scripts&quot; example, and my ocaml emacs scripts.
</li>
<li>Tested the &quot;solo5&quot; system that runs mirageos on kvm as an alternative to xen.
</li>
</ul>
<p>I'm continuing with the following work in my spare time:</p>
<ul>
<li>Read documents and source code of the opam monadlib library with a view to extending this and unifying it with other libraries such as lwt.
</li>
<li>Using the approach of the Haskel Pipes library to develop a general protocol handler framework. I'm experimenting initially in Haskell but I'd also like to do it in OCaml when the ideas are more solid.
</li>
</ul>
<p>In terms of the event it was great - everything worked out very well, I don't have any suggestions for improvements :)</p>
|js};
      };
      {
        updated = {js|2016-5-3 18:00|js};
        authors =
          [
            {
              name = {js|Hannes Mehnert|js};
              uri = Some {js|https://github.com/hannesm|js};
              email = Some {js|hm519@cam.ac.uk|js};
            };
          ];
        subject = {js|MirageOS security advisory 00: mirage-net-xen|js};
        permalink = {js|MSA00|js};
        body =
          {js|<h2>MirageOS Security Advisory 00 - memory disclosure in mirage-net-xen</h2>
<ul>
<li>Module:       mirage-net-xen
</li>
<li>Announced:    2016-05-03
</li>
<li>Credits:      Enguerrand Decorne, Thomas Leonard, Hannes Mehnert, Mindy Preston
</li>
<li>Affects:      mirage-net-xen &lt;1.4.2
</li>
<li>Corrected:    2016-01-08 1.5.0 release, 2016-05-03 1.4.2 release
</li>
</ul>
<p>For general information regarding MirageOS Security Advisories,
please visit <a href="https://mirage.io/security">https://mirage.io/security</a>.</p>
<p>Hannes published a <a href="https://hannes.nqsb.io/Posts/BadRecordMac">blog article</a> about
the analysis of this issue.</p>
<h3>Background</h3>
<p>MirageOS is a library operating system using cooperative multitasking, which can
be executed as a guest of the Xen hypervisor.  Virtual devices, such as a
network device, share memory between MirageOS and the hypervisor.  MirageOS
allocates and grants the hypervisor access to a ringbuffer containing pages to
be sent on the network device, and another ringbuffer with pages to be filled
with received data.  A write on the MirageOS side consists of filling the page
with the packet data, submitting a write request to the hypervisor, and awaiting
a response from the hypervisor.  To correlate the request with the response, a
16bit identifier is used.</p>
<h3>Problem Description</h3>
<p>Generating this 16bit identifier was not done in a unique manner.  When multiple
pages share an identifier, and are requested to be transmitted via the wire, the
first successful response will mark all pages with this identifier free, even
those still waiting to be transmitted.  Once marked free, the MirageOS
application fills the page for another chunk of data.  This leads to corrupted
packets being sent, and can lead to disclosure of memory intended for another
recipient.</p>
<h3>Impact</h3>
<p>This issue discloses memory intended for another recipient.  All versions before
mirage-net-xen 1.4.2 are affected.  The receiving side uses a similar mechanism,
which may lead to corrupted incoming data (eventually even mutated while being
processed).</p>
<p>Version 1.5.0, released on 8th January, already assigns unique identifiers for
transmission.  Received pages are copied into freshly allocated buffers before
passed to the next layer.  When 1.5.0 was released, the impact was not clear to
us.  Version 1.6.1 now additionally ensures that received pages have a unique
identifier.</p>
<h3>Workaround</h3>
<p>No workaround is available.</p>
<h3>Solution</h3>
<p>The unique identifier is now generated in a unique manner using a monotonic
counter.</p>
<p>Transmitting corrupt data and disclosing memory is fixed in versions 1.4.2 and
above.</p>
<p>The recommended way to upgrade is:</p>
<pre><code class="language-bash">opam update
opam upgrade mirage-net-xen
</code></pre>
<p>Or, explicitly:</p>
<pre><code class="language-bash">opam upgrade
opam reinstall mirage-net-xen=1.4.2
</code></pre>
<p>Affected releases have been marked uninstallable in the opam repository.</p>
<h3>Correction details</h3>
<p>The following list contains the correction revision numbers for each
affected branch.</p>
<p>Memory disclosure on transmit:</p>
<p>master: <a href="https://github.com/mirage/mirage-net-xen/commit/47de2edfad9c56110d98d0312c1a7e0b9dcc8fbf">47de2edfad9c56110d98d0312c1a7e0b9dcc8fbf</a></p>
<p>1.4: <a href="https://github.com/mirage/mirage-net-xen/commit/ec9b1046b75cba5ae3473b2d3b223c3d1284489d">ec9b1046b75cba5ae3473b2d3b223c3d1284489d</a></p>
<p>Corrupt data while receiving:</p>
<p>master: <a href="https://github.com/mirage/mirage-net-xen/commit/0b1e53c0875062a50e2d5823b7da0d8e0a64dc37">0b1e53c0875062a50e2d5823b7da0d8e0a64dc37</a></p>
<p>1.4: <a href="https://github.com/mirage/mirage-net-xen/commit/6daad38af2f0b5c58d6c1fb24252c3eed737ede4">6daad38af2f0b5c58d6c1fb24252c3eed737ede4</a></p>
<h3>References</h3>
<p><a href="https://github.com/mirage/mirage-net-xen">mirage-net-xen</a></p>
<p>You can find the latest version of this advisory online at
<a href="https://mirage.io/blog/MSA00">https://mirage.io/blog/MSA00</a>.</p>
<p>This advisory is signed using OpenPGP, you can verify the signature
by downloading our public key from a keyserver (<code>gpg --recv-key 4A732D757C0EDA74</code>),
downloading the raw markdown source of this advisory from <a href="https://raw.githubusercontent.com/mirage/mirage-www/master/tmpl/advisories/00.txt.asc">GitHub</a>
and executing <code>gpg --verify 00.md.asc</code>.</p>
|js};
      };
      {
        updated = {js|2016-2-29 12:00|js};
        authors =
          [
            {
              name = {js|Gabriel Radanne|js};
              uri = Some {js|https://github.com/drup|js};
              email = Some {js|drupyog@zoho.com|js};
            };
          ];
        subject = {js|Introducing Functoria|js};
        permalink = {js|introducing-functoria|js};
        body =
          {js|<p>For the last few months, I've been working with <a href="http://www.gazagnaire.org">Thomas</a> on improving the <code>mirage</code> tool and
I'm happy to present <a href="https://github.com/mirage/functoria">Functoria</a>, a library to create arbitrary MirageOS-like DSLs. Functoria is independent from <code>mirage</code> and will replace the core engine, which was somewhat bolted on to the tool until now.</p>
<p>This introduces a few breaking changes so please consult
<a href="../docs/breaking-changes">the breaking changes page</a> to see what is different and how to fix things if needed.
The good news is that it will be much more simple to use, much more flexible,
and will even produce pretty pictures!</p>
<h2>Configuration</h2>
<p>For people unfamiliar with MirageOS, the <code>mirage</code> tool handles configuration of mirage unikernels by reading an OCaml file describing the various pieces and dependencies of the project.
Based on this configuration it will use <a href="http://opam.ocaml.org/">opam</a> to install the dependencies, handle various configuration tasks and emit a build script.</p>
<p>A very simple configuration file looks like this:</p>
<pre><code>open Mirage
let main = foreign &quot;Unikernel.Main&quot; (console @-&gt; job)
let () = register &quot;console&quot; [main $ default_console]
</code></pre>
<p>It declares a new functor, <code>Unikernel.Main</code>, which take a console as an argument and instantiates it on the <code>default_console</code>. For more details about unikernel configuration, please read the <a href="../wiki/hello-world">hello-world</a> tutorial.</p>
<h2>Keys</h2>
<p>A <a href="https://github.com/mirage/mirage/issues/229">much</a> <a href="https://github.com/mirage/mirage/issues/228">demanded</a> <a href="https://github.com/mirage/mirage/issues/231">feature</a> has been the ability to define so-called bootvars.
Bootvars are variables whose value is set either at configure time or at
startup time.</p>
<p>A good example of a bootvar would be the IP address of the HTTP stack. For example, you may wish to:</p>
<ul>
<li>Set a good default directly in the <code>config.ml</code>
</li>
<li>Provide a value at configure time, if you are already aware of deployment conditions.
</li>
<li>Provide a value at startup time, for last minute changes.
</li>
</ul>
<p>All of this is now possible using <strong>keys</strong>. A key is composed of:</p>
<ul>
<li><em>name</em> — The name of the value in the program.
</li>
<li><em>description</em> — How it should be displayed/serialized.
</li>
<li><em>stage</em> — Is the key available only at runtime, at configure time, or both?
</li>
<li><em>documentation</em> — This is not optional, so you have to write it.
</li>
</ul>
<p>Imagine we are building a multilingual unikernel and we want to pass the
default language as a parameter. The language parameter is an optional string, so we use the <a href="http://mirage.github.io/functoria/Functoria_key.Arg.html#VALopt"><code>opt</code></a> and <a href="http://mirage.github.io/functoria/Functoria_key.Arg.html#VALstring"><code>string</code></a> combinators. We want to be able to define it both
at configure and run time, so we use the stage <code> `Both</code>. This gives us the following code:</p>
<pre><code>let lang_key =
  let doc = Key.Arg.info
      ~doc:&quot;The default language for the unikernel.&quot; [ &quot;l&quot; ; &quot;lang&quot; ]
  in
  Key.(create &quot;language&quot; Arg.(opt ~stage:`Both string &quot;en&quot; doc))
</code></pre>
<p>Here, we defined both a long option <code>--lang</code>, and a short one <code>-l</code>, (the format is similar to the one used by <a href="http://erratique.ch/software/cmdliner">Cmdliner</a>).
In the unikernel, the value is retrieved with <code>Key_gen.language ()</code>.</p>
<p>The option is also documented in the <code>--help</code> option for both <code>mirage configure</code> (at configure time) and <code>./my_unikernel</code> (at startup time).</p>
<pre><code>       -l VAL, --lang=VAL (absent=en)
           The default language for the unikernel.
</code></pre>
<p>A simple example of a unikernel with a key is available in <a href="https://github.com/mirage/mirage-skeleton">mirage-skeleton</a> in the <a href="https://github.com/mirage/mirage-skeleton/tree/master/hello"><code>hello</code> directory</a>.</p>
<h3>Switching implementation</h3>
<p>We can do much more with keys, for example we can use them to switch devices at configure time.
To illustrate, let us take the example of dynamic storage, where we want to choose between a block device and a crunch device with a command line option.
In order to do that, we must first define a boolean key:</p>
<pre><code>let fat_key =
  let doc = Key.Arg.info
      ~doc:&quot;Use a fat device if true, crunch otherwise.&quot; [ &quot;fat&quot; ]
  in
  Key.(create &quot;fat&quot; Arg.(opt ~stage:`Configure bool false doc))
</code></pre>
<p>We can use the <a href="http://mirage.github.io/functoria/Functoria.html#VALif_impl"><code>if_impl</code></a> combinator to choose between two devices depending on the value of the key.</p>
<pre><code>let dynamic_storage =
  if_impl (Key.value fat_key)
    (kv_ro_of_fs my_fat_device)
    (my_crunch_device)
</code></pre>
<p>We can now use this device as a normal storage device of type <code>kv_ro impl</code>! The key is also documented in <code>mirage configure --help</code>:</p>
<pre><code>       --fat=VAL (absent=false)
           Use a fat device if true, crunch otherwise.
</code></pre>
<p>It is also possible to compute on keys before giving them to <code>if_impl</code>, combining multiple keys in order to compute a value, and so on. For more details, see the <a href="http://mirage.github.io/functoria/">API</a> and the various examples available in <a href="https://github.com/mirage/mirage">mirage</a> and <a href="https://github.com/mirage/mirage-skeleton">mirage-skeleton</a>.</p>
<p>Switching keys opens various possibilities, for example a <code>generic_stack</code> combinator is now implemented in <code>mirage</code> that will switch between socket stack, direct stack with DHCP, and direct stack with static IP, depending on command line arguments.</p>
<h2>Drawing unikernels</h2>
<p>All these keys and dynamic implementations make for complicated unikernels. In order to clarify what is going on and help to configure our unikernels, we have a new command: <code>describe</code>.</p>
<p>Let us consider the <code>console</code> example in <a href="https://github.com/mirage/mirage-skeleton">mirage-skeleton</a>:</p>
<pre><code>open Mirage

let main = foreign &quot;Unikernel.Main&quot; (console @-&gt; job)
let () = register &quot;console&quot; [main $ default_console]
</code></pre>
<p>This is fairly straightforward: we define a <code>Unikernel.Main</code> functor using a console and we
instantiate it with the default console. If we execute <code>mirage describe --dot</code> in this directory, we will get the following output.</p>
<p><a href="../graphics/dot/console.svg"><img src="../graphics/dot/console.svg" alt="A console unikernel" title="My little unikernel" /></a></p>
<p>As you can see, there are already quite a few things going on!
Rectangles are the various devices and you'll notice that
the <code>default_console</code> is actually two consoles: the one on Unix and the one on Xen. We use the <code>if_impl</code> construction — represented as a circular node — to choose between the two during configuration.</p>
<p>The <code>key</code> device handles the runtime key handling. It relies on an <code>argv</code> device, which is similar to <code>console</code>. Those devices are present in all unikernels.</p>
<p>The <code>mirage</code> device is the device that brings all the jobs together (and on the hypervisor binds them).</p>
<h2>Data dependencies</h2>
<p>You may have noticed dashed lines in the previous diagram, in particular from <code>mirage</code> to <code>Unikernel.Main</code>. Those lines are data dependencies. For example, the <code>bootvar</code> device has a dependency on the <code>argv</code> device. It means that <code>argv</code> is configured and run first, returns some data — an array of string — then <code>bootvar</code> is configured and run.</p>
<p>If your unikernel has a data dependency — say, initializing the entropy — you can use the <code>~deps</code> argument on <code>Mirage.foreign</code>. The <code>start</code> function of the unikernel will receive one extra argument for each dependency.</p>
<p>As an example, let us look at the <a href="http://mirage.github.io/functoria/Functoria_app.html#VALapp_info"><code>app_info</code></a> device. This device makes the configuration information available at runtime. We can declare a dependency on it:</p>
<pre><code>let main =
  foreign &quot;Unikernel.Main&quot; ~deps:[abstract app_info] (console @-&gt; job)
</code></pre>
<p><a href="../graphics/dot/info.svg"><img src="../graphics/dot/info.svg" alt="A unikernel with info" title="My informed unikernel" /></a></p>
<p>The only difference with the previous unikernel is the data dependency — represented by a dashed arrow — going from <code>Unikernel.Main</code> to <code>Info_gen</code>. This means that <code>Unikernel.Main.start</code> will take an extra argument of type <code>Mirage_info.t</code> which we can, for example, print:</p>
<pre><code>name: console
libraries: [functoria.runtime; lwt.syntax; mirage-console.unix;
            mirage-types.lwt; mirage.runtime; sexplib]
packages: [functoria.0.1; lwt.2.5.0; mirage-console.2.1.3; mirage-unix.2.3.1;
           sexplib.113.00.00]
</code></pre>
<p>The complete example is available in <a href="https://github.com/mirage/mirage-skeleton">mirage-skeleton</a> in the <a href="https://github.com/mirage/mirage-skeleton/tree/master/app_info"><code>app_info</code> directory</a>.</p>
<h2>Sharing</h2>
<p>Since we have a way to draw unikernels, we can now observe the sharing between various pieces. For example, the direct stack with static IP yields this diagram:</p>
<p><a href="../graphics/dot/stack.svg"><img src="../graphics/dot/stack.svg" alt="A stack unikernel" title="My stack unikernel" /></a></p>
<p>You can see that all the sub-parts of the stack have been properly shared. To be merged, two devices must have the same name, keys, dependencies and functor arguments.
To force non-sharing of two devices, it is enough to give them different names.</p>
<p>This sharing also works up to switching keys. The generic stack gives us this diagram:</p>
<p><a href="../graphics/dot/dynamic.svg"><img src="../graphics/dot/dynamic.svg" alt="A dynamic stack unikernel" title="My generic unikernel" /></a></p>
<p>If you look closely, you'll notice that there are actually <em>three</em> stacks in the last example: the <em>socket</em> stack, the <em>direct stack with DHCP</em>, and the <em>direct stack with IP</em>. All controlled by switching keys.</p>
<h2>All your functors are belong to us</h2>
<p>There is more to be said about the new capabilities offered by functoria, in particular on how to define new devices. You can discover them by looking at the <a href="https://github.com/mirage/mirage">mirage</a> implementation.</p>
<p>However, to wrap up this blog post, I offer you a visualization of the MirageOS website itself (brace yourself). <a href="../graphics/dot/www.svg">Enjoy!</a></p>
<p><em>Thanks to <a href="http://mort.io">Mort</a>, <a href="http://somerandomidiot.com">Mindy</a>, <a href="http://amirchaudhry.com">Amir</a> and <a href="https://github.com/yallop">Jeremy</a>
for their comments on earlier drafts.</em></p>
|js};
      };
      {
        updated = {js|2016-11-17 16:00|js};
        authors =
          [
            {
              name = {js|Thomas Gazagnaire|js};
              uri = Some {js|http://gazagnaire.org|js};
              email = Some {js|thomas@gazagnaire.org|js};
            };
          ];
        subject = {js|Irmin 0.12 with portable filesystem watching released|js};
        permalink = {js|irmin-0.12|js};
        body =
          {js|<p>Development of the <a href="https://github.com/mirage/irmin">Irmin</a> Git-like data store continues (see <a href="/blog/introducing-irmin">here</a> for an introduction). We are releasing <a href="https://github.com/mirage/irmin/releases/tag/0.12.0">Irmin 0.12.0</a> which brings support for native file-system watchers to greatly improve the performance of watches on the datastore.</p>
<p>Previously, an Irmin application that wanted to use watches would setup file-system scanning/polling by doing:</p>
<pre><code>  let () = Irmin_unix.install_dir_polling_listener 1.0
</code></pre>
<p>which would scan the <code>.git/refs</code> directory every second. This worked in practice but was unpredictably latent (if unlucky you might wait for a full second for the watch callbacks to trigger), and disk/CPU intensive as we were scanning the full storage directory every second to detect file changes.  In the cases where the store had 1000s of tags, this could easily saturate the CPU. And in case you were wondering, there are increasing number of applications (such as <a href="https://github.com/docker/datakit">DataKit</a>) that do create thousands of tags regularly, and <a href="https://github.com/engil/Canopy">Canopy</a> that need low latency for interactive development.</p>
<p>In the new 0.12.0 release, you need to use:</p>
<pre><code>   let () = Irmin_unix.set_listen_dir_hook ()
</code></pre>
<p>and the Irmin storage will do &quot;the right thing&quot;. If you are on Linux, and have the <a href="https://opam.ocaml.org/packages/inotify/">inotify OPAM package</a> installed, it will use libinotify to get notified by the kernel on every change and re-scan the whole directory. On OSX, if you have the <a href="https://opam.ocaml.org/packages/osx-fsevents/">osx-fsevents OPAM package</a> installed, it will do the same thing using the OSX <a href="https://en.wikipedia.org/wiki/FSEvents">FSEvents.framework</a>. The portable compatibility layer between inotify and fsevents comes via the new <a href="https://github.com/samoht/irmin-watcher/releases/tag/0.2.0">irmin-watcher</a> package that has been released recently as well.  This may also come in useful for other tools that require portable OCaml access to filesystem hierarchies.</p>
<p>If you are using Irmin, please do let us know how you are getting on via the
<a href="https://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a>
and report any bugs on the <a href="https://github.com/mirage/irmin/issues">issue tracker</a>.</p>
|js};
      };
      {
        updated = {js|2016-1-7 18:10|js};
        authors =
          [
            {
              name = {js|Dan Williams|js};
              uri = Some {js|https://github.com/djwillia|js};
              email = Some {js|djwillia@us.ibm.com|js};
            };
          ];
        subject = {js|Run Mirage Unikernels on KVM/QEMU with Solo5|js};
        permalink = {js|introducing-solo5|js};
        body =
          {js|<p>I'm excited to announce the release of
<a href="https://github.com/solo5/solo5">Solo5</a>!
Solo5 is essentially a kernel library that bootstraps the hardware and
forms a base (similar to Mini-OS) from which unikernels can be built.
It runs on fully virtualized x86 hardware (e.g., KVM/QEMU), using
<code>virtio</code> device interfaces.</p>
<p>Importantly, Solo5 is integrated (to some extent) with the MirageOS
toolstack, so the Solo5 version of the Mirage toolstack can build
Mirage unikernels that run directly on KVM/QEMU instead of Xen.  As
such, Solo5 can be considered an alternative to Mini-OS in the Mirage
stack.  <a href="https://github.com/solo5/solo5">Try it out
today!</a></p>
<p>In the rest of this post, I'll give a bit of motivation about why I
think the lowest layer of the unikernel is interesting and important,
as well as a rough overview of the steps I took to create Solo5.</p>
<h3>Why focus so far down the software stack?</h3>
<p>When people think about Mirage unikernels, one of the first things
that comes to mind is the use of a high-level language (OCaml).
Indeed, the Mirage community has invested lots of time and effort
producing implementations of traditional system components (e.g., an
entire <a href="https://github.com/mirage/mirage-tcpip">TCP stack</a>) in OCaml.  The pervasive use of OCaml contributes to
security arguments for Mirage unikernels (strong type systems are
good) and is an interesting design choice well worth exploring.</p>
<p>But underneath all of that OCaml goodness is a little kernel layer
written in C.  This layer has a direct impact on:</p>
<ul>
<li>
<p><strong>What environments the unikernel can run on.</strong> Mini-OS, for
example, assumes a paravirtualized (Xen) machine, whereas Solo5
targets full x86 hardware virtualization with <code>virtio</code> devices.</p>
</li>
<li>
<p><strong>Boot time.</strong> &quot;Hardware&quot; initialization (or lack of it in a
paravirtualized case) is a major factor in achieving the 20 ms
unikernel boot times that are changing the way people think about
elasticity in the cloud.</p>
</li>
<li>
<p><strong>Memory layout and protection.</strong> Hardware &quot;features&quot; like
page-level write protection must be exposed by the lowest layer for
techniques like memory tracing to be performed.  Also,
software-level strategies like address space layout randomization
require cooperation of this lowest layer.</p>
</li>
<li>
<p><strong>Low-level device interfacing.</strong> As individual devices (e.g., NICs)
gain virtualization capabilities, the lowest software layer is an
obvious place to interface directly with hardware.</p>
</li>
<li>
<p><strong>Threads/events.</strong> The low-level code must ensure that device I/O
is asynchronous and/or fits with the higher-level synchronization
primitives.</p>
</li>
</ul>
<p>The most popular existing code providing this low-level kernel layer
is called Mini-OS.  Mini-OS was (I believe) originally written as
a vehicle to demonstrate the paravirtualized interface offered by Xen
for people to have a reference to port their kernels to and as a base
for new kernel builders to build specialized Xen domains.  Mini-OS is
a popular base for <a href="https://mirage.io">MirageOS</a>,
<a href="http://cnp.neclab.eu/projects/clickos/">ClickOS</a>,
and <a href="http://unikernel.org/projects/">other unikernels</a>.  Other
software that implements a unikernel base include
<a href="http://rumpkernel.org/">Rumprun</a> and <a href="http://osv.io/">OSv</a>.</p>
<p>I built Solo5 from scratch (rather than adapting Mini-OS, for example)
primarily as an educational (and fun!) exercise to explore and really
understand the role of the low-level kernel layer in a unikernel.  To
provide applications, Solo5 supports the Mirage stack.  It is my hope
that Solo5 can be a useful base for others; even if only at this point
to run some Mirage applications on KVM/QEMU!</p>
<h3>Solo5: Building a Unikernel Base from Scratch</h3>
<p>At a high level, there are roughly 3 parts to building a unikernel
base that runs on KVM/QEMU and supports Mirage:</p>
<ul>
<li>
<p><strong>Typical kernel hardware initialization.</strong> The kernel must know how
to load things into memory at the desired locations and prepare
the processor to operate in the correct mode (e.g., 64-bit).  Unlike
typical kernels, most setup is one-time and simplified.  The kernel
must set up a memory map, stack, interrupt vectors, and provide
primitives for basic memory allocation.  At its simplest, a
unikernel base kernel does not need to worry about user address
spaces, threads, or many other things typical kernels need.</p>
</li>
<li>
<p><strong>Interact with <code>virtio</code> devices.</strong> <code>virtio</code> is a paravirtualized
device standard supported by some hypervisors, including KVM/QEMU
and Virtualbox.  As far as devices go, <code>virtio</code> devices are simple:
I was able to write (very simple/unoptimized) <code>virtio</code> drivers for
Solo5 drivers from scratch in C.  At some point it may be
interesting to write them in OCaml like the Xen device drivers in
Mirage, but for someone who doesn't know OCaml (like me) a simple C
implementation seemed like a good first step.  I should note that
even though the drivers themselves are written in C, Solo5 does
include some OCaml code to call out to the drivers so it can connect with
Mirage.</p>
</li>
<li>
<p><strong>Appropriately link Mirage binaries/build system.</strong> A piece of
software called <a href="https://github.com/mirage/mirage-platform">mirage-platform</a>
performs the binding between Mini-OS
and the rest of the Mirage stack.  Building a new unikernel base
means that this &quot;cut point&quot; will have lots of undefined dependencies
which can either be implemented in the new unikernel base, stubbed
out, or reused.  Other &quot;cut points&quot; involve device drivers: the
console, network and block devices.  Finally, the <code>mirage</code> tool
needs to output appropriate Makefiles for the new target and an
overall Makefile needs to put everything together.</p>
</li>
</ul>
<p>Each one of these steps carries complexity and gotchas and I have
certainly made many mistakes when performing all of them.  The
hardware initialization process is needlessly complex, and the overall
Makefile reflects my ignorance of OCaml and its building and packaging
systems.  It's a work in progress!</p>
<h3>Next Steps and Getting Involved</h3>
<p>In addition to the aforementioned clean up, I'm currently exploring
the boot time in this environment.  So far I've found that generating
a bootable iso with GRUB as a bootloader and relying on QEMU to
emulate BIOS calls to load the kernel is, by the nature of emulation,
inefficient and something that should be avoided.</p>
<p>If you find the lowest layer of the unikernel interesting, please
don't hesitate to contact me or get involved.  I've packaged the build
and test environment for Solo5 into a Docker container to reduce the
dependency burden in playing around with it.  Check out <a href="https://github.com/solo5/solo5">the
repo</a> for the full
instructions!</p>
<p>I'll be talking about Solo5 at the upcoming <a href="http://wiki.xenproject.org/wiki/2016_Unikernels_and_More:_Cloud_Innovators_Forum_Schedule">2016 Unikernels and More:
Cloud Innovators
Forum</a>
event to be held on January 22, 2016 at <a href="https://www.socallinuxexpo.org/scale/14x">SCALE
14X</a> in Pasadena, CA USA.  I
look forward to meeting some of you there!</p>
<p><em>Discuss this post on <a href="https://devel.unikernel.org/t/run-mirage-unikernels-on-kvm-qemu-with-solo5/59">devel.unikernel.org</a></em></p>
<p><em>Thanks to <a href="https://twitter.com/amirmc">Amir</a>,
<a href="http://mort.io">Mort</a>,
and <a href="https://github.com/yallop">Jeremy</a>,
for taking the time to read and comment on earlier drafts.</em></p>
|js};
      };
      {
        updated = {js|2016-1-1 23:42|js};
        authors =
          [
            {
              name = {js|Hannes Mehnert|js};
              uri = Some {js|https://github.com/hannesm|js};
              email = Some {js|hm519@cam.ac.uk|js};
            };
          ];
        subject = {js|MirageOS hack retreat|js};
        permalink = {js|hackathon-marrakech2016|js};
        body =
          {js|<p>The first MirageOS hack retreat will take place in Marrakech, Morocco, from 11th till 16th March 2016.  It is open for everybody.  The main goal is to get together people motivated to contribute to MirageOS.</p>
<p>Find more details on <a href="http://retreat.mirage.io">the hack retreat website</a>.</p>
<p><em>Edit: discuss this post on <a href="https://devel.unikernel.org/t/1st-mirageos-hackathon/24/1">devel.unikernel.org</a></em></p>
|js};
      };
      {
        updated = {js|2015-12-29 15:30|js};
        authors =
          [
            {
              name = {js|Christiano Haesbaert|js};
              uri = Some {js|http://www.haesbaert.org/|js};
              email = Some {js|haesbaert@haesbaert.org|js};
            };
          ];
        subject = {js|Introducing Charrua — a DHCP implementation|js};
        permalink = {js|introducing-charrua-dhcp|js};
        body =
          {js|<p>Almost every network needs to support
<a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol">DHCP</a>
(Dynamic
Host Configuration Protocol), that is, a way for clients to request network
parameters from the environment. Common parameters are an IP address, a network
mask, a default gateway and so on.</p>
<p>DHCP can be seen as a critical security component, since it deals usually with
unauthenticated/unknown peers, therefore it is of special interest to run a
server as a self-contained MirageOS unikernel.</p>
<p><a href="http://www.github.com/haesbaert/charrua-core">Charrua</a> is a DHCP implementation
written in OCaml and it started off as an excuse to learn more about the language.
While in development it got picked up on the MirageOS mailing lists and became one
of the <a href="https://github.com/mirage/mirage-www/wiki/Pioneer-Projects">Pioneer
Projects</a>.</p>
<p>The name <code>Charrua</code> is a reference to the, now extinct, semi-nomadic people of
southern South America — nowadays it is also used to refer to Uruguayan
nationals. The logic is that DHCP handles dynamic (hence nomadic) clients.</p>
<p>The library is platform agnostic and works outside of MirageOS as well. It
provides two main modules:
<a href="http://haesbaert.github.io/charrua-core/api/Dhcp_wire.html">Dhcp_wire</a> and
<a href="http://haesbaert.github.io/charrua-core/api/Dhcp_server.html">Dhcp_server</a>.</p>
<h3>Dhcp_wire</h3>
<p><a href="http://haesbaert.github.io/charrua-core/api/Dhcp_wire.html">Dhcp_wire</a> provides
basic functions for dealing with the protocol, essentially
marshalling/unmarshalling and helpers for dealing with the various DHCP options.</p>
<p>The central record type of
<a href="http://haesbaert.github.io/charrua-core/api/Dhcp_wire.html">Dhcp_wire</a> is a
<a href="http://haesbaert.github.io/charrua-core/api/Dhcp_wire.html#TYPEpkt">pkt</a>, which
represents a full DHCP packet, including layer 2 and layer 3 data as well as the
many possible DHCP options. The most important functions are:</p>
<pre><code class="language-ocaml">val pkt_of_buf : Cstruct.t -&gt; int -&gt; [&gt; `Error of string | `Ok of pkt ]
val buf_of_pkt : pkt -&gt; Cstruct.t
</code></pre>
<p><a href="http://haesbaert.github.io/charrua-core/api/Dhcp_wire.html#VALpkt_of_buf">pkt_of_buf</a> takes
a <a href="https://github.com/mirage/ocaml-cstruct">Cstruct.t</a> buffer and a length and it
then attempts to build a DHCP packet. Unknown DHCP options are ignored, invalid
options or malformed data are not accepted and you get an <code> `Error of string</code>.</p>
<p><a href="http://haesbaert.github.io/charrua-core/api/Dhcp_wire.html#VALbuf_of_pkt">buf_of_pkt</a> is
the mirror function, but it never fails.  It could for instance fail in case of
two duplicate DHCP options, but that would imply too much policy in a
marshalling function.</p>
<p>The DHCP options from RFC2132 are implemented in
<a href="http://haesbaert.github.io/charrua-core/api/Dhcp_wire.html#TYPEdhcp_option">dhcp_option</a>.
There are more, but the most common ones look like this:</p>
<pre><code class="language-ocaml">type dhcp_option =
  | Subnet_mask of Ipaddr.V4.t
  | Time_offset of int32
  | Routers of Ipaddr.V4.t list
  | Time_servers of Ipaddr.V4.t list
  | Name_servers of Ipaddr.V4.t list
  | Dns_servers of Ipaddr.V4.t list
  | Log_servers of Ipaddr.V4.t list
</code></pre>
<h3>Dhcp_server</h3>
<p><a href="http://haesbaert.github.io/charrua-core/api/Dhcp_server.html">Dhcp_server</a>
Provides a library for building a DHCP server and is divided into two sub-modules:
<a href="http://haesbaert.github.io/charrua-core/api/Dhcp_server.Config.html">Config</a>,
which handles the building of a suitable DHCP server configuration record and
<a href="http://haesbaert.github.io/charrua-core/api/Dhcp_server.Config.html">Input</a>,
which handles the input of DHCP packets.</p>
<p>The logic is modelled in a pure functional style and
<a href="http://haesbaert.github.io/charrua-core/api/Dhcp_server.html">Dhcp_server</a> does
not perform any IO of its own. It works by taking an input
<a href="http://haesbaert.github.io/charrua-core/api/Dhcp_wire.html#TYPEpkt">packet</a>,
a
<a href="http://haesbaert.github.io/charrua-core/api/Dhcp_server.Config.html#TYPEt">configuration</a>
and returns a possible reply to be sent by the caller, or an error/warning:</p>
<h4>Input</h4>
<pre><code class="language-ocaml">type result = 
| Silence                 (* Input packet didn't belong to us, normal nop event. *)
| Reply of Dhcp_wire.pkt  (* A reply packet to be sent on the same subnet. *)
| Warning of string       (* An odd event, could be logged. *)
| Error of string         (* Input packet is invalid, or some other error ocurred. *)

val input_pkt : Dhcp_server.Config.t -&gt; Dhcp_server.Config.subnet -&gt;
   Dhcp_wire.pkt -&gt; float -&gt; result
(** input_pkt config subnet pkt time Inputs packet pkt, the resulting action
    should be performed by the caller, normally a Reply packet is returned and
    must be sent on the same subnet. time is a float representing time as in
    Unix.time or MirageOS's Clock.time. **)
</code></pre>
<p>A typical main server loop would work by:</p>
<ol>
<li>Reading a packet from the network.
</li>
<li>Unmarshalling with <a href="http://haesbaert.github.io/charrua-core/api/Dhcp_wire.html#VALpkt_of_buf">Dhcp_wire.pkt_of_buf</a>.
</li>
<li>Inputting the result with <a href="http://haesbaert.github.io/charrua-core/api/Dhcp_server.Input.html#VALinput_pkt">Dhcp_server.Input.input_pkt</a>.
</li>
<li>Sending the reply, or logging the event from the <a href="http://haesbaert.github.io/charrua-core/api/Dhcp_server.Input.html#VALinput_pkt">Dhcp_server.Input.input_pkt</a> call.
</li>
</ol>
<p>A mainloop example can be found in
<a href="https://github.com/mirage/mirage-skeleton/blob/master/dhcp/unikernel.ml#L28">mirage-skeleton</a>:</p>
<pre><code class="language-ocaml">  let input_dhcp c net config subnet buf =
    let open Dhcp_server.Input in
    match (Dhcp_wire.pkt_of_buf buf (Cstruct.len buf)) with
    | `Error e -&gt; Lwt.return (log c (red &quot;Can't parse packet: %s&quot; e))
    | `Ok pkt -&gt;
      match (input_pkt config subnet pkt (Clock.time ())) with
      | Silence -&gt; Lwt.return_unit
      | Warning w -&gt; Lwt.return (log c (yellow &quot;%s&quot; w))
      | Error e -&gt; Lwt.return (log c (red &quot;%s&quot; e))
      | Reply reply -&gt;
        log c (blue &quot;Received packet %s&quot; (Dhcp_wire.pkt_to_string pkt));
        N.write net (Dhcp_wire.buf_of_pkt reply)
        &gt;&gt;= fun () -&gt;
        log c (blue &quot;Sent reply packet %s&quot; (Dhcp_wire.pkt_to_string reply));
        Lwt.return_unit
</code></pre>
<p>As stated,
<a href="http://haesbaert.github.io/charrua-core/api/Dhcp_server.Input.html#VALinput_pkt">Dhcp_server.Input.input_pkt</a>
does not perform any IO of its own, it only deals with the logic of analyzing a
DHCP packet and building a possible answer, which should then be sent by the
caller. This allows a design where all the side effects are controlled in one
small chunk, which makes it easier to understand the state transitions since they
are made explicit.</p>
<p>At the time of this writing,
<a href="http://haesbaert.github.io/charrua-core/api/Dhcp_server.Input.html#VALinput_pkt">Dhcp_server.Input.input_pkt</a>
is not side effect free, as it manipulates a database of leases, this will be
changed in the next version to be pure as well.</p>
<p>Storing leases in permanent storage is also unsupported at this time and
should be available soon, with Irmin and other backends. The main idea is to
always return a new lease database for each input, or maybe just the updates to
be applied, and in this scenario, the caller would be able to store the database in
permanent storage as he sees fit.</p>
<h4>Configuration</h4>
<p>This project started independently of MirageOS and at that time, the best
configuration I could think of was the well known <code>ISC</code> <code>dhcpd.conf</code>. Therefore,
the configuration uses the same format but it does not support the myriad of
options of the original one.</p>
<pre><code class="language-ocaml">  type t = {
    addresses : (Ipaddr.V4.t * Macaddr.t) list;
    subnets : subnet list;
    options : Dhcp_wire.dhcp_option list;
    hostname : string;
    default_lease_time : int32;
    max_lease_time : int32;
  }

  val parse : string -&gt; (Ipaddr.V4.Prefix.addr * Macaddr.t) list -&gt; t
  (** [parse cf l] Creates a server configuration by parsing [cf] as an ISC
      dhcpd.conf file, currently only the options at [sample/dhcpd.conf] are
      supported. [l] is a list of network addresses, each pair is the output
      address to be used for building replies and each must match a [network
      section] of [cf]. A normal usage would be a list of all interfaces
      configured in the system *)
</code></pre>
<p>Although it is a great format, it doesn't exactly play nice with MirageOS and
OCaml, since the unikernel needs to parse a string at runtime to build the
configuration, this requires a file IO backend and other complications. The
next version should provide OCaml helpers for building the configuration, which
would drop the requirements of a file IO backend and facilitate writing tests.</p>
<h3>Building a simple server</h3>
<p>The easiest way is to follow the <a href="https://github.com/mirage/mirage-skeleton/blob/master/dhcp/README.md">mirage-skeleton DHCP
README</a>.</p>
<h3>Future</h3>
<p>The next steps would be:</p>
<ul>
<li>Provide helpers for building the configuration.
</li>
<li>Expose the lease database in an immutable structure, possibly a <code>Map</code>, adding
also support/examples for <a href="https://github.com/mirage/irmin">Irmin</a>.
</li>
<li>Use <a href="https://github.com/mirage/functoria">Functoria</a> to pass down the
configuration in <a href="https://github.com/mirage/mirage-skeleton/blob/master/dhcp/README.md">mirage-skeleton</a>. Currently
it is awkward since the user has to edit <code>unikernel.ml</code> and <code>config.ml</code>, with
<a href="https://github.com/mirage/functoria">Functoria</a> we would be able to have it
much nicer and only touch <code>config.ml</code>.
</li>
<li>Convert MirageOS DHCP client code to use <a href="http://haesbaert.github.io/charrua-core/api/Dhcp_wire.html">Dhcp_wire</a>, or perhaps add a
client logic functionality to <a href="http://www.github.com/haesbaert/charrua-core">Charrua</a>.
</li>
</ul>
<h3>Finishing words</h3>
<p>This is my first real project in OCaml and I'm more or less a newcomer to
functional programming as well, my background is mostly kernel hacking as an
ex-OpenBSD developer.
I'd love to hear how people are actually using it and any problems they're
finding, so please do let me know via the
<a href="https://github.com/haesbaert/charrua-core/issues">issue tracker</a>!</p>
<p>Prior to this project I had no contact with any of the MirageOS folks, but I'm
amazed about how easy the interaction and communication with the community has been,
everyone has been incredibly friendly and supportive. I'd say MirageOS is a gold
project for anyone wanting to work with smart people and hack OCaml.</p>
<p>My many thanks to <a href="http://anil.recoil.org">Anil</a>, <a href="http://mort.io">Richard</a>, <a href="https://github.com/hannesm">Hannes</a>, <a href="https://twitter.com/amirmc">Amir</a>, Scott, Gabriel and others.
Thanks also to <a href="http://roscidus.com/blog/">Thomas</a> and <a href="https://github.com/Chris00/">Christophe</a> for comments on this post.
I also
would like to thank my <a href="https://www.genua.de">employer</a> for letting me work on this
project in our hackathons.</p>
|js};
      };
      {
        updated = {js|2015-12-17 12:00|js};
        authors =
          [
            {
              name = {js|Amir Chaudhry|js};
              uri = Some {js|http://amirchaudhry.com|js};
              email = Some {js|amirmc@gmail.com|js};
            };
          ];
        subject = {js|Unikernel.org|js};
        permalink = {js|unikernel-org|js};
        body =
          {js|<p>Unikernels are specialised single address space machine images that are
constructed by using library operating systems. With MirageOS, we've taken a
clean-slate approach to unikernels with a focus on safety. This involved
writing protocol libraries from the ground up and it also afforded the ability
to use clean, modern APIs.</p>
<p>Other unikernel implementations have made trade-offs different to those made
by MirageOS. Some excel at handling legacy applications by making the most of
existing OS codebases rather than building clean-slate implementations. Some
target a wide array of possible environments, or environments complementary to
those supported by MirageOS currently.
All of these implementations ultimately help developers construct unikernels
that match their specific needs and constraints.</p>
<p>As word about unikernels in general is spreading, more people are trying to
learn about this new approach to programming the cloud and embedded devices.
Since information is spread across multiple sites, it can be tricky to know
where to get an overview and how to get started quickly. So to help people get
on board, there's a new community website at <strong><a href="http://unikernel.org">unikernel.org</a></strong>!</p>
<p>The <a href="http://unikernel.org">unikernel.org</a> community site aims to collate information about the
various projects and provide a focal point for early adopters to understand
more about the technology and become involved in the projects themselves.</p>
<p>Over time, it will also become a gathering place for common infrastructure to
form and be shared across projects.  Early examples of this include the
scripts for booting on Amazon EC2, which began with MirageOS contributors but
were used and improved by <a href="http://rumpkernel.org">Rump Kernel</a> contributors.  You can follow the
email threads where the script was <a href="https://www.freelists.org/post/rumpkernel-users/EC2-launch-script-feedback-valued">first proposed</a> and ultimately
provided <a href="https://www.freelists.org/post/rumpkernel-users/Amazon-EC2-support-now-in-Rumprun">EC2 support for Rumprun</a>. Continuing to work together
to make such advances will ease the process of bringing in new users and
contributors across all the projects.</p>
<p>Please do visit the site and contribute stories about how you're using and
improving unikernels!</p>
<p><em>Edit: discuss this post on <a href="https://devel.unikernel.org/t/why-we-need-unikernel-org/18/1">devel.unikernel.org</a></em></p>
<p><em>Thanks to <a href="http://anil.recoil.org">Anil</a>, <a href="https://github.com/yallop">Jeremy</a> and <a href="http://somerandomidiot.com">Mindy</a> for
comments on an earlier draft.</em></p>
|js};
      };
      {
        updated = {js|2015-10-23 11:00|js};
        authors =
          [
            {
              name = {js|Amir Chaudhry|js};
              uri = Some {js|http://amirchaudhry.com|js};
              email = Some {js|amirmc@gmail.com|js};
            };
          ];
        subject = {js|Videos from around the world!|js};
        permalink = {js|videos-around-world-2015|js};
        body =
          {js|<p>Word about Unikernels and MirageOS is spreading and as the community grows,
more people have been giving talks at user groups and conferences. Below are a
selection of those that have been recorded, which alone is about 5 hours of
content.  The topics are wide ranging and include discussions about where
unikernels fit in the ecosystem, all the way down to networking topics.</p>
<p>I hope you enjoy these and if you'd like to give a talk somewhere or share
one of your videos, please do <a href="mailto:mirageos-devel@lists.xenproject.org">get in touch</a>!</p>
<h4>Videos of recent talks</h4>
<p><strong><a href="http://anil.recoil.org">Anil Madhavapeddy</a> at Esper Technologies - May 2015</strong><br />
<strong>'Unikernels: Functional Infrastructure with MirageOS'</strong></p>
<div class="flex-video">
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/bC7rTUEZfmI" frameborder="0" allowfullscreen=""></iframe>
</div>
<p><strong><a href="https://twitter.com/RCPavlicek">Russell Pavlicek</a> at SouthEast LinuxFest - June 2015</strong><br />
<strong>'Next Generation Cloud'</strong></p>
<div class="flex-video">
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/8UgiPODw3CY" frameborder="0" allowfullscreen=""></iframe>
</div>
<p><em>Russ has also been at many other Linuxfests this year!</em></p>
<p><strong><a href="http://amirchaudhry.com">Amir Chaudhry</a> at PolyConf - July 2015</strong><br />
<strong>'Unikernels!'</strong></p>
<div class="flex-video">
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/nZLy19eRWLk" frameborder="0" allowfullscreen=""></iframe>
</div>
<p>There's more information about this talk in the blog post at:
<a href="http://amirchaudhry.com/unikernels-polyconf-2015">http://amirchaudhry.com/unikernels-polyconf-2015</a></p>
<p><strong><a href="https://github.com/hannesm">Hannes Mehnert</a> at Source_Code Berlin - Aug 2015</strong><br />
<strong>'Leaving legacy behind — A clean-slate approach to operating systems'</strong></p>
<div class="flex-video">
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/PTtI8hpR7hQ" frameborder="0" allowfullscreen=""></iframe>
</div>
<p><strong><a href="https://twitter.com/sjfloat">Steve Jones</a> at DevopsDays Pittsburgh - Aug 2015</strong><br />
<strong>'The Incredible Shrinking Operating System!'</strong></p>
<div class="flex-video">
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/Ud3NGqRRGc4" frameborder="0" allowfullscreen=""></iframe>
</div>
<p><strong><a href="http://somerandomidiot.com">Mindy Preston</a> at Strangeloop - Sep 2015</strong><br />
<strong>'Non-Imperative Network Programming'</strong></p>
<div class="flex-video">
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/GNc1t6Q5Dls" frameborder="0" allowfullscreen=""></iframe>
</div>
<p>Mindy also wrote a post that has some information and links:
<a href="http://somerandomidiot.com/blog/2015/10/07/ocaml-workshop-and-strange-loop-talks">http://somerandomidiot.com/blog/2015/10/07/ocaml-workshop-and-strange-loop-talks</a></p>
<p><strong><a href="https://twitter.com/mattbajor">Matt Bajor</a> at Strangeloop - Sep 2015</strong><br />
<strong>'Look ma, no OS! Unikernels and their applications'</strong></p>
<div class="flex-video">
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/W9F4pn9Lngc" frameborder="0" allowfullscreen=""></iframe>
</div>
<p><strong><a href="https://twitter.com/garethr">Gareth Rushgrove</a> at Operability - Sep 2015</strong><br />
<strong>'Taking the Operating System out of Operations'</strong></p>
<div class="flex-video">
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/nxofKgwgjHs" frameborder="0" allowfullscreen=""></iframe>
</div>
<p><strong><a href="https://twitter.com/gar1t">Garett Smith</a> at CityCode - Oct 2015</strong><br />
<strong>'Rainbows and Unikernels'</strong></p>
<div class="flex-video">
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/cUvNths_5RA" frameborder="0" allowfullscreen=""></iframe>
</div>
|js};
      };
      {
        updated = {js|2015-10-15 19:00|js};
        authors =
          [
            {
              name = {js|Amir Chaudhry|js};
              uri = Some {js|http://amirchaudhry.com|js};
              email = Some {js|amirmc@gmail.com|js};
            };
          ];
        subject = {js|Getting Started Screencasts|js};
        permalink = {js|getting-started-screencasts|js};
        body =
          {js|<p>We put together some quick screencasts to make it easier for people to get
started with MirageOS. They're all in a playlist below, which is around 10
minutes in total.</p>
<p>There are currently 4 videos which walk through some of the typical steps.
The first three cover installation, building a 'hello world', and building a
Xen unikernel on an Ubuntu machine. The fourth video gives an overview of the
development workflows that are possible with OPAM and Git.</p>
<p>These should give everyone a clear idea of what it's like to work with the
tools before leaping in and installing things!</p>
<p>If anyone would like to help us make more of these screencasts, please do get
in touch on the <a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> — I've also listed it as one of our many
<a href="https://github.com/mirage/mirage-www/wiki/Pioneer-Projects#screencasts">Pioneer Projects</a>!</p>
<div class="flex-video">
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/videoseries?list=PLgjWYrrJw8_wlrkveCXULbg6oIYDvNuDU" frameborder="0" allowfullscreen=""></iframe>
</div>
|js};
      };
      {
        updated = {js|2015-07-22 17:00|js};
        authors =
          [
            {
              name = {js|David Kaloper|js};
              uri = Some {js|https://github.com/pqwy|js};
              email = Some {js|david.mersinjak@cl.cam.ac.uk|js};
            };
          ];
        subject = {js|Organized chaos: managing randomness|js};
        permalink = {js|mirage-entropy|js};
        body =
          {js|<p>This post gives a bit of background on the <em>Random Number Generator</em> (RNG) in
the recent MirageOS v2.5 release.</p>
<p>First we give background about why RNGs are really critical for security. Then
we try to clarify the often-confused concepts of &quot;randomness&quot; and &quot;entropy&quot;, as
used in this context. Finally, we explore the challenges of harvesting
good-quality entropy in a unikernel environment.</p>
<h3>Playing dice</h3>
<p>Security software must play dice.</p>
<p>It must do so to create secrets, for example. Secrets can then serve as the
keys that protect communication, like the Diffie-Hellman key exchanged between
two TLS endpoints. Proof of the knowledge of a particular secret can be
used to verify the identity of someone on the Internet, as in the case of
verifying the possession of the secret RSA key associated with an X.509
certificate. As an attacker guessing a secret can have disastrous consequences,
it must be chosen in a manner that is realistically unpredictable by anyone
else — we need it to be <em>random</em>.</p>
<p>There are other reasons to use randomness. A number of algorithms require a
unique value every time they are invoked and badly malfunction when this
assumption is violated, with random choice being one way to provide a value
likely to be unique. For example, repeating the <code>k</code>-<a href="https://en.wikipedia.org/wiki/Digital_Signature_Algorithm#Sensitivity">parameter</a>
in DSA digital signatures compromises the secret key, while reusing a
<a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode">GCM</a> nonce negates both confidentiality and authenticity. Other
algorithms are probabilistic, in that they generate random values before
operating on an input, and then store the chosen values in the output, such as
the <a href="https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding">OAEP</a> padding mode for RSA. This is done in order to confuse the
relationship between the input and the output and defeat a clever attacker who
tries to manipulate the input to gain knowledge about secrets by looking at the
output. Still other algorithms pick random numbers to internally change their
operation and hide the physical amount of time they need to execute, to avoid
revealing information about the secrets they operate on. This is known as
<a href="https://en.wikipedia.org/wiki/Blinding_%28cryptography%29">blinding</a>, and is one way to counter timing side-channel
attacks.</p>
<p>Randomness is therefore quite pervasive in a security context. In fact, many
cryptographic algorithms are designed under the assumption of a readily
available source of randomness, termed a <em><a href="https://en.wikipedia.org/wiki/Random_oracle">random oracle</a></em>.
The security analysis of those algorithms is conditional on the oracle; we know
that they have certain security characteristics, like the difficulty of guessing
the correct message or impersonating somebody, only given an ideal random oracle.</p>
<p>And so security software has a problem here. Computers are inherently
deterministic, made to behave reproducibly given a known program and starting
state. How to go about solving this?</p>
<h3>Random failures</h3>
<p>Before taking a look at how we try to solve this problem, let's instead consider
what happens if we <strong>fail</strong> to do so. There is even a <a href="https://en.wikipedia.org/wiki/Random_number_generator_attack">Wikipedia
page</a> about this, which is a nice starting point. Some
of the highlights:</p>
<p>The first public release of Netscape's original SSL, version 2.0, was
<a href="http://prng.net/faq/netscape-ssl/">broken</a> several months after its release. The weakness
was in initializing the RNG with the current time, the process ID and the parent
process ID of the browser. The time stamp can be guessed to a certain precision,
leaving only its sub-second part and the two PIDs unknown. This relatively small
unknown space of initial values can be brute-forced.</p>
<p>About a decade later, Debian patched their version of OpenSSL and reduced RNG
initialization to the current PID. As a result, only 32767 random sequences were
possible. This flaw went undetected for two years and became known as the
<a href="http://research.swtch.com/openssl">Debian fiasco</a>. Personal reports indicate that some of the 32767
distinct secret keys that could be generated with OpenSSL on a Debian system
during that time are still in circulation.</p>
<p>Computing the largest common divisor of a pair of numbers is much faster than
discovering all the prime divisors of a particular number. RSA public keys
contain a number, and secret keys contain its factors. An RSA key is usually
generated by randomly picking the factors. If a pool of keys was generated with
a heavily biased random number generator, such that factors are likely to
repeat, it is possible to search for common factors in all pairs and crack the
affected keys, a technique which produces
<a href="https://eprint.iacr.org/2013/599">spectacular</a> <a href="https://factorable.net/weakkeys12.extended.pdf">results</a>.</p>
<p>Recently, a bitcoin application for Android was
<a href="https://www.reddit.com/r/Bitcoin/comments/37oxow/the_security_issue_of_blockchaininfos_android/">discovered</a> to be downloading its random initial value from a
<a href="http://www.random.org">website</a>. It wasn't even necessary to intercept this
unencrypted traffic, because the website started serving a redirect page and the
Android application was left initializing its RNG with the text of the redirection
message. It therefore started
generating the same private ECDSA key and the associated bitcoin address for
every affected user, an issue which reportedly <a href="http://www.theregister.co.uk/2015/06/01/blockchain_app_shows_how_not_to_code/">cost</a> some users
their bitcoins.</p>
<p>Playstation 3 game signatures can be forged. Sony <a href="https://www.schneier.com/blog/archives/2011/01/sony_ps3_securi.html">reused</a> a
single <code>k</code>-parameter, which is supposed to be &quot;unique, unpredictable and
secret&quot;, for every ECDSA signature they made. This lead to complete compromise
of the signing keys. Admittedly, this is not really an RNG
problem in itself, but it shows where such a malfunction can lead.</p>
<p>These are only some of the most spectacular failures related to random numbers.
For example, it is widely known in security circles that RNGs of embedded
devices tend to be predictable, leading to widespread use of weak keys on routers
and similar equipment, amongst other things. So when implementing a unikernel
operating system, you don't want to end up on that Wikipedia page either.</p>
<h3>Random sequences and stuff</h3>
<p>But what are random numbers, really? Intuitively, we tend to think about them as
somehow &quot;dancing around&quot;, or being &quot;jiggly&quot; in a sense. If we have a software
component that keeps producing random outputs, these outputs form a sequence,
and we hope this to be a <a href="https://en.wikipedia.org/wiki/Random_sequence">random sequence</a>.</p>
<p>But such a thing is <a href="https://xkcd.com/221">notoriously</a> <a href="http://dilbert.com/strip/2001-10-25">difficult</a> to define.
The above linked page opens with the following quote:</p>
<blockquote>
<p>A random sequence is a vague notion... in which each term is unpredictable to
the uninitiated and whose digits pass a certain number of tests traditional with
statisticians.</p>
</blockquote>
<p>The intuitive jigglyness is captured by <a href="https://en.wikipedia.org/wiki/Statistical_randomness">statistical
randomness</a>. We require each output, taken
independently, to come from the same distribution (and in fact we want it to be
the uniform distribution). That is, when we take a long sequence of outputs, we
want them to cover the entire range, we want them to cover it evenly, and we
want the evenness to increase as the number of outputs increases — which
constitutes a purely frequentist definition of randomness. In addition, we want
the absence of clear patterns between outputs. We don't want the sequence to
look like <code>7, 8, 9, 10, ...</code>, even with a bit of noise, and we
don't want correlation between outputs. The problem here is that no-one really
knows what &quot;having patterns&quot; means; it is entirely possible that we only
searched for patterns too simple, and that in fact there is a pattern that fully
explains the sequence lurking just around the complexity corner.</p>
<p>Nonetheless, there is a well established battery of tests to check statistical
randomness of RNG outputs, called the <a href="http://www.stat.fsu.edu/pub/diehard/">Diehard Tests</a>, and serves
as the de-facto standard for testing random number generators. Here's the
beginning of a certain sequence that <a href="http://interstat.statjournals.net/YEAR/2005/articles/0510005.pdf">passes</a> the test
with flying colors:</p>
<p><code>3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3, 2, 3, 8, 4, 6, 2, 6, 4, 3, 3, 8, 3, ...</code></p>
<p>We still would not recommend using digits of <code>π</code> as a secret key.
Neither would we recommend
releasing software for everyone to study, which uses that sequence to generate
the secrets. But what went wrong?</p>
<p>The other <a href="https://en.wikipedia.org/wiki/Algorithmically_random_sequence">concept of randomness</a>. Roughly, a
random sequence should not be predictable to anyone with any knowledge other
than the sequence itself. In other words, it cannot be compressed no matter how
much we try, and in the extreme, this means that it cannot be generated by a
program. While the latter restriction is obviously a little too strong for our
purpose, it highlights a deep distinction in what people mean by being
&quot;random&quot;.
Jumping around is one thing. Being <em>actually unpredictable</em> is a
wholly different matter.</p>
<p>There are many other <a href="http://mathworld.wolfram.com/Rule30.html">simple</a> mathematical processes which
generate sequences with high statistical randomness. Many of those are used to
produce &quot;random&quot; sequences for various purposes. But these are still completely
deterministic processes that exhibit random behaviour only in the statistical
sense. Instead of being <em>random</em>, they are <em>pseudo-random</em>, and we call such
generators <em>Pseudo-Random Number Generators</em> (PRNGs).</p>
<p>We can look for something approaching a &quot;true&quot; random sequence in nature.
The current agreement is that the nature of quantum processes is random in this
sense, and random sequences based on this idea are readily available for
<a href="http://qrbg.irb.hr/">download</a>. Or we can use the microphone and keep recording; the
lowest-order bits of the signal are pretty unpredictable. But we cannot write a
program to generate an actually random sequence.</p>
<p>Still, we need to compromise. The real problem of common PRNGs is that knowing
the rule and observing some of the outputs is enough to predict the rest of the
sequence. The entire future behavior of <a href="https://en.wikipedia.org/wiki/Mersenne_Twister">Mersenne twister</a>,
one of the most commonly used generators in various programming packages, can be
predicted after observing only 624 outputs in a row. A step up from such a
process is a <em>Cryptographically Secure Pseudo-Random Number Generator</em> (CSPRNG).
Their key property is that it is computationally prohibitively expensive to
distinguish their outputs from a &quot;true&quot; random sequence. This also means that it
is computationally prohibitively expensive to reconstruct their internal state,
just by looking at their outputs. In a sense, someone trying to predict the
outputs can not take shortcuts, and is instead forced to perform the laborious
task of starting the generator with all the possible states and checking if the
output matches the observed sequence. This is how we can quantify a CSPRNG
unpredictability: it takes trying about half of all the possibilities to guess
the state.</p>
<p>MirageOS' security stack contains a CSPRNG, a design called <a href="https://www.schneier.com/fortuna.html">Fortuna</a>.
What it really does, is encrypt the simple sequence <code>0, 1, 2, 3, ...</code> with AES
(AES-CTR) using a secret key. This makes it as resistant to prediction as AES is
to <a href="https://en.wikipedia.org/wiki/Known-plaintext_attack">known-plaintext attacks</a>. After each output, it
generates a bit more, hashes that, and uses the result as the next key. This is
not to improve the statistical randomness, as it is already guaranteed by AES.
Rather, it's a form of <a href="https://en.wikipedia.org/wiki/Forward_secrecy">forward secrecy</a>: an attacker who
learns the secret key at some point would need to perform the <a href="https://en.wikipedia.org/wiki/Preimage_attack">preimage
attack</a> on the hash function to figure out the earlier key
and reconstruct the earlier outputs.</p>
<h3>Entropy</h3>
<p>Although resistant to prediction based solely on the outputs, just like any
other software RNG, Fortuna is still just a deterministic PRNG. Its entire
output is as unpredictable as its initial value, which we call the <em>seed</em>. From
the information perspective, a PRNG can only transform what was unpredictable
about its initial seed into an equally unpredictable sequence. In other words,
we typically use PRNGs to stretch the unpredictability inherent in the initial
seed into an infinite stream. The best PRNGs do not give out more hints about
their starting position, but they can never out-race the amount of
unpredictability that they started with.</p>
<p>We often call this quality of unpredictability <em>entropy</em>. In a sense, by
employing an algorithmic generator, we have just shifted the burden of being
unpredictable to the beginning. But now we're cornered and have to search for entropy in
the only place where a computer can find it: in the physical world.</p>
<p>A typical (kernel-level) RNG-system reaches out into the world around it through
hardware interaction: as hardware events happen, various drivers tend to emit
small packets of data, such as the time, or hardware-specific state. These
events are a product of the user interactions with the keyboard and mouse, of
network packets arriving at an interface, of the hard drive asserting interrupts
to signal the end of a DMA transfer, and the like. They are combined together
and used to seed the internal (CS-)PRNG.</p>
<p>In fact, describing them as a <em>seed</em> from which the entire sequence is unfolded
is a deliberate oversimplification: what really happens is that the PRNG is
continuously fed with random events, which change its state as they arrive, and
the requests for random bytes are served from the PRNG. The PRNG is used to
&quot;mix&quot; the unpredictability inherent in its input, that is, to smooth out various
timestamps and similar values into a statistically well-behaved sequence.</p>
<h3>Do Virtual Machines Dream of Electric Sheep?</h3>
<p>Our problem here is that a virtual machine (VM) in a typical configuration
barely sees any physical hardware. Users do not interact with VMs in server
scenarios using a directly-connected keyboard and mouse. VMs make use of a
virtualized network interface and virtualized disks. Even the CPU features can
be intercepted and virtualized. Virtual environments are entropy-starved.</p>
<p>This is a known problem and <a href="http://www.cs.berkeley.edu/~cthompson/papers/vmm-entropy-report-2011.pdf">various</a>
<a href="http://www.ieee-security.org/TC/SP2014/papers/Not-So-RandomNumbersinVirtualizedLinuxandtheWhirlwindRNG.pdf">analyses</a> of the weakness of random outputs in virtual
environments have been published. The problem is especially severe right after
boot. The gradual trickle of unpredictability from hardware events slowly moves
the pseudo-random stream into an increasingly unpredictable state,
but at the very start, it still
tends to be fairly predictable. Typically, operating systems store some of their
PRNG output on shutdown and use it to quickly reseed their PRNG on the next
boot, in order to reuse whatever entropy was contained in its state.
Unfortunately, it is common to boot several machines from the same system image,
or from a pristine image lacking a seed, making random outputs in a virtual
machine vulnerable to prediction close to the startup phase.</p>
<p>To help solve these problems, we employ several sources of entropy in MirageOS
unikernels. The case of a Unix executable is simple, as we reuse the system's
own RNG, as exposed via <code>/dev/urandom</code>, as the source of our entropy. This is
because the kernel is in a much better position to enter an unpredictable state
than any single process running under its supervision. The case of Xen
unikernels is harder. Here, we group the entropy sources into those that
originate within the unikernel itself, and those that originate externally.</p>
<p>In the external case, we again rely on the kernel interacting with the hardware,
but this time it's the dom0 kernel. We have a background service,
<a href="https://github.com/mirage/xentropyd">Xentropyd</a>, which runs in dom0, reads the RNG and serves its output
to other domains through the Xen Console. The problem is that in many scenarios,
like hosting on popular cloud providers, we cannot expect this degree of cooperation from
dom0. A bigger problem is that although most of the code is present, we haven't
fully fleshed out this design and it remains disabled in MirageOS 2.5.0</p>
<p>So we need to be able to achieve unpredictability relying purely on what is
available inside a unikernel. A unikernel has no direct exposure to the
hardware, but it is of course interacting with the outside world. To tap into
this ambient entropy, we have to continuously sample all inter-event timings
in its event loop. This process is analogous to what happens in a full-blown OS
kernel, except our events lack the extra hardware context, and our timers are
potentially less granular (for example, on ARM). This makes our
interaction-based events somewhat more predictable, or in other words, they have
a little less entropy.</p>
<p>Recent Intel chips come with an on-die random generator, which ultimately
derives from thermal readings, and is available through <code>RDRAND</code> and (more
directly) <code>RDSEED</code> instructions. The community has expressed concern that
relying exclusively on this generator might not be a wise choice: it could
silently malfunction, and its design is hidden in the hardware, which raises
concerns about potential intentional biases in the output — a scheme not
<a href="https://en.wikipedia.org/wiki/Dual_EC_DRBG">unheard of</a>. However, since entropy is additive, its output can never
reduce whatever unpredictability the system already has. Therefore, if
available, we continuously sample this on-die RNG, and inject its outputs into
our PRNG.</p>
<p>The combination of event timings and a built-in RNG does have good unpredictability
in the long run, especially if our unikernel is running on a multi-tenant host
and competing for CPU with other instances. But the entropy in each individual
event is still relatively low: we can assume that a determined attacker can
guess each individual time stamp up to a certain precision that we don't know,
but which is potentially quite high. This creates the following problem: imagine
that an attacker knows the current PRNG state, and can measure the time of the
next event, but not with sufficient precision to know the last two bits of the
timestamp. To this attacker, our event contains two bits of entropy.
If we immediately update the PRNG, the attacker only has to observe
some of the output and check four candidate states against it, to fully recover
knowledge about the state and negate our entropy addition. On the other hand, if
we decide to wait and try to accumulate many more events before updating the
PRNG, we keep generating a fully predictable sequence in the meantime.</p>
<p>And here is where Fortuna really shines. It keeps accumulating events in a
number of
internal pools in a round-robin fashion. These pools are constantly being
activated, but with an exponentially decreasing frequency. The pools activated
too frequently are wasted, but one of them is activated with just the right
frequency to contain enough entropy to make it prohibitively expensive for an
attacker to enumerate all the possibilities. This design was
<a href="https://eprint.iacr.org/2014/167">shown</a> to be within a constant factor from optimal entropy
use, and in particular, scales robustly with the actual amount of entropy
inherent in the input events.</p>
<p>This leaves us with the problem of boot-time entropy. Not only can the saved
random seed be reused by cloning the disk image, but in many cases, a MirageOS
unikernel is running without such storage at all!</p>
<p>Following the design of <a href="http://www.ieee-security.org/TC/SP2014/papers/Not-So-RandomNumbersinVirtualizedLinuxandtheWhirlwindRNG.pdf">Whirlwind RNG</a>, we employ an entropy
<a href="https://github.com/mirage/mirage-entropy/blob/863b48d4e33b43ca31c49c2e8caef4e367fab7b2/lib/entropy_xen.ml#L79">bootstrapping loop</a>. It's an iterated computation, which
measures the time it took to perform the previous iteration, and then performs
the amount of work that depends on the time, many times over. In this way, it
creates a feedback loop with a fragile dependency on any non-determinism in the
physical execution on the CPU, such as any contention or races in the CPU state.
Even on ARM, which currently uses a less fine-grained timer and whose design is
not as parallel as Intel's, this yields an initial value which varies wildly
between boots. We use this value to kickstart the PRNG, giving it quick
divergence, and ensuring that the state is unpredictable from the very start.</p>
<h3>Parting words</h3>
<p>While some of our techniques (in particular bootstrapping on ARM) need a little
more exposure before we place our full confidence in them — and users should
probably avoid generating long-term private keys in unikernels running on bare
Xen just yet — the combination of boostrapping, continuous reseeding, and
robust accumulation gives us a hopefully comprehensive solution to generating
randomness in a unikernel environment.</p>
<p>We intend to re-evaluate the effectiveness of this design after getting some
experience with how it works in the wild. To this end, we particularly
appreciate the community feedback and
you can reach us through our <a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a>, or hop onto
<code>freenode</code> and join <code>#mirage</code>.</p>
<p><em>Thanks to <a href="http://erratique.ch">Daniel</a>, <a href="http://mort.io">Mort</a> and <a href="http://amirchaudhry.com">Amir</a> for their comments on earlier
drafts.</em></p>
|js};
      };
      {
        updated = {js|2015-07-07 12:00|js};
        authors =
          [
            {
              name = {js|Mindy Preston|js};
              uri = Some {js|https://github.com/yomimono|js};
              email = Some {js|mindy.preston@cl.cam.ac.uk|js};
            };
            {
              name = {js|Hannes Mehnert|js};
              uri = Some {js|https://github.com/hannesm|js};
              email = Some {js|hm519@cam.ac.uk|js};
            };
          ];
        subject = {js|Easy HTTPS Unikernels with mirage-seal|js};
        permalink = {js|mirage-seal|js};
        body =
          {js|<p>Building a static website is one of the better-supported user stories for MirageOS, but it currently results in an HTTP-only site, with no capability for TLS.  Although there's been a great TLS stack <a href="https://mirage.io/blog/introducing-ocaml-tls">available for a while now</a>, it was a bit fiddly to assemble the pieces of TLS, Cohttp, and the MirageOS frontend tool in order to construct an HTTPS unikernel.  With MirageOS 2.5, that's changed!  Let's celebrate by building an HTTPS-serving unikernel of our very own.</p>
<h2>Prerequisites</h2>
<h2>Get a Certificate</h2>
<p>To serve HTTPS, we'll need a certificate to present to clients (i.e., browsers) for authentication and establishing asymmetric encryption. For just testing things out, or when it's okay to cause a big scary warning message to appear for anyone browsing a site, we can just use a self-signed certificate.  Alternatively, the domain name registrar or hosting provider for a site will be happy to sell (or in some cases, give!) a certificate -- both options are explained in more detail below.</p>
<p>Whichever option you choose, you'll need to install <code>certify</code> to get started (assuming you'd like to avoid using <code>openssl</code>).  To do so, pin the package in opam:</p>
<pre><code>opam pin add certify https://github.com/yomimono/ocaml-certify.git
opam install certify
</code></pre>
<h3>Self-Signed</h3>
<p>It's not strictly necessary to get someone else to sign a certificate. We can create and sign our own certificates with the <code>selfsign</code> command-line tool.  The following invocation will create a secret key in <code>secrets/server.key</code> and a public certificate for the domain <code>totallyradhttpsunikernel.xyz</code> in <code>secrets/server.pem</code>.  The certificate will be valid for 365 days, so if you choose this option, it's a good idea set a calendar reminder to renew it if the service will be up for longer than that.  The key generated will be a 2048-bit RSA key, although it's possible to create certificates valid for different lengths -- check <code>selfsign --help</code> for more information.</p>
<pre><code>selfsign -c secrets/server.pem -k secrets/server.key -d 365 totallyradhttpsunikernel.example
</code></pre>
<p>We can now use this key and certificate with <code>mirage-seal</code>!  See &quot;Packaging Up an HTTPS Site with Mirage-Seal&quot; below.</p>
<h3>Signed by Someone Else</h3>
<p>Although there are many entities that can sign a certificate with different processes, most have the following in common:</p>
<ol>
<li>you generate a request to have a certificate made for a domain
</li>
<li>the signing entity requests that you prove your ownership over that domain
</li>
<li>once verified, the signing entity generates a certificate for you
</li>
</ol>
<h4>Generating a Certificate-Signing Request</h4>
<p>No matter whom we ask to sign a certificate, we'll need to generate a certificate signing request so the signer knows what to create.  The <code>csr</code> command-line tool can do this.  The line below will generate a CSR (saved as server.csr) signed with a 2048-bit RSA key (which will be saved as server.key), for the organization &quot;Rad Unikernel Construction, Ltd.&quot; and the common name &quot;totallyradhttpsunikernel.example&quot;.  For more information on <code>csr</code>, try <code>csr --help</code>.</p>
<pre><code>csr -c server.csr -k server.key totallyradhttpsunikernel.example &quot;Rad Unikernel Construction, Ltd.&quot;
</code></pre>
<p><code>csr</code> will generate a <code>server.csr</code> that contains the certificate signing request for submission elsewhere.</p>
<h5>Example: Gandi.net</h5>
<p>My domain is registered through the popular registrar Gandi.net, who happen to give a free TLS certificate for one year with domain registration, so I elected to have them sign a certificate for me (Gandi did not pay a promotional consideration for this mention).  Most of this process is managed through their web GUI and a fairly large chunk is automatically handled behind the scenes.  Here's how you can do it too:</p>
<p>Log in to the web interface available through the registrar's website.  You can start the certificate signing process from the &quot;services&quot; tab, which exposes an &quot;SSL&quot; subtab.  Click that (Gandi doesn't need to know that we intend only to support TLS, not SSL).  Hit the &quot;Get an SSL Certificate&quot; button.  Standard SSL is fine.  Even if you're entitled to a free certificate, it will appear that you need to pay here; however at checkout, the total amount due will be 0 in your preferred currency.  Ask for a single address and, if you want to pay nothing, a valid period of 1 year.</p>
<p>Copy the content of the certificate-signing request you generated earlier and paste it into the web form.  Gandi will also ask you to identify your TLS stack; unfortunately <code>ocaml-tls</code> isn't in the drop-down menu, so choose OTHER (and perhaps send them a nice note asking them to add the hottest TLS stack on the block to their list).  Click &quot;submit&quot; and click through the order form.</p>
<p>If you're buying a certificate for a domain you have registered through Gandi (via the registered account), the rest of the process is pretty automatic.  You should shortly receive an e-mail with a subject like &quot;Procedure for the validation of your Standard SSL certificate&quot;, which explains the process in more detail, but really all you need to do is wait a while (about 30 minutes, for me).  After the certificate has been generated, Gandi will notify you by e-mail, and you can download your certificate from the SSL management screen.  Click the magnifying glass next to the name of the domain for which you generated the cert to do so.</p>
<p>Once you've downloaded your certificate, you may also wish to append the <a href="https://en.wikipedia.org/wiki/Intermediate_certificate_authorities">intermediate certificates</a>.  Here's a help page on <a href="https://wiki.gandi.net/en/ssl/intermediate">gathering intermediate certificates</a>.  Equipped with the intermediate certificates, append them to the signed certificate downloaded for your site to provide a full certificate chain:</p>
<pre><code>cat signed_cert.pem intermediate_certs.pem &gt; server.pem
</code></pre>
<h5>Example: StartSSL.com</h5>
<p>Another free TLS certificate provider is <a href="https://www.startssl.com">StartSSL</a>.  During online registration, StartSSL will generate a TLS client certificate for you.  This is used for authentication of yourself towards their service.</p>
<p>You need to validate that you own the domain you want to request a certificate for.  This is done via the &quot;Validations Wizard&quot;, which lets you choose to validate a domain via &quot;Domain Name Validation&quot;.  There you enter your domain name, and receive an eMail with a token which you have to enter into the web interface.</p>
<p>Once done, run <code>csr</code> to create a key and a certificate signing request.  Go to the &quot;Certificates Wizard&quot;, select &quot;Web Server SSL/TLS Certificate&quot;, skip the generation of the private key (you already generated one with <code>csr</code>), copy and paste your certificate signing request (only the public key of that CSR is used, everything else is ignored), select a domain name, and immediately receive your certificate.</p>
<p>Make sure to also download their intermediate CA certificate, and append them:</p>
<pre><code>cat intermediate.pem cert.pem &gt; server.pem
</code></pre>
<h2>Packaging Up an HTTPS Site with Mirage-Seal</h2>
<p>Equipped with a private key and a certificate, let's make an HTTPS unikernel!  First, use <code>opam</code> to install <code>mirage-seal</code>.  If <code>opam</code> or other MirageOS tooling aren't set up yet, check out the <a href="https://mirage.io/wiki/install">instructions for getting started</a>.</p>
<pre><code>opam install mirage-seal
</code></pre>
<p><code>mirage-seal</code> has a few required arguments.</p>
<ul>
<li><code>--data</code>: one directory containing all the content that should be served by the unikernel.  Candidates for such a directory are the top-level output directory of a static site generator (such as <code>public</code> for octopress), the <code>DocumentRoot</code> of an Apache configuration, or the <code>root</code> of an nginx configuration.
</li>
<li><code>--keys</code>: one directory containing the certificate (<code>server.pem</code>) and key (<code>server.key</code>) for the site.
</li>
</ul>
<p>There are also a number of configurable parameters for IP settings.  By default, <code>mirage-seal</code> will use DHCP to configure the network at boot.  To set static IP information, use the <code>--ip</code>, <code>--nm</code>, and <code>--gw</code> arguments.</p>
<p>You'll find more thorough documentation by looking at <code>mirage-seal --help</code> or <a href="https://github.com/mirage/mirage-seal/blob/master/README.md">mirage-seal's README file</a>.</p>
<p>To build a Xen unikernel, select the Xen mode with <code>-t xen</code>.  In full, for a unikernel that will configure its network via DHCP:</p>
<pre><code>mirage-seal --data=/home/me/coolwebsite/public --keys=/home/me/coolwebsite/secrets -t xen
</code></pre>
<p><code>mirage-seal</code> will then generate a unikernel <code>mir-seal.xen</code> and a Xen configuration file <code>seal.xl</code> in the current working directory.  To boot it and open the console (on a machine running Xen), invoke <code>xl create</code> on the configuration file with the <code>-c</code> option:</p>
<pre><code>sudo xl create seal.xl -c
</code></pre>
<p>Via the console, we can see the sealed unikernel boot and obtain an IP through DHCP.  Congratulations -- you made a static site unikernel browsable over HTTPS!</p>
|js};
      };
      {
        updated = {js|2015-06-29 16:00|js};
        authors =
          [
            {
              name = {js|Hannes Mehnert|js};
              uri = Some {js|https://github.com/hannesm|js};
              email = Some {js|hm519@cam.ac.uk|js};
            };
          ];
        subject = {js|Reviewing the Bitcoin Pinata|js};
        permalink = {js|bitcoin-pinata-results|js};
        body =
          {js|<p>TL;DR: Nobody took our BTC.  Random people from the Internet even donated
into our BTC wallet.
We showed the feasibility of a
transparent self-service bounty.  In the style of Dijkstra: security
bounties can be a very effective way to show the presence of
vulnerabilities, but they are hopelessly inadequate for showing their
absence.</p>
<h4>What are you talking about?</h4>
<p>Earlier this year, we <a href="https://mirage.io/blog/announcing-bitcoin-pinata">released a Bitcoin Piñata</a>.
The <a href="http://ownme.ipredator.se">Piñata</a> was a security bounty
containing 10 BTC and it's been online since 10th February 2015.
Upon successful
mutual authentication, where the Piñata has only a single trust anchor, it sends the
private key to the Bitcoin address.</p>
<p><a href="https://github.com/mirleft/btc-pinata">It is open source</a>,
and exposes both the client and server side of
<a href="https://github.com/mirleft/ocaml-tls">ocaml-tls</a>, running as an 8.2MB
<a href="https://mirage.io">MirageOS</a> unikernel.  You can see the <a href="https://github.com/mirleft/btc-pinata/blob/master/opam-full.txt">code manifest</a> to find out which libraries are involved.  We put this online and invited people to attack it.</p>
<p>Any approach was permitted in attacking the Piñata:
the host system, the MirageOS <a href="https://github.com/mirage/mirage-tcpip">TCP/IP
stack</a>, our TLS,
X.509 and ASN.1 implementations, as well as the Piñata code.
A successful attacker could do whatever they want with the BTC, no
questions asked (though we would <a href="https://blockchain.info/address/183XuXTTgnfYfKcHbJ4sZeF46a49Fnihdh">notice the transaction</a>).</p>
<p>The exposed server could even be short-circuited to the exposed
client: you could proxy a TLS connection in which the (encrypted!)
secret was transmitted via your machine.</p>
<p>This post summarises what we've seen so far and what we've learned about attempts people have made to take the BTC.</p>
<h4>Accesses</h4>
<p>There were 50,000 unique IP addresses who accessed the website.
1000 unique IP addresses initiated more than 20,000 TLS
connections to the Piñata, trying to break it.  Cumulative numbers of
the HTTP and TLS accesses are shown in the diagram:</p>
<img src="/graphics/pinata_access.png" alt="Cumulative Piñata accesses" />
<p>There were more than 9000 failing and 12000 successful TLS sessions,
comprised of short-circuits described earlier, and our own tests.</p>
<p>No X.509 certificate was presented in 1200 of the failed TLS
connections.  Another 1000 failed due to invalid input as the first
bytes.  This includes attempts using telnet — I'm looking at you,
xx.xxx.74.126 <code>please give key</code> (on 10th February at 16:00) and
xx.xxx.166.143 <code>hi give me teh btcs</code> (on 11th February at 05:57)!</p>
<h4>We are not talking to everybody</h4>
<p>Our implementation first parses the record version of a client hello,
and if it fails, an unknown record version is reported.  This happened
in 10% of all TLS connections (including the 1000 with invalid input in the
last section).</p>
<p>Another big class, 6%, were attempted Heartbeat packets (popular due
to <a href="https://en.wikipedia.org/wiki/Heartbleed">Heartbleed</a>), which we
do not implement.</p>
<p>Recently, issues in the state machines of TLS implementations were
published in <a href="http://smacktls.com">smacktls</a> (and <a href="http://ccsinjection.lepidum.co.jp/">CCS
injection</a>).  3% of the Piñata connections
received an unexpected handshake record at some point, which the Piñata handled
correctly by shutting down the connection.</p>
<p>In 2009, the <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#Renegotiation_attack">renegotiation
attack</a>
on the TLS protocol was published, which allowed a person in the
middle to inject prefix bytes, because a renegotiated handshake was
not authenticated with data from the previous handshake.  OCaml-TLS
closes a connection if the <a href="https://tools.ietf.org/html/rfc5746">renegotiation
extension</a> is not present, which
happened in 2% of the connections.
Another 2% did not propose a ciphersuite supported by OCaml-TLS; yet
another 2% tried to talk SSL version 3 with us, which we do not
implement (for <a href="https://tools.ietf.org/html/rfc7568">good reasons</a>, such as
<a href="https://www.us-cert.gov/ncas/alerts/TA14-290A">POODLE</a>).</p>
<p>In various other (old versions of) TLS implementations, these
connections would have been successful and insecure!</p>
<h4>Attempts worth noting</h4>
<p>Interesting failures were: 31 connections which sent too many or too
few bytes, leading to parse errors.</p>
<p>TLS requires each communication partner who authenticates themselves to
present a certificate.  To prove ownership of the private key of the
certificate, a hash of the concatenated handshake records needs to be
signed and transmitted over the wire.  22 of our TLS traces had
invalid signatures.  Not verifying such signatures was the problem of Apple's famous <a href="https://www.imperialviolet.org/2014/02/22/applebug.html">goto
fail</a>.</p>
<p>Another 100 failure traces tested our X.509 validation:
The majority of these failures (58) sent us certificates which were not signed by our trust
anchor, such as <code>CN=hacker/emailAddress=hacker@hacker</code> and <code>CN=Google Internal SNAX Authority</code> and various Apple and Google IDs -- we're still trying to figure out what SNAX is, Systems Network Architecture maybe?</p>
<p>Several certificates contained invalid X.509 extensions: we require
that a server certificate does not contain the <code>BasicConstraints = true</code> extension, which marks this certificate as certificate
authority, allowing to sign other certificates.  While not explicitly
forbidden, best practices (e.g. from
<a href="https://wiki.mozilla.org/SecurityEngineering/mozpkix-testing#Behavior_Changes">Mozilla</a>)
reject them.  Any sensible systems administrator would not accept a CA
as a server certificate.</p>
<p>Several other certificates were self-signed or contained an invalid
signature: one certificate was our client certificate, but with a
different RSA public key, thus the signature on the certificate was
invalid; another one had a different RSA public key, and the signature
was zeroed out.</p>
<p>Some certificates were not of X.509 version 3, or were expired.
Several certificate chains were not pairwise signed, a <a href="https://crypto.stanford.edu/~dabo/pubs/abstracts/ssl-client-bugs.html">common attack
vector</a>.</p>
<p>Two traces contained certificate structures which our ASN.1 parser
rejected.</p>
<p>Another two connections (both initiated by ourselves) threw an
exception which lead to <a href="https://github.com/mirleft/btc-pinata/blob/master/logger.ml#L116">shutdown of the connection</a>: there
<a href="https://github.com/mirleft/ocaml-tls/commit/80117871679d57dde8c8e3b73392024ef4b42c38">was</a>
an out-of-bounds access while parsing handshake records.  This did not
lead to arbitrary code execution.</p>
<h4>Conclusion</h4>
<p>The BTC Piñata was the first transparent self-service bounty, and it
was a success: people showed interest in the topic; some even donated
BTC; we enjoyed setting it up and running it; we fixed a non-critical
out of bounds access in our implementation; a large fraction of our
stack has been covered by the recorded traces.</p>
<p>There are several points to improve a future Piñata: attestation that the code
running is the open sourced code, attestation that the service owns
the private key (maybe by doing transactions or signatures with input
from any user).</p>
<p>There are several applications using OCaml-TLS, using MirageOS as well
as Unix:</p>
<ul>
<li><a href="https://github.com/mirage/mirage-seal">mirage-seal</a> compiles to
a unikernel container which serves a given directory over https;
</li>
<li><a href="https://github.com/hannesm/tlstunnel">tlstunnel</a> is a
(<a href="https://github.com/bumptech/stud">stud</a> like) TLS proxy, forwarding
to a backend server;
</li>
<li><a href="https://github.com/hannesm/jackline">jackline</a> is a
(alpha version) terminal-based XMPP client;
</li>
<li><a href="https://github.com/mirage/ocaml-conduit">conduit</a> is an abstraction
over network connections -- to make it use OCaml-TLS, set
<code>CONDUIT_TLS=native</code>.
</li>
</ul>
<p>Again, a big thank you to <a href="https://ipredator.se">IPredator</a> for
hosting our BTC Piñata and lending us the BTC!</p>
|js};
      };
      {
        updated = {js|2015-06-26 16:00|js};
        authors =
          [
            {
              name = {js|Amir Chaudhry|js};
              uri = Some {js|http://amirchaudhry.com|js};
              email = Some {js|amirmc@gmail.com|js};
            };
            {
              name = {js|Thomas Gazagnaire|js};
              uri = Some {js|http://gazagnaire.org|js};
              email = Some {js|thomas@gazagnaire.org|js};
            };
          ];
        subject = {js|MirageOS v2.5 with full TLS support|js};
        permalink = {js|announcing-mirage-25-release|js};
        body =
          {js|<p>Today we're announcing the new release of MirageOS v2.5, which includes
first-class support for SSL/TLS in the MirageOS configuration language. We
introduced the pure OCaml implementation of
<a href="/blog/introducing-ocaml-tls">transport layer security (TLS)</a> last summer and have been working since
then to improve the integration and create a robust framework.  The recent
releases allow developers to easily build and deploy secure unikernel services
and we've also incorporated numerous bug-fixes and major stability
improvements (especially in the network stack).  The full list of changes is
available on the <a href="/releases">releases</a> page and the <a href="/wiki/breaking-changes">breaking API changes</a>
now have their own page.</p>
<p>Over the coming week, we'll share more about the TLS stack by diving into the
results of the <a href="/blog/announcing-bitcoin-pinata">Bitcoin Piñata</a>, describing a new workflow for
building secure static sites, and discussing insights on entropy in
virtualised environments.</p>
<p>In the rest of this post, we'll cover why OCaml-TLS matters (and link to some
tools), mention our new domain name, and mention our security advisory
process.</p>
<h3>Why OCaml-TLS matters</h3>
<p>The last year has seen a slew of security flaws, which are even reaching the
mainstream news.  This history of flaws are often the result of implementation
errors and stem from the underlying challenges of interpreting ambiguous
specifications, the complexities of large APIs and code bases, and the use of
unsafe programming practices.  Re-engineering security-critical software
allows the opportunity to use modern approaches to prevent these recurring
issues. In a <a href="/blog/why-ocaml-tls">separate post</a>, we cover some of the benefits of
re-engineering TLS in OCaml.</p>
<h4>TLS Unix Tools</h4>
<p>To make it even easier to start benefiting from OCaml-TLS, we've also made a
collection of <a href="/wiki/tls-unix">TLS unix tools</a>.  These are designed to make it
really easy to use a good portion of the stack without having to use Xen. For
example, Unix <code>tlstunnel</code> is being used on <a href="https://realworldocaml.org">https://realworldocaml.org</a>. If
you have <code>stunnel</code> or <code>stud</code> in use somewhere, then replacing it with the
<code>tlstunnel</code> binary is an easy way to try things out.  Please do give this a go
and send us feedback!</p>
<h3>openmirage.org -&gt; mirage.io</h3>
<p>We've also switched our domain over to <strong><a href="https://mirage.io">https://mirage.io</a></strong>, which is a
unikernel running the full stack. We've been discussing this transition for a
while on our <a href="/wiki/#Weekly-calls-and-release-notes">fortnightly calls</a> and have actually been running this
unikernel in parallel for a while. Setting things up this way has allowed us
to stress test things in the wild and we've made big improvements to the
networking stack as a result.</p>
<p>We now have end-to-end deployments for our secure-site unikernels, which is
largely automated -- going from <code>git push</code> all the way to live site. You can
get an idea of the workflows we have set up by looking over the following
links:</p>
<ul>
<li><a href="http://amirchaudhry.com/heroku-for-unikernels-pt1">Automated unikernel deployment</a> -- Description of the end-to-end flow for one of our sites.
</li>
<li><a href="https://github.com/mirage/mirage-www-deployment">mirage-www-deployment repo</a> -- The repo from which we pull the site you're currently reading! You might find the scripts useful.
</li>
</ul>
<h3>Security disclosure process</h3>
<p>Since we're incorporating more security features, it's important to consider
the process of disclosing issues to us.  Many bugs can be reported as usual on
our <a href="https://github.com/mirage/mirage/issues">issue tracker</a> but if you think you've discovered a
<strong>security vulnerability</strong>, the best way to inform us is described on a new
page at <strong><a href="https://mirage.io/security">https://mirage.io/security</a></strong>.</p>
<h3>Get started!</h3>
<p>As usual, MirageOS v2.5 and the its ever-growing collection of
libraries is packaged with the <a href="https://opam.ocaml.org">OPAM</a> package
manager, so look over the <a href="/wiki/install">installation instructions</a>
and run <code>opam install mirage</code> to get the command-line
tool. To update from a previously installed version of MirageOS,
simply use the normal workflow to upgrade your packages by using <code>opam update -u</code> (you should do this regularly to benefit from ongoing fixes).
If you're looking for inspiration, you can check out the examples on
<a href="https://github.com/mirage/mirage-skeleton">mirage-skeleton</a> or ask on the <a href="/community">mailing list</a>. Please do be aware
that existing <code>config.ml</code> files using
the <code>conduit</code> and <code>http</code> constructors might need to be updated -- we've made a
page of <a href="/wiki/breaking-changes">backward incompatible changes</a> to explain what you need to
do.</p>
<p>We would love to hear your feedback on this release, either on our
<a href="https://github.com/mirage/mirage/issues">issue tracker</a> or <a href="/community">our mailing lists</a>!</p>
|js};
      };
      {
        updated = {js|2015-06-26 14:00|js};
        authors =
          [
            {
              name = {js|Amir Chaudhry|js};
              uri = Some {js|http://amirchaudhry.com|js};
              email = Some {js|amirmc@gmail.com|js};
            };
          ];
        subject = {js|Why OCaml-TLS?|js};
        permalink = {js|why-ocaml-tls|js};
        body =
          {js|<p>TLS implementations have a history of security flaws, which are often the
result of implementation errors.  These security flaws stem from the
underlying challenges of interpreting ambiguous specifications, the
complexities of large APIs and code bases, and the use of unsafe programming
practices.</p>
<p>Re-engineering security-critical software allows the opportunity to use modern
approaches to prevent these recurring issues. Creating <a href="https://github.com/mirleft/ocaml-tls">the TLS stack in OCaml</a>
offers a range of benefits, including:</p>
<p><strong>Robust memory safety</strong>: Lack of memory safety was the largest single source
of vulnerabilities in various TLS stacks throughout 2014, including
<a href="http://heartbleed.com">Heartbleed (CVE-2014-0160)</a>. OCaml-TLS avoids this
class of issues entirely due to OCaml's automatic memory management, safety
guarantees and the use of a pure-functional programming style.</p>
<p><strong>Improved certificate validation</strong>: Implementation errors in other stacks
allowed validation to be skipped under certain conditions, leaving users
exposed (e.g.
<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0092">CVE-2014-0092</a>).
In our TLS stack, we return errors explicitly as values and handle all
possible variants. The OCaml toolchain and compile-time checks ensure that
this has taken place.</p>
<p><strong>Mitigation of state machine errors</strong>: Errors such as
<a href="https://gotofail.com">Apple's GoTo Fail (CVE-2014-1266)</a> involved code being
skipped and a default 'success' value being returned, even though signatures
were never verified. Our approach encodes the state machine explicitly, while
state transitions default to failure. The code structure also makes clear the
need to consider preconditions.</p>
<p><strong>Elimination of downgrade attacks</strong>: Legacy requirements forced other TLS
stacks to incorporate weaker 'EXPORT' encryption ciphers. Despite the
environment changing, this code still exists and leads to attacks such as
<a href="https://freakattack.com">FREAK (CVE-2015-0204)</a> and
<a href="https://weakdh.org">Logjam (CVE-2015-4000)</a>. Our TLS server does not support
weaker EXPORT cipher suites so was never vulnerable to such attacks.
In addition our stack never supported SSLv3, which was known to be the cause of many vulnerabilities and is only now in the process of being deprecated (<a href="https://tools.ietf.org/html/rfc7568">RFC: 7568</a>).</p>
<p><strong>Greatly reduced TCB</strong>: The size of the trusted computing base (TCB) of a
system, measured in lines of code, is a widely accepted approximation of the
size of its attack surface.  Our secure Bitcoin Piñata, a unikernel built
using our TLS stack, is less than 4% the size of an equivalent, traditional
stack (102 kloc as opposed to 2560 kloc).</p>
<p>These are just some of the benefits of re-engineering critical software using
modern techniques.</p>
|js};
      };
      {
        updated = {js|2015-02-10 16:00|js};
        authors =
          [
            {
              name = {js|Amir Chaudhry|js};
              uri = Some {js|http://amirchaudhry.com|js};
              email = Some {js|amirmc@gmail.com|js};
            };
          ];
        subject = {js|Smash the Bitcoin Pinata for fun and profit!|js};
        permalink = {js|announcing-bitcoin-pinata|js};
        body =
          {js|<p><a href="http://ownme.ipredator.se/"><img src="http://amirchaudhry.com/images/btc-pinata/btc-pinata.png" style="float:right; padding: 10px" width="300px" /></a></p>
<p>Last summer we announced the beta release of a clean-slate implementation of
TLS in pure OCaml, alongside a <a href="https://mirage.io/blog/introducing-ocaml-tls">series of blog posts</a> that described
the libraries and the thinking behind them.  It took two hackers six months
— starting on <a href="https://goo.gl/maps/GpcQs">the beach</a> —  to get the stack to that point and
their <a href="https://tls.nqsb.io">demo server</a> is still going strong. Since then, the team has
continued working and recently <a href="http://media.ccc.de/browse/congress/2014/31c3_-_6443_-_en_-_saal_2_-_201412271245_-_trustworthy_secure_modular_operating_system_engineering_-_hannes_-_david_kaloper.html#video">presented</a> at the 31st Chaos
Communication Congress.</p>
<p>The authors are putting their stack to the test again and this time they've
built a <strong><a href="http://ownme.ipredator.se">Bitcoin Piñata</a></strong>! Essentially, they've hidden a
private key to a bitcoin address within a Unikernel running on Xen. If you're
able to smash your way in, then you get to keep the spoils.</p>
<p>There's more context around this in my <a href="http://amirchaudhry.com/bitcoin-pinata">Piñata post</a> and you can see
the details on the <a href="http://ownme.ipredator.se">site itself</a>. Remember that the codebase is
<a href="https://github.com/mirleft/">all open</a> (as well as <a href="https://github.com/mirleft/ocaml-tls/issues?q=label%3A%22security+concern%22+">issues</a>) so there's nothing to
reverse engineer. Have fun!</p>
|js};
      };
      {
        updated = {js|2014-12-31 16:00|js};
        authors =
          [
            {
              name = {js|Anil Madhavapeddy|js};
              uri = Some {js|http://anil.recoil.org|js};
              email = Some {js|anil@recoil.org|js};
            };
          ];
        subject =
          {js|MirageOS 2014 review: IPv6, TLS, Irmin, Jitsu and community growth|js};
        permalink = {js|2014-in-review|js};
        body =
          {js|<small>
  This work funded in part by the EU FP7 User-Centric Networking project, Grant
  No. 611001.
</small>
<p>An action-packed year has flown by for MirageOS, and it's time for a little recap of what's been happening and the plans for the new year.
We announced <a href="https://mirage.io/blog/announcing-mirage10">MirageOS 1.0</a> just over a year ago, and 2014 also saw a major <a href="https://mirage.io/blog/announcing-mirage-20-release">2.0 summer release</a> and the growth of a developer community that have been building support for IPv6, Transport Layer Security, on-demand spawning, profiling and much more.  There have been 205 individual library <a href="https://mirage.io/releases">releases</a>, 25 <a href="http://decks.openmirage.org">presentations</a>, and lots of <a href="https://mirage.io/links">online chatter</a> through the year, so here follows a summary of our major activities recently.</p>
<h3>Clean-Slate Transport Layer Security</h3>
<p><a href="http://media.ccc.de/browse/congress/2014/31c3_-_6443_-_en_-_saal_2_-_201412271245_-_trustworthy_secure_modular_operating_system_engineering_-_hannes_-_david_kaloper.html#video"><img src="/graphics/tls-31c3.png" style="float:right; padding: 5px" width="300px" /></a></p>
<p>David Kaloper and Hannes Mehnert started 2014 with getting interested in writing a <a href="https://ocaml.org/meetings/ocaml/2014/ocaml2014_4.pdf">safer and cleaner TLS stack</a> in OCaml, and ended the year with a complete demonstration and talk last week in <a href="http://media.ccc.de/browse/congress/2014/31c3_-_6443_-_en_-_saal_2_-_201412271245_-_trustworthy_secure_modular_operating_system_engineering_-_hannes_-_david_kaloper.html#video">31C3</a>, the premier hacker conference!  Their blog posts over the summer remain an excellent introduction to the new stack:</p>
<ul>
<li><em>&quot;<a href="https://mirage.io/blog/introducing-ocaml-tls">OCaml-TLS: Introducing transport layer security (TLS) in pure OCaml</a>&quot;</em> presents the motivation and architecture behind our clean-slate implementation of the protocol.
</li>
<li><em>&quot;<a href="https://mirage.io/blog/introducing-nocrypto">OCaml-TLS: building the nocrypto library core</a>&quot;</em> talks about the cryptographic primitives that form the heart of TLS confidentiality guarantees, and how they expose safe interfaces to the rest of the stack.
</li>
<li><em>&quot;<a href="https://mirage.io/blog/introducing-x509">OCaml-TLS: adventures in X.509 certificate parsing and validation</a>&quot;</em> explains how authentication and chain-of-trust verification is implemented in our stack.
</li>
<li><em>&quot;<a href="https://mirage.io/blog/introducing-asn1">OCaml-TLS: ASN.1 and notation embedding</a>&quot;</em> introduces the libraries needed for handling ASN.1 grammars, the wire representation of messages in TLS.
</li>
<li><em>&quot;<a href="https://mirage.io/blog/ocaml-tls-api-internals-attacks-mitigation">OCaml-TLS: the protocol implementation and mitigations to known attacks</a>&quot;</em> concludes with the implementation of the core TLS protocol logic itself.
</li>
</ul>
<p>By summer, the stack was complete enough to connect to the majority of TLS 1.0+ sites on the Internet, and work progressed to integration with the remainder of the MirageOS libraries.  By November, the <a href="https://github.com/mirage/ocaml-conduit">Conduit</a> network library had Unix support for both the <a href="https://github.com/savonet/ocaml-ssl">OpenSSL/Lwt</a> bindings and the pure OCaml stack, with the ability to dynamically select them.  You can now deploy and test the pure OCaml TLS stack on a webserver simply by:</p>
<pre><code>opam install lwt tls cohttp
export CONDUIT_TLS=native
cohttp-server-lwt -c &lt;certfile&gt; -p &lt;port&gt; &lt;directory&gt;
</code></pre>
<p>This will spin up an HTTPS server that serves the contents of <code>&lt;directory&gt;</code> to you over TLS.
At the same time, we were also working on integrating the TLS stack into the Xen unikernel backend, so we could run completely standalone.  This required some surgery:</p>
<ul>
<li>The <a href="https://github.com/mirleft/ocaml-nocrypto">nocrypto</a> crypto core is written in C, so we had to improve support for linking in external C libraries.  Since the Xen unikernel is a single address-space custom kernel, we also need to be careful to compile it with the correct compilation flags or else risk <a href="https://github.com/mirage/mirage-tcpip/issues/80">subtle bugs</a>. Thomas Leonard completely rearranged the MirageOS compilation pipeline to support <a href="https://github.com/mirage/mirage/pull/332">separation compilation of C stubs</a>, and we had the opportunity to remove lots of duplicated code within <a href="https://github.com/mirage/mirage-platform">mirage-platform</a> as a result of this work.
</li>
<li>Meanwhile, the problem of gathering entropy in a virtual machine reared its head.  We created a <a href="https://github.com/mirage/mirage-entropy">mirage-entropy</a> device driver, and an <a href="http://lists.xenproject.org/archives/html/mirageos-devel/2014-11/msg00146.html">active discussion</a> ensued about how best to gather reliable randomness from Xen.  <a href="http://dave.recoil.org">Dave Scott</a> built the best solution -- the <a href="https://github.com/mirage/xentropyd">xenentropyd</a> that proxies entropy from dom0 to a unikernel VM.
</li>
<li>David Kaloper also ported the <code>nocrypto</code> library to use the <a href="https://github.com/ocamllabs/ocaml-ctypes">OCaml-Ctypes</a> library, which increases the safety of the C bindings significantly.  This is described in more detail in the &quot;<a href="https://mirage.io/blog/modular-foreign-function-bindings">Modular foreign function bindings</a>&quot; blog post from the summer.  This forms the basis for allowing Xen unikernels to communicate with C code, and integration with the MirageOS toolchain will continue to improve next year.
</li>
</ul>
<p>You can see <a href="http://media.ccc.de/browse/congress/2014/31c3_-_6443_-_en_-_saal_2_-_201412271245_-_trustworthy_secure_modular_operating_system_engineering_-_hannes_-_david_kaloper.html#video">Hannes and David present OCaml-TLS</a> at CCC online.  It's been a real pleasure watching their work develop in the last 12 months with such precision and attention to detail!</p>
<h3>HTTP and JavaScript</h3>
<p><a href="http://rgrinberg.com/">Rudi Grinberg</a> got sufficiently irked with the poor state of documentation for the <a href="https://github.com/mirage/ocaml-cohttp">CoHTTP</a> library that he began gently contributing fixes towards the end of 2013, and rapidly became one of the maintainers.  He also began improving the ecosystem around the web stack by building a HTTP routing layer, described in his blog posts:</p>
<ul>
<li><em><a href="http://rgrinberg.com/blog/2014/12/13/primitive-type-safe-routing/">Type Safe Routing - Baby Steps</a></em>: type-safe routing of URLs to avoid dangling links
</li>
<li><em><a href="http://rgrinberg.com/blog/2014/04/04/introducing-opium/">Introducing Opium</a></em>: middleware for REST services
</li>
<li><em><a href="http://rgrinberg.com/blog/2014/04/11/middleware-intro/">Middleware in Opium</a></em>: a walkthrough the Opium HTTP middleware model
</li>
<li><em><a href="http://rgrinberg.com/blog/2014/05/23/humane-re-intro/">Introducing Humane-Re</a></em>: more friendly regular expression interfaces
</li>
</ul>
<p>Meanwhile, <a href="http://www.ujamjar.com/">Andy Ray</a> started developing <a href="http://www.ujamjar.com/hardcaml/">HardCaml</a> (a register transfer level hardware design system) in OCaml, and built the <a href="https://andrewray.github.io/iocamljs/">iocamljs</a> interactive browser notebook.  This uses <a href="http://ocsigen.org/js_of_ocaml">js_of_ocaml</a> to port the <em>entire</em> OCaml compilation toolstack to JavaScript, including <code>ocamlfind</code>, Lwt threading and dynamic loading support.  The results are browsable <a href="https://andrewray.github.io/iocamljs/">online</a>, and it is now easy to generate a JavaScript-driven interactive page for many MirageOS libraries.</p>
<p>An interesting side effect of Andy's patches were the addition of a <a href="https://github.com/mirage/ocaml-cohttp/pull/172">JavaScript port</a> to the CoHTTP library.  For those not familiar with the innards, CoHTTP uses the <a href="https://realworldocaml.org/v1/en/html/functors.html">OCaml module system</a> to build a very portable HTTP implementation that can make mapped to different I/O models (Lwt or Async cooperative threading or POSIX blocking I/O), and to different operating systems (e.g. Unix or MirageOS).  The JavaScript support mapped the high-level modules in CoHTTP to the XMLHTTPRequest native to JavaScript, allowing the same OCaml HTTP client code to run efficiently on Unix, Windows and now an IOCamlJS browser instance.</p>
<p>MirageOS uses a number of libraries developed by the <a href="http://ocsigen.org">Ocsigen</a> team at <a href="http://irill.org">IRILL</a> in Paris, and so I was thrilled to <a href="https://www.irill.org/videos/oups-december-2014/MirageOS">deliver a talk</a> there in December.  Romain Calascibetta started integrating Ocsigen and MirageOS over the summer, and the inevitable plotting over beer in Paris lead <a href="https://github.com/Drup">Gabriel Radanne</a> to kick off an effort to integrate the complete Ocsigen web stack into MirageOS. Head to <a href="https://github.com/ocsigen/ocsigenserver/issues/54">ocsigen/ocsigenserver#54</a> if you're interested in seeing this happen in 2015!
I also expect the JavaScript and MirageOS integration to continue to improve in 2015, thanks to large industrial users such as <a href="https://github.com/facebook">Facebook</a> adopting <code>js_of_ocaml</code> in their open-source tools such as <a href="https://github.com/facebook/hack">Hack</a> and <a href="https://github.com/facebook/flow">Flow</a>.</p>
<h3>IPv6</h3>
<p>We've wanted IPv6 support in MirageOS since its inception, and several people contributed to making this possible.  At the start of the year, <a href="https://github.com/hhugo">Hugo Heuzard</a> and <a href="https://github.com/dsheets">David Sheets</a> got <a href="https://github.com/mirage/ocaml-ipaddr/pull/9">IPv6 parsing support</a> into the <code>ipaddr</code> library (with me watching bemusedly at how insanely complex parsing is versus IPv4).</p>
<p>Meanwhile, <a href="https://www.dpmms.cam.ac.uk/~no263/">Nicolas Ojeda Bar</a> had been building OCaml networking libraries independently for some time, such as a <a href="https://github.com/nojb/ocaml-imap">IMAP client</a>, <a href="https://github.com/nojb/ocaml-maildir">Maildir</a> handler, and a <a href="https://github.com/nojb/ocaml-bt">Bittorrent</a> client.  He became interested in the networking layer of MirageOS, and performed a <a href="https://github.com/mirage/mirage-tcpip/pull/70">comprehensive cleanup</a>  that resulted in a more modular stack that now supports both IPv4 and IPv6!</p>
<p>The addition of IPv6 support also forced us to consider how to simplify the configuration frontend to MirageOS unikernels that was <a href="https://mirage.io/blog/mirage-1.1-released">originally written</a> by Thomas Gazagnaire and <a href="https://mirage.io/blog/intro-tcpip">described here</a> by Mindy Preston.
Nicolas has <a href="http://lists.xenproject.org/archives/html/mirageos-devel/2014-12/msg00001.html">proposed</a> a declarative extension to the configuration that allows applications to extend the <code>mirage</code> command-line more easily, thus unifying the &quot;built-in&quot; MirageOS compilation modes (such as choosing between Xen or Unix) and protocol-specific choices (such as configuring IPv4 and IPv6).</p>
<p>The new approach opens up the possibility of writing more user-friendly configuration frontends that can render them as a text- or web-based selectors, which is really important as more real-world uses of MirageOS are being created.  It should be possible in 2015 to solve common problems such as web or DNS serving without having to write a single line of OCaml code.</p>
<h3>Profiling</h3>
<p><a href="http://roscidus.com/blog/blog/2014/10/27/visualising-an-asynchronous-monad"><img src="http://roscidus.com/blog/images/mirage-profiling/block-reads-3-32.png" style="float:right; padding: 5px" width="300px" /></a></p>
<p>One of the benefits touted by our CACM article on <a href="http://queue.acm.org/detail.cfm?id=2566628">unikernels</a> at the start of the year was the improved tooling from the static linking of an entire application stack with an operating system layer.
<a href="http://roscidus.com">Thomas Leonard</a> joined the project this year after publishing a widely read <a href="http://roscidus.com/blog/blog/2014/06/06/python-to-ocaml-retrospective/">blog series</a> on his experiences from switching from Python to OCaml.
Aside from leading (and upstreaming to Xen) the port of <a href="https://mirage.io/blog/introducing-xen-minios-arm">MirageOS to ARM</a>, he also explored how to add profiling throughout the unikernel stack.</p>
<p>The support is now comprehensive and integrated into the MirageOS trees: the <a href="http://ocsigen.org/lwt">Lwt</a> cooperative threading engine has hooks for thread switching, most of the core libraries register named events, traces are dumped into shared memory buffers in the <a href="http://wiki.eclipse.org/Linux_Tools_Project/TMF/CTF_guide">CTF</a> file format used by the Linux trace toolkit, and there are JavaScript and GTK+ <a href="https://github.com/talex5/mirage-trace-viewer">GUI frontends</a> that can parse them.</p>
<p>You can find the latest instructions on <a href="https://mirage.io/wiki/profiling">Tracing and Profiling</a> on this website, and here are Thomas' original blog posts on the subject:</p>
<ul>
<li><a href="http://roscidus.com/blog/blog/2014/08/15/optimising-the-unikernel/">Optimising the Unikernel</a>
</li>
<li><a href="http://roscidus.com/blog/blog/2014/10/27/visualising-an-asynchronous-monad/">Visualising an Asynchronous Monad</a>
</li>
</ul>
<h3>Irmin</h3>
<p><a href="https://gazagnaire.org">Thomas Gazagnaire</a> spent most of the year furiously hacking away at the storage layer in Irmin, which is a clean-slate storage stack that uses a Git-like branching model as the basis for distributed unikernel storage.  <a href="https://github.com/mirage/irmin/releases/tag/0.9.0">Irmin 0.9.0</a> was released in December with efficiency improvements and a sufficiently portable set of dependencies to make JavaScript compilation practical.</p>
<ul>
<li><em>&quot;<a href="https://mirage.io/blog/introducing-irmin">Introducing Irmin: Git-like distributed, branchable storage</a>&quot;</em>  describes the concepts and high-level architecture of the system.
</li>
<li><em>&quot;<a href="https://mirage.io/blog/introducing-irmin-in-xenstore">Using Irmin to add fault-tolerance to the Xenstore database</a>&quot;</em> shows how Irmin is used in a real-world application: the security-critical Xen toolstack that manages hosts full of virtual machines (<a href="https://www.youtube.com/watch?v=DSzvFwIVm5s">video</a>).
</li>
<li>There have been several other early adopters of Irmin for their own projects (independent of MirageOS).  One of the most exciting is by <a href="https://github.com/gregatcam">Gregory Tsipenyuk</a>, who has been developing a version-controlled <a href="https://github.com/gregtatcam/imaplet-lwt">Irmin-based IMAP server</a> that offers a very different model for e-mail management.  Expect to see more of this in the new year!
</li>
</ul>
<p>We also had the pleasure of Benjamin Farinier and Matthieu Journault join us as summer interns.  Both of them did a great job improving the internals of Irmin, and Benjamin's work on <em><a href="http://gazagnaire.org/pub/FGM15.pdf">Mergeable Persistent Datastructures</a></em> will be presented at JFLA 2015.</p>
<h3>Jitsu</h3>
<p><a href="http://decks.openmirage.org/irill14-seminar#/"><img src="/graphics/decks-on-arm.png" style="float:right; padding: 5px" width="250px" /></a></p>
<p><a href="http://www.skjegstad.com/">Magnus Skjegstad</a> returned to Cambridge and got interested in the rapid dynamic provisioning of unikernels.  He built <a href="https://github.com/MagnusS/jitsu">Jitsu</a>, a DNS server that spawns unikernels in response to DNS requests and boots them in real-time with no perceptible lag to the end user.  The longer term goal behind this is to enable a community cloud of ARM-based <a href="http://cubieboard.org/">Cubieboard2</a> boards that serve user content without requiring centralised data centers, but with the ease-of-use of existing systems.</p>
<p>Building Jitsu and hitting our goal of extremely low latency management of unikernels required a huge amount of effort from across the MirageOS team.</p>
<ul>
<li><a href="http://dave.recoil.org">Dave Scott</a> and <a href="http://jon.recoil.org">Jon Ludlam</a> (two of the Xen maintainers at Citrix) improved the Xen <code>xl</code> toolstack to deserialise the VM startup chain to shave 100s of milliseconds off every operation.
</li>
<li><a href="http://roscidus.com/blog/">Thomas Leonard</a> drove the removal of our forked <a href="http://wiki.xen.org/wiki/Mini-OS">Xen MiniOS</a> with a library version that is being fed upstream (including ARM support).  This made the delta between Xen and MirageOS much smaller and therefore made reducing end-to-end latency tractable.
</li>
<li><a href="https://github.com/dsheets">David Sheets</a> built a test harness to boot unikernel services and measure their latency under very different conditions, including contrasting boot timer versus <a href="http://docker.com">Docker</a> containers.  In many instances, we ended up booting faster than containers due to not touching disk at all with a standalone unikernel.  <a href="http://www.cl.cam.ac.uk/~iml1/">Ian Leslie</a> built us some custom power measurement hardware that came in handy to figure out how to drive down the energy cost of unikernels running on ARM boards.
</li>
<li><a href="http://gazagnaire.org">Thomas Gazagnaire</a>, Balraj Singh, Magnus Skjegstad built the <code>synjitsu</code> proxy server that intercepts and proxies TCP connections to mask the couple of 100 milliseconds during unikernel boot time, ensuring that no TCP connections ever require retransmission from the client.
</li>
<li><a href="http://dave.recoil.org">Dave Scott</a> and I built out the <a href="https://github.com/mirage/">vchan</a> shared memory transport that supports low-latency communiction between unikernels and/or Unix processes.  This is rapidly heading into a Plan9-like model, with the additional twist of using Git instead of a flat filesystem hierarchy as its coordination basis.
</li>
<li><a href="http://amirchaudhry.com/">Amir Chaudhry</a> and <a href="http://mort.io">Richard Mortier</a> documented the Git-based (and eventually Irmin-based) workflow behind managing the unikernels themselves, so that they can easily be deployed to distance ARM devices simply by running <code>git pull</code>.  You can read more about this in his <a href="http://amirchaudhry.com/from-jekyll-to-unikernel-in-fifty-lines">From Jekyll to Unikernels</a> post.
</li>
</ul>
<p>All of this work was hastily crammed into a <a href="https://www.usenix.org/conference/nsdi15/call-for-papers">USENIX NSDI 2015</a> paper that got submitted at 4am on a bright autumn morning.  <a href="https://www.usenix.org/system/files/conference/nsdi15/nsdi15-paper-madhavapeddy.pdf">Here is the published paper</a>, and we're planning a blog post describing how you can deploy this infrastructure for yourself.</p>
<h3>Community</h3>
<p>All of the above work was only possible due to the vastly improved tooling and infrastructure around the project.  Our community manager Amir Chaudhry led the <a href="https://mirage.io/docs/">minuted</a> calls every two weeks that tied the efforts together, and we established some <a href="https://github.com/mirage/mirage-www/wiki/Pioneer-Projects">pioneer projects</a> for newcomers to tackle.</p>
<img src="/graphics/opam-packages-20141231.png" style="float:right; padding: 5px" width="250px" />
<p>The <a href="https://opam.ocaml.org">OPAM</a> package manager continued to be the frontend for all MirageOS tools, with releases of libraries happening <a href="https://mirage.io/releases">regularly</a>.  Because of the modular nature of MirageOS code, most of the libraries can also be used as normal Unix-based libraries, meaning that we aren't just limited to MirageOS users but can benefit from the entire OCaml community.  The graph to the right shows the growth of the total package database since the project started to give you a sense of how much activity there is.</p>
<p>The major <a href="http://opam.ocaml.org/blog/opam-1-2-0-release/">OPAM 1.2</a> also added a number of new features that made MirageOS code easier to develop, including a <a href="http://opam.ocaml.org/blog/opam-1-2-pin/">Git-based library pinning workflow</a> that works superbly with GitHub, and <a href="http://opam.ocaml.org/blog/opam-1-2-travisci/">easier Travis integration</a> for continuous integration.  <a href="https://github.com/niksu">Nik Sultana</a> also improved the <a href="https://github.com/mirage/is-mirage-broken/tree/master/logs">is-mirage-broken</a> to give us a cron-driven prod if a library update caused an end-to-end failure in building the MirageOS website or other self-hosted infrastructure.</p>
<p>Our favourite <a href="http://www.somerandomidiot.com">random idiot</a>, Mindy Preston, wrote up a superb blog series about her experiences in the spring of 2014 with moving her homepage to be hosted on MirageOS.  This was followed up by <a href="http://roscidus.com/blog/blog/2014/07/28/my-first-unikernel/">Thomas Leonard</a>, <a href="http://philtomson.github.io/blog/2014/09/10/some-notes-on-building-and-running-mirage-unikernels-on-cubieboard2/">Phil Tomson</a>, <a href="https://github.com/iw/mirage-jekyll">Ian Wilkinson</a>, <a href="http://ocaml.is-awesome.net/2014/11/building-a-blog-with-mirage-os">Toby Moore</a>, and many others that we've tried to record in our <a href="https://mirage.io/links/">link log</a>.  We really appreciate the hundreds of bug reports filed by users and folk trying out MirageOS; by taking the trouble to do this, you've  helped us refine and polish the frontend.  One challenge for 2015 that we could use help on is to pull together many of these distributed blogged instructions and merge them back into the main documentation (get in touch if interested!).</p>
<p>OCaml has come a long way in the last year in terms of tooling, and another task my research group <a href="http://ocaml.io">OCaml Labs</a> works on at Cambridge is the development of the <a href="https://ocaml.org/meetings/ocaml/2014/ocaml2014_7.pdf">OCaml Platform</a>.  I'll be blogging separately about our OCaml-specific activities in a few days, but all of this work has a direct impact on MirageOS itself since it lets us establish a local feedback loop between MirageOS and OCaml developers to rapidly iterate on large-scale development.  The regular <a href="http://ocamllabs.github.io/compiler-hacking/">OCaml compiler hacking sessions</a> organised by Jeremy Yallop and Leo White have been a great success this year, with a wide variety of people from academic (Cambridge, London universities and Microsoft Research) and industrial (Jane Street, Citrix and Facebook among others) and locally interested folk.
One very important project that has had a lot of work put into it in 2014 (but isn't quite ready for a public release yet) is <a href="https://github.com/samoht/assemblage">Assemblage</a>, which will remove much of the boilerplate currently needed to build and release an OCaml library to OPAM.</p>
<p>We also had a great time working with open-source summer programs. Thanks to the Xen Foundation and GNOME for their support here, and we hope to do this again next summer!  The roundup posts were:</p>
<ul>
<li><em><a href="http://www.somerandomidiot.com/blog/2014/08/22/opw-fin/">OPW FIN</a></em> by Mindy Preston: on of her <a href="http://gnome.org/opw/">FOSS Outreach Program</a> work.
</li>
<li><em><a href="http://1000hippos.wordpress.com/">Amazon Adventures</a></em> by Jyotsna Prakash: on her <a href="https://developers.google.com/open-source/soc/?csw=1">Google Summer of Code</a> 2014 efforts on EC2 bindings.
</li>
</ul>
<h3>Upcoming features</h3>
<p>So what's coming up for our unikernels in 2015?  Our focus heading into the new year is very much on improving the ease-of-use and deployability of MirageOS and fleshing out the feature set for the early adopters such as the <a href="https://github.com/xapi-project">XAPI</a> project, <a href="http://events.linuxfoundation.org/sites/events/files/slides/XenStore_MAC_XenSummit_2014.pdf">Galois</a>, and the <a href="http://nymote.org">Nymote</a> personal data project.  Here are some of the highlights:</p>
<ul>
<li>
<p><strong>Dust Clouds</strong>: The work on Jitsu is leading to the construction of what we term &quot;<a href="http://anil.recoil.org/papers/2010-iswp-dustclouds.pdf">dust clouds</a>&quot;: on-demand scaling of unikernel services within milliseconds of requests coming in, terminated right beside the user on local ARM devices.  The model supports existing clouds as well, and so we are improving support for cloud APIs such via Jyotsna Prakash's <a href="https://github.com/moonlightdrive/ocaml-ec2">EC2</a> bindings, <a href="https://github.com/djs55/xe-unikernel-upload">XenAPI</a>, and (volunteers needed) OpenStack support.  If you're interested in tracking this work, head over to the <a href="http://nymote.org">Nymote</a> site for updates.</p>
</li>
<li>
<p><strong>Portability</strong>: Beyond Xen, there are several efforts afoot to port MirageOS to bare metal targets.  One promising effort is to use <a href="http://rumpkernel.org">Rump Kernels</a> as the boot infrastructure and MirageOS as the application stack.  We hope to have a Raspberry Pi and other ARM targets fairly soon.  Meanwhile at the end of the spectrum is mobile computing, which was part of the original <a href="http://anil.recoil.org/papers/2010-bcs-visions.pdf">multiscale</a> vision for starting the project.  The JavaScript, iOS and Android ports are all progressing (mainly thanks to community contributions around OCaml support for this space, such as Jeff Psellos' hard work on <a href="http://psellos.com/ocaml/">OCaml-IOS</a>).</p>
</li>
<li>
<p><strong>Protocol Development</strong>: There are a huge number of protocols being developed independently, and more are always welcome.  <a href="https://github.com/infidel">Luke Dunstan</a> is hacking on <a href="https://github.com/mirage/ocaml-dns/pull/35#discussion_r22388447">multicast DNS</a> support, we have an IMAP <a href="https://github.com/nojb/ocaml-imap">client</a> and <a href="https://github.com/gregtatcam/imaplet-lwt/">server</a>, <a href="https://github.com/dominicjprice">Dominic Price</a> has built a series of social network APIs for <a href="https://github.com/dominicjprice/sociaml-facebook-api">Facebook</a> or <a href="https://github.com/dominicjprice/sociaml-tumblr-api">Tumblr</a>, and <a href="http://nottingham.ac.uk/horizon/people/masoud.koleini">Masoud Koleini</a> has been extending Haris Rotsos' work to achieve a line-rate and type-safe <a href="https://github.com/mirage/ocaml-openflow">OpenFlow</a> switch and controller based on the <a href="https://github.com/frenetic-lang">Frenetic</a> project.  Hannes is also developing <a href="https://github.com/hannesm/jackline">Jackline</a>, which uses his MirageOS to assemble a trustworthy communication client.  <a href="http://erratique.ch/software">Daniel Buenzli</a> also continues to release a growing set of high-quality, modular libraries that we depend on throughout MirageOS.</p>
</li>
<li>
<p><strong>Storage</strong>: All storage services from the unikernels will be Git-based (e.g. logging, command-and-control, key-value retrieval).  Expect to see Xen toolstack extensions that make this support seamless, so a single Linux VM will be able to control a large army of unikernels via persistent data structures.</p>
</li>
</ul>
<h3>Want to get involved?</h3>
<p>This is a really fun time to get involved with unikernels and the MirageOS project. The year of 2014 has seen <a href="https://mirage.io/links/">lots of discussion</a> about the potential of unikernels and we'll see some of the first big deployments involving them in 2015.  For the ones among you who wish to learn more, then check out the <a href="https://github.com/mirage/mirage-www/wiki/Pioneer-Projects">pioneer projects</a>, watch out for <a href="https://mirage.io/wiki">Amir's meeting notes</a> and join the voice calls if you want a more interactive discussion, and engage on the <a href="https://mirage.io/community/">mailing lists</a> with any questions you might have.</p>
<p>For me personally, it's been a real privilege to spend the year working with and learning from the friendly, intelligent and diverse community that is springing up around the project.  The progression from experiment to reality has been a lot of work, but the unikernel dream is finally coming together rath[er nicely thanks to everyone's hard work and enthusiasm.  I'd also like to thank all of our <a href="https://mirage.io/community/">funding bodies</a> and the <a href="http://linuxfoundation.org">Linux Foundation</a> and the <a href="http://xenproject.org">Xen Project</a> (especially Lars Kurth and Russell Pavlicek) for their support throughout the year that made all this work possible.  Happy new year, everyone!</p>
|js};
      };
      {
        updated = {js|2014-07-22 11:00|js};
        authors =
          [
            {
              name = {js|Anil Madhavapeddy|js};
              uri = Some {js|http://anil.recoil.org|js};
              email = Some {js|anil@recoil.org|js};
            };
          ];
        subject = {js|MirageOS v2.0: a recap of the new features|js};
        permalink = {js|announcing-mirage-20-release|js};
        body =
          {js|<small>
  This work funded in part by the EU FP7 User-Centric Networking project, Grant
  No. 611001.
</small>
<p>The <a href="https://mirage.io/blog/announcing-mirage10">first release</a> of MirageOS back in December 2013 introduced the prototype
of the <a href="http://queue.acm.org/detail.cfm?id=2566628">unikernel concept</a>, which realised the promise of a safe,
flexible mechanism to build highly optimized software stacks purpose-built for deployment in the public cloud (more <a href="https://mirage.io/wiki/overview-of-mirage">background</a> on this).
Since then, we've been hard at work using and extending MirageOS for real projects and the community has been
<a href="https://mirage.io/blog/welcome-to-our-summer-hackers">steadily growing</a>.</p>
<p>We're thrilled to announce the release of MirageOS v2.0 today!  Over the past
few weeks the <a href="https://mirage.io/community">team</a> has been <a href="https://github.com/mirage/mirage/issues/257">hard at work</a> blogging about all
the new features in this latest release, coordinated by the tireless <a href="http://amirchaudhry.com">Amir Chaudhry</a>:</p>
<img src="/graphics/cubieboard2.jpg" style="float:right; padding: 5px" width="250px" />
<ul>
<li><strong>ARM device support</strong>: While the first version of MirageOS was specialised towards conventional x86 clouds, the code generation and boot libraries have now been made portable enough to operate on low-power embedded ARM devices such as the <a href="http://cubieboard.org/">Cubieboard 2</a>.  This is a key part of our efforts to build a safe, unified <a href="http://anil.recoil.org/papers/2010-bcs-visions.pdf">mutiscale programming model</a> for both cloud and mobile workloads as part of the <a href="http://nymote.org">Nymote</a> project.  We also upstreamed the changes required to the Xen Project so that other unikernel efforts such as <a href="https://github.com/GaloisInc/HaLVM">HalVM</a> or <a href="https://www.usenix.org/system/files/conference/nsdi14/nsdi14-paper-martins.pdf">ClickOS</a> can benefit.
<ul>
<li><em>&quot;<a href="https://mirage.io/blog/introducing-xen-minios-arm">Introducing an ARMy of unikernels</a>&quot;</em> by <a href="http://roscidus.com/blog/">Thomas Leonard</a> talks about the changes required and <a href="https://mirage.io/wiki/xen-on-cubieboard2">instructions</a> for trying this out for yourself on your own cheap Cubieboard.
</li>
</ul>
</li>
<li><strong>Irmin distributed, branchable storage</strong>: Unikernels usually execute in a distributed, disconnection-prone environment (particularly with the new mobile ARM support).  We therefore built the <a href="https://github.com/mirage/irmin">Irmin</a> library to explicitly make synchronization easier via a Git-like persistence model that can be used to build and easily trace the operation of distributed applications across all of these diverse environments.
<ul>
<li><em>&quot;<a href="https://mirage.io/blog/introducing-irmin">Introducing Irmin: Git-like distributed, branchable storage</a>&quot;</em> by <a href="http://gazagnaire.org">Thomas Gazagnaire</a> describes the concepts and high-level architecture of the system.
</li>
<li><em>&quot;<a href="https://mirage.io/blog/introducing-irmin-in-xenstore">Using Irmin to add fault-tolerance to the Xenstore database</a>&quot;</em> by <a href="http://dave.recoil.org">Dave Scott</a> shows how Irmin is used in a real-world application: the security-critical Xen toolstack that manages hosts full of virtual machines (<a href="https://www.youtube.com/watch?v=DSzvFwIVm5s">video</a>).
</li>
</ul>
</li>
<li><strong>OCaml TLS</strong>: The philosophy of MirageOS is to construct the entire operating system in a safe programming style, from the device drivers up.  This continues in this release with a comprehensive OCaml implementation of <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">Transport Level Security</a>, the most widely deployed end-to-end encryption protocol on the Internet (and one that is very prone to <a href="https://en.wikipedia.org/wiki/Heartbleed">bad security holes</a>).  The blog series is written by <a href="https://github.com/hannesm">Hannes Mehnert</a> and <a href="https://github.com/pqwy">David Kaloper</a>.
<ul>
<li><em>&quot;<a href="https://mirage.io/blog/introducing-ocaml-tls">OCaml-TLS: Introducing transport layer security (TLS) in pure OCaml</a>&quot;</em> presents the motivation and architecture behind our clean-slate implementation of the protocol.
</li>
<li><em>&quot;<a href="https://mirage.io/blog/introducing-nocrypto">OCaml-TLS: building the nocrypto library core</a>&quot;</em> talks about the cryptographic primitives that form the heart of TLS confidentiality guarantees, and how they expose safe interfaces to the rest of the stack.
</li>
<li><em>&quot;<a href="https://mirage.io/blog/introducing-x509">OCaml-TLS: adventures in X.509 certificate parsing and validation</a>&quot;</em> explains how authentication and chain-of-trust verification is implemented in our stack.
</li>
<li><em>&quot;<a href="https://mirage.io/blog/introducing-asn1">OCaml-TLS: ASN.1 and notation embedding</a>&quot;</em> introduces the libraries needed for handling ASN.1 grammars, the wire representation of messages in TLS.
</li>
<li><em>&quot;<a href="https://mirage.io/blog/ocaml-tls-api-internals-attacks-mitigation">OCaml-TLS: the protocol implementation and mitigations to known attacks</a>&quot;</em> concludes with the implementation of the core TLS protocol logic itself.
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Modularity and communication</strong>: MirageOS is built on the concept of a <a href="http://anil.recoil.org/papers/2013-asplos-mirage.pdf">library operating system</a>, and this release provides many new libraries to flexibly extend applications with new functionality.
<ul>
<li><em>&quot;<a href="https://mirage.io/blog/intro-tcpip">Fitting the modular MirageOS TCP/IP stack together</a>&quot;</em> by <a href="http://somerandomidiot.com">Mindy Preston</a> explains the rather unique modular architecture of our TCP/IP stack that lets you swap between the conventional Unix sockets API, or a complete implementation of TCP/IP in pure OCaml.
</li>
<li><em>&quot;<a href="https://mirage.io/blog/update-on-vchan">Vchan: low-latency inter-VM communication channels</a>&quot;</em> by <a href="http://jon.recoil.org">Jon Ludlam</a> shows how unikernels can communicate efficiently with each other to form distributed clusters on a multicore Xen host, by establishing shared memory rings with each other.
</li>
<li><em>&quot;<a href="https://mirage.io/blog/modular-foreign-function-bindings">Modular foreign function bindings</a>&quot;</em> by <a href="https://github.com/yallop">Jeremy Yallop</a> continues the march towards abstraction by expaining how to interface safely with code written in C, without having to write any unsafe C bindings!  This forms the basis for allowing Xen unikernels to communicate with existing libraries that they may want to keep at arm's length for security reasons.
</li>
</ul>
</li>
</ul>
<p>All the libraries required for these new features are <a href="/releases">regularly
released</a> into the <a href="http://opam.ocaml.org">OPAM</a> package manager, so
just follow the <a href="/wiki/install">installation instructions</a> to give them a spin.
A release this size probably introduces minor hiccups that may cause build
failures, so we very much encourage <a href="https://github.com/mirage/mirage/issues">bug
reports</a> on our issue tracker or
<a href="/community">questions</a> to our mailing lists.  Don't be shy: no question is too
basic, and we'd love to hear of any weird and wacky uses you put this new
release to!  And finally, the lifeblood of MirageOS is about sharing and
<a href="http://opam.ocaml.org/doc/Packaging.html">publishing libraries</a> that add new functionality to the framework, so do get
involved and open-source your own efforts.</p>
<p><em>Breaking news</em>: <a href="http://mort.io">Richard Mortier</a> and I will be speaking at <a href="http://www.oscon.com">OSCON</a> this week on Thursday morning about the new features <a href="http://www.oscon.com/oscon2014/public/schedule/detail/35024">in F150 in the Cloud Track</a>. Come along if you are in rainy Portland at the moment!</p>
|js};
      };
      {
        updated = {js|2014-07-22 10:00|js};
        authors =
          [
            {
              name = {js|Thomas Leonard|js};
              uri = Some {js|http://roscidus.com/blog/|js};
              email = Some {js|talex5@gmail.com|js};
            };
          ];
        subject = {js|Building an ARMy of Xen unikernels|js};
        permalink = {js|introducing-xen-minios-arm|js};
        body =
          {js|<p>Mirage has just gained the ability to compile unikernels for the Xen/arm32
platform, allowing Mirage guests to run under the Xen hypervisor on ARM
devices such as the <a href="http://cubietruck.com/collections/frontpage/products/cubieboard2-allwinner-a20-arm-cortex-a7-dual-core-development-board">Cubieboard 2</a> and <a href="http://cubietruck.com/collections/frontpage/products/cubietruck-cubieboard3-cortex-a7-dual-core-2gb-ram-8gb-flash-with-wifi-bt">CubieTruck</a>.</p>
<h3>Introduction</h3>
<p>The ARMv7 architecture introduced the (optional) Virtualization Extensions,
providing hardware support for running virtual machines on ARM devices, and
Xen's <a href="http://www.xenproject.org/developers/teams/arm-hypervisor.html">ARM Hypervisor</a> uses this to support hardware accelerated
ARM guests.</p>
<p><a href="http://wiki.xen.org/wiki/Mini-OS">Mini-OS</a> is a tiny OS kernel designed specifically for running under Xen.
It provides code to initialise the CPU, display messages on the console,
allocate memory (malloc), and not much else. It is used as the low-level
core of Mirage's Xen implementation.</p>
<p>Mirage v1 was built on an old version of Mini-OS which didn't support ARM.
For Mirage v2, we have added ARM support to the current Mini-OS (completing
Karim Allah Ahmed's <a href="http://lists.xen.org/archives/html/xen-devel/2014-01/msg00249.html">initial ARM port</a>) and made Mirage depend
on it as an external library.
This means that Mirage will automatically gain support for other
architectures that get added later.
We are currently working with the Xen developers to get
<a href="https://github.com/talex5/xen">our Mini-OS fork</a> upstreamed.</p>
<p>In a similar way, we have replaced Mirage v1's bundled maths library with a
dependency on the external
<a href="https://github.com/JuliaLang/openlibm">OpenLibm</a>, which we also extended
with ARM support (this was just a case of fixing the build system; the code
is from FreeBSD's libm, which already supported ARM).</p>
<p>Mirage v1 also bundled <a href="http://www.fefe.de/dietlibc/">dietlibc</a> to provide its standard C library.
A nice side-effect of this work came when we were trying to separate out the
dietlibc headers from the old Mini-OS headers in Mirage.
These had rather grown together over time and the work was proving
difficult, until we discovered that we no longer needed a libc at all, as
almost everything that used it had been replaced with pure OCaml versions!
The only exception was the <code>printf</code> code for formatting floating point
numbers, which OCaml uses in its <code>printf</code> implementation.
We replaced that by taking the small <code>fmt_fp</code> function from
<a href="http://www.musl-libc.org/">musl libc</a>.</p>
<p>Here's the final diffstat of the changes to <a href="https://github.com/mirage/mirage-platform">mirage-platform</a>
adding ARM support:</p>
<pre><code>778 files changed, 1949 insertions(+), 59689 deletions(-)
</code></pre>
<h3>Trying it out</h3>
<p>You'll need an ARM device with the Virtualization Extensions.
I've been testing using the Cubieboard 2 (and CubieTruck):</p>
<p><img src="/graphics/cubieboard2.jpg" alt="Cubieboard2" /></p>
<p>The first step is to install Xen.
<a href="https://mirage.io/wiki/xen-on-cubieboard2">Running Xen on the Cubieboard2</a>
documents the manual installation process, but you can now also use
<a href="https://github.com/mirage/xen-arm-builder">mirage/xen-arm-builder</a> to build
an SDcard image automatically.
Copy the image to the SDcard, connect the network cable and power, and the
board will boot Xen.</p>
<p>Once booted you can ssh to Dom0, the privileged Linux domain used to manage
the system, <a href="https://mirage.io/wiki/install">install Mirage</a>, and build your unikernel just
as on x86.
Currently, you need to select the Git versions of some components.
The following commands will install the necessary versions if you're using
the xen-arm-builder image:</p>
<pre><code class="language-bash">$ opam init
$ opam install mirage-xen-minios
$ opam remote add mirage-dev git://github.com/mirage/mirage-dev
$ opam install mirage
</code></pre>
<h3>Technical details</h3>
<p>One of the pleasures of unikernels is that you can comprehend the whole
system with relatively little effort, and
those wishing to understand, debug or contribute to the ARM support may find
the following technical sections interesting.
However, you don't need to know the details of the ARM port to use it,
as Mirage abstracts away the details of the underlying platform.</p>
<h4>The boot process</h4>
<p>An ARM Mirage unikernel uses the <a href="http://www.simtec.co.uk/products/SWLINUX/files/booting_article.html">Linux zImage format</a>, though it is
not actually compressed. Xen will allocate some RAM for the image and load
the kernel at the offset 0x8000 (32 KB).</p>
<p>Execution begins in <a href="https://github.com/talex5/xen/blob/cde4b7e14b0aeedcdc006b0622905b7af2665c77/extras/mini-os/arch/arm/arm32.S#L8">arm32.S</a>, with the <code>r2</code> register pointing to a
<a href="http://www.devicetree.org">Flattened Device Tree (FDT)</a> describing details of the virtual system.
This assembler code performs a few basic boot tasks:</p>
<ol>
<li>Configuring the MMU, which maps virtual addresses to physical addresses (see next section).
</li>
<li>Turning on caching and branch prediction.
</li>
<li>Setting up the exception vector table (this says how to handle interrupts and deal with various faults, such as reading from an invalid address).
</li>
<li>Setting up the stack pointer and calling the C function <code>arch_init</code>.
</li>
</ol>
<p><a href='https://github.com/talex5/xen/blob/cde4b7e14b0aeedcdc006b0622905b7af2665c77/extras/mini-os/arch/arm/setup.c#L74'>arch_init</a> makes some calls to the hypervisor to set up support for the console and interrupt controller, and then calls <code>start_kernel</code>.</p>
<p><a href='https://github.com/mirage/mirage-platform/blob/b0a027d4486230ce6e1e8fd0e7354b17e9c388f5/xen/runtime/xencaml/main.c#L57'>start_kernel</a> (in libxencaml) sets up a few more features (events, malloc, time-keeping and <a href="http://wiki.xen.org/wiki/Grant_Table">grant tables</a>), then calls <code>caml_startup</code>.</p>
<p><a href='https://github.com/mirage/mirage-platform/blob/b0a027d4486230ce6e1e8fd0e7354b17e9c388f5/xen/runtime/ocaml/startup.c#L202'>caml_startup</a> (in libocaml) initialises the garbage collector and calls <code>caml_program</code>, which is your application's <code>main.ml</code>.</p>
<h4>The address space</h4>
<p>With the Virtualization Extensions, there are two stages to converting a
virtual memory address (used by application code) to a physical address in
RAM.
The first stage is under the control of the guest VM, mapping the virtual
address to what the guest believes is the physical address (this address is
referred to as the <em>Intermediate Physical Address</em> or <em>IPA</em>).
The second stage, under the control of Xen, maps the IPA to the real
physical address.
The tables holding these mappings are called <em>translation tables</em>.</p>
<p>Mirage's memory needs are simple: most of the RAM should be used for the
garbage-collected OCaml heap, with a few pages used for interacting with Xen
(these don't go on the OCaml heap because they must be page aligned and must
not move around).</p>
<p>Xen does not commit to using a fixed address as the IPA of the RAM, but the
C code needs to run from a known location. To solve this problem the
assembler code in <code>arm32.S</code> detects where it is running from and sets up a
virtual-to-physical mapping that will make it appear at the expected
location, by adding a fixed offset to each virtual address.
For example, on Xen/unstable, we configure the beginning of the virtual
address space to look like this (on Xen 4.4, the physical addresses would
start at 80000000 instead):</p>
<table>
  <tr><th>Virtual address</th><th>Physical address (IPA)</th><th>Purpose</th></tr>
  <tr><td>400000</td><td>40000000</td><td>Stack (16 KB)</td></tr>
  <tr><td>404000</td><td>40004000</td><td>Translation tables (16 KB)</td></tr>
  <tr><td>408000</td><td>40008000</td><td>Kernel image</td></tr>
</table>
<p>The physical address is always at a fixed offset from the virtual address and
the addresses wrap around, so virtual address c0400000 maps back to physical
address 0 (in this example).</p>
<p>The stack, which grows downwards, is placed at the start of RAM so that a
stack overflow will trigger a fault rather than overwriting other data.</p>
<p>The 16 KB translation table is an array of 4-byte entries each mapping 1 MB
of the virtual address space, so the 16 KB table is able to map the entire
32-bit address space (4 GB). Each entry can either give the physical section
address directly (which is what we do) or point to a second-level table
mapping individual 4 KB pages. By using only the top-level table we reduce
possible delays due to <a href="http://en.wikipedia.org/wiki/Translation_lookaside_buffer">TLB misses</a>.</p>
<p>After the kernel code comes the data (constants and global variables), then
the <a href="http://en.wikipedia.org/wiki/.bss">bss</a> section (data that is initially
zero, and therefore doesn't need to be stored in the kernel image),
and finally the rest of the RAM, which is handed over to the malloc system.</p>
<h3>Contact</h3>
<p>The current version seems to be working well on Xen 4.4 (stable) and the 4.5
development version, but has only been lightly tested.
If you have any problems or questions, or get it working on other devices,
please <a href="https://mirage.io/community/">let us know</a>!</p>
|js};
      };
      {
        updated = {js|2014-07-21 11:00|js};
        authors =
          [
            {
              name = {js|Dave Scott|js};
              uri = Some {js|http://dave.recoil.org/|js};
              email = Some {js|dave@recoil.org|js};
            };
          ];
        subject =
          {js|Using Irmin to add fault-tolerance to the Xenstore database|js};
        permalink = {js|introducing-irmin-in-xenstore|js};
        body =
          {js|<p><em>This is the second in a series of posts that introduces the <a href="https://github.com/mirage/irmin">Irmin</a> distributed storage engine.
You might like to begin with the <a href="https://mirage.io/blog/introducing-irmin">introductory post</a>.</em></p>
<p><a href="http://wiki.xen.org/wiki/XenStore">Xenstore</a> is a critical service found on all hosts
running <a href="http://www.xen.org/">Xen</a>. Xenstore is necessary to</p>
<ul>
<li>configure all VM I/O devices such as disk controllers and network interface cards;
</li>
<li>share performance statistics and OS version information; and
</li>
<li>signal VMs during shutdown, suspend, resume, migrate etc.
</li>
</ul>
<p>Xenstore must be <strong>reliable</strong>: if it fails then the host is unmanageable and must be rebooted.</p>
<p>Xenstore must be <strong>secure</strong>: if it is compromised by a VM then that VM can access data belonging
to other VMs.</p>
<p>The current version of Xenstore is <a href="http://xenbits.xen.org/gitweb/?p=xen.git;a=tree;f=tools/ocaml/xenstored;h=0d762f2a61de098c0100814e0c140575b51688a3;hb=stable-4.4">already written in OCaml</a>
and documented in the paper
<a href="http://gazagnaire.org/pub/GH09.pdf">OXenstored: an efficient hierarchical and transactional database using functional programming with reference cell comparisons</a> presented at ICFP 2009.
The existing code works very reliably, but there is always room for improvement
for debuggability of such a complex system component. This is where Irmin, the
storage layer of Mirage 2.0, can help.</p>
<p>But first, a quick Xenstore primer:</p>
<h3>Xen and Xenstore in 30 seconds</h3>
<p>The Xen hypervisor focuses on isolating VMs from each-other; the hypervisor provides a virtual CPU scheduler
and a memory allocator but does not perform I/O on behalf of guest VMs.
On a Xen host, privileged server VMs perform I/O on behalf of client VMs.
The configuration for calculating which server VM services requests for which client VMs is stored in Xenstore, as
key/value pairs.</p>
<p>The following diagram shows a Xen host with a single client and server VM, with
a single virtual device in operation.  Disk blocks and network packets flow via
shared memory between Xen-aware drivers in the VMs, shown in the lower-half.
The control-plane, shown in the upper-half, contains the metadata about the
datapath: how the device should appear in the client VM; where the I/O should
go in the server VM; where the shared memory control structures are etc.</p>
<img src="/graphics/xenstore-diagram.png" alt="Device configuration is stored in Xenstore as key=value pairs." />
<p>The Xenstore device attach protocol insists that all device keys are added
through atomic transactions, i.e. partial updates are never visible to clients and transactions
cannot interfere with each other.
A Xenstore server must abort transactions whose operations were not successfully
isolated from other transactions. After an abort, the client is expected to retry.
Each key=value write is communicated to the server as a single request/response, so transactions
comprising multiple writes are open for multiple round-trip times.
This protocol is baked into guest VM kernels (including Linux, FreeBSD, Mirage, ...)
and won't change anytime soon.</p>
<p>Xenstore is used heavily when lots of VMs are starting in parallel. Each VM typically
has several devices, each of these devices is added in a parallel transaction and therefore
many transactions are open at once. If the server aborts too many of these transactions,
causing the clients to retry, the system will make little progress and may appear to live-lock.
The challenge for a Xenstore implementation is to minimise the number of aborted
transactions and retries, without compromising on the isolation guarantee.</p>
<h3>Irmin Xenstore design goals</h3>
<p>The design goals of the Irmin-based Mirage Xenstore server are:</p>
<ol>
<li>safely restart after a crash;
</li>
<li>make system debugging easy; and
</li>
<li>go really fast!
</li>
</ol>
<p>How does Irmin help achieve these goals?</p>
<h3>Restarting after crashes</h3>
<p>The Xenstore service is a reliable component and very rarely crashes. However,
if a crash does occur, the impact is severe on currently running virtual
machines. There is no protocol for a running VM to close its connection to a
Xenstore and open a new one, so if Xenstore crashes then running VMs are simply
left orphaned. VMs in this state are impossible to manage properly: there is no
way to shut them down cleanly, to suspend/resume or migrate, or to configure
any disk or network interfaces. If Xenstore crashes, the host must be rebooted
shortly after.</p>
<p>Irmin helps make Xenstore recoverable after a crash, by providing a library
that applications can use to persist and synchronise distributed data
structures on disk and in memory. By using Irmin to persist all our state
somewhere sensible and taking care to manage our I/O carefully, then the server
process becomes stateless and can be restarted at will.</p>
<p>To make Xenstore use Irmin,
the first task is to enumerate all the different kinds of state in the running process.
This includes the obvious key-value pairs used for VM configuration
as well as data currently hidden away in the OCaml heap:
the addresses in memory of established communication rings,
per-domain quotas, pending watch events and watch registrations etc etc.
Once the state has been enumerated it must be mapped onto key-value pairs which can
be stored in Irmin. Rather than using ad-hoc mappings everywhere, the Mirage Irmin
server has
<a href="https://github.com/mirage/ocaml-xenstore-server/blob/blog/introducing-irmin-in-xenstore/server/pMap.mli">persistent Maps</a>,
<a href="https://github.com/mirage/ocaml-xenstore-server/blob/blog/introducing-irmin-in-xenstore/server/pSet.ml">persistent Sets</a>,
<a href="https://github.com/mirage/ocaml-xenstore-server/blob/blog/introducing-irmin-in-xenstore/server/pQueue.ml">persistent Queues</a>
and
<a href="https://github.com/mirage/ocaml-xenstore-server/blob/blog/introducing-irmin-in-xenstore/server/pRef.ml">persistent reference cells</a>.</p>
<p>Irmin applications are naturally written as functors, with the details of the persistence kept
abstract.
The following <a href="https://github.com/mirage/irmin/blob/0.8.3/lib/core/irminView.mli">Irmin-inspired</a> signature represents what Xenstore needs
from Irmin:</p>
<pre><code>module type VIEW = sig
  type t

  val create: unit -&gt; t Lwt.t
  (** Create a fresh VIEW from the current state of the store.
      A VIEW tracks state queries and updates and acts like a branch
      which has an explicit [merge]. *)

  val read: t -&gt; Protocol.Path.t -&gt; 
    [ `Ok of Node.contents | `Enoent of Protocol.Path.t ] Lwt.t
  (** Read a single key *)

  val list: t -&gt; Protocol.Path.t -&gt; 
    [ `Ok of string list | `Enoent of Protocol.Path.t ] Lwt.t
  (** List all the children of a key *)

  val write: t -&gt; Protocol.Path.t -&gt; Node.contents -&gt; 
    [ `Ok of unit ] Lwt.t
  (** Update a single key *)

  val mem: t -&gt; Protocol.Path.t -&gt; bool Lwt.t
  (** Check whether a key exists *)

  val rm: t -&gt; Protocol.Path.t -&gt; [ `Ok of unit ] Lwt.t
  (** Remove a key *)

  val merge: t -&gt; string -&gt; bool Lwt.t
  (** Merge this VIEW into the current state of the store *)
end
</code></pre>
<p>The main 'business logic' of Xenstore can then be functorised over this signature relatively easily.
All we need is to instantiate the functor using Irmin to persist the data somewhere sensible.
Eventually we will need two instantiations: one which runs as a userspace application and which
writes to the filesystem; and a second which will run as a
native Xen kernel (known as a <a href="/blog/xenstore-stub-domain">xenstore stub domain</a>)
and which will write to a fixed memory region (like a ramdisk).
The choice of which to use is left to the system administrator. Currently most (if not all)
distribution packagers choose to run Xenstore in userspace. Administrators who wish to
further secure their hosts are encouraged to run the kernelspace version to isolate Xenstore
from other processes (where a VM offers more isolation than a container, which offers more
isolation than a chroot). Note this choice is invisible to the guest VMs.</p>
<p>So far in the Irmin Xenstore integration only the userspace instantiation has been implemented.
One of the most significant user-visible features is that all of the operations done through
Irmin can be inspected using the standard <code>git</code> command line tool.
The runes to configure Irmin to write
<a href="http://git-scm.com">git</a> format data to the filesystem are as follows:</p>
<pre><code>    let open Irmin_unix in
    let module Git = IrminGit.FS(struct
      let root = Some filename
      let bare = true
    end) in
    let module DB = Git.Make(IrminKey.SHA1)(IrminContents.String)(IrminTag.String) in
    DB.create () &gt;&gt;= fun db -&gt;
</code></pre>
<p>where keys and values will be mapped into OCaml <code>strings</code>, and our
<code>VIEW.t</code> is simply an Irmin <code>DB.View.t</code>. All that remains is to implement
<code>read</code>, <code>list</code>, <code>write</code>, <code>rm</code> by</p>
<ol>
<li>mapping Xenstore <code>Protocol.Path.t</code> values onto Irmin keys; and
</li>
<li>mapping Xenstore <code>Node.contents</code> records onto Irmin values.
</li>
</ol>
<p>As it happens Xenstore and Irmin have similar notions of &quot;paths&quot; so the first mapping is
easy. We currently use <a href="https://github.com/janestreet/sexplib">sexplib</a> to map Node.contents
values onto strings for Irmin.</p>
<p>The resulting <a href="https://github.com/mirage/ocaml-xenstore-server/blob/blog/introducing-irmin-in-xenstore/userspace/main.ml#L101">Irmin glue module</a> looks like:</p>
<pre><code>    let module V = struct
      type t = DB.View.t
      let create = DB.View.create
      let write t path contents =
        DB.View.update t (value_of_filename path) (Sexp.to_string (Node.sexp_of_contents contents))
      (* omit read,list,write,rm for brevity *)
      let merge t origin =
        let origin = IrminOrigin.create &quot;%s&quot; origin in
        DB.View.merge_path ~origin db [] t &gt;&gt;= function
        | `Ok () -&gt; return true
        | `Conflict msg -&gt;
          info &quot;Conflict while merging database view: %s&quot; msg;
          return false
    end in
</code></pre>
<p>The <code>write</code> function simply calls through to Irmin's <code>update</code> function, while the <code>merge</code> function
calls Irmin's <code>merge_path</code>. If Irmin cannot merge the transaction then our <code>merge</code> function will
return <code>false</code> and this will be signalled to the client, which is expected to retry the high-level
operation (e.g. hotplugging or unplugging a device).</p>
<p>Now all that remains is to carefully adjust the I/O code so that effects (reading and writing packets
along the persistent connections) are interleaved properly with persisted state changes and
voilà, we now have a xenstore which can recover after a restart.</p>
<h3>Easy system debugging with Git</h3>
<p>When something goes wrong on a Xen system it's standard procedure to</p>
<ol>
<li>take a snapshot of the current state of Xenstore; and
</li>
<li>examine the log files for signs of trouble.
</li>
</ol>
<p>Unfortunately by the
time this is done, interesting Xenstore state has usually been deleted. Unfortunately the first task
of the human operator is to evaluate by-hand the logged actions in reverse to figure out what the state
actually was when the problem happened. Obviously this is tedious, error-prone and not always
possible since the log statements are ad-hoc and don't always include the data you need to know.</p>
<p>In the new Irmin-powered Xenstore the history is preserved in a git-format repository, and can
be explored using your favourite git viewing tool. Each store
update has a compact one-line summary, a more verbose multi-line explanation and (of course)
the full state change is available on demand.</p>
<p>For example you can view the history in a highly-summarised form with:</p>
<pre><code class="language-console">$ git log --pretty=oneline --abbrev-commit --graph
* 2578013 Closing connection -1 to domain 0
* d4728ba Domain 0: rm /bench/local/domain/0/backend/vbd/10 = ()
* 4b55c99 Domain 0: directory /bench/local/domain/0/backend = [ vbd ]
* a71a903 Domain 0: rm /bench/local/domain/10 = ()
* f267b31 Domain 0: rm /bench/vss/uuid-10 = ()
* 94df8ce Domain 0: rm /bench/vm/uuid-10 = ()
* 0abe6b0 Domain 0: directory /bench/vm/uuid-10/domains = [  ]
* 06ddd3b Domain 0: rm /bench/vm/uuid-10/domains/10 = ()
* 1be2633 Domain 0: read /bench/local/domain/10/vss = /bench/vss/uuid-10
* 237a8e4 Domain 0: read /bench/local/domain/10/vm = /bench/vm/uuid-10
* 49d70f6 Domain 0: directory /bench/local/domain/10/device = [  ]
*   ebf4935 Merge view to /
|\\
| * e9afd9f Domain 0: read /bench/local/domain/10 =
* | c4e0fa6 Domain 0: merging transaction 375
|/
</code></pre>
<p>The summarised form shows both individual operations as well as isolated transactions which
are represented as git branches.
You can then 'zoom in' and show the exact state change with commands like:</p>
<pre><code>$ git show bd44e03
commit bd44e0388696380cafd048eac49474f68d41bd3a
Author: 448 &lt;irminsule@openmirage.org&gt;
Date:   Thu Jan 1 00:09:26 1970 +0000

    Domain 0: merging transaction 363

diff --git a/*0/bench.dir/local.dir/domain.dir/7.dir/control.dir/shutdown.value b/*0/bench.dir/local.dir/domain.dir/7.dir/control.dir/shutdown.value
new file mode 100644
index 0000000..aa38106
--- /dev/null
+++ b/*0/bench.dir/local.dir/domain.dir/7.dir/control.dir/shutdown.value
@@ -0,0 +1 @@
+((creator 0)(perms((owner 7)(other NONE)(acl())))(value halt))
</code></pre>
<p>Last but not least, you can <code>git checkout</code> to the exact time the problem occurred and examine
the state of the store.</p>
<h3>Going really fast</h3>
<p>Xenstore is part of the control-plane of a Xen system and is most heavily stressed when lots
of VMs are being started in parallel. Each VM has multiple devices and each device is added in a
separate transaction. These transactions remain open for multiple client-server round-trips, as
each individual operation is sent to Xenstore as a separate RPC.
To provide isolation, each Xenstore transaction is represented by an Irmin <code>VIEW.t</code> which
is persisted on disk as a git branch.
When starting lots of VMs in
parallel, lots of branches are created and must be merged back together. If a branch cannot
be merged then an abort signal is sent to the client and it must retry.</p>
<p>Earlier versions of Xenstore had naive transaction merging algorithms
which aborted many of these transactions, causing the clients to re-issue them.This led to a live-lock
where clients were constantly reissuing the same transactions again and again.</p>
<p>Happily Irmin's default merging strategy is much better: by default Irmin
records the results of every operation and replays the operations on merge
(similar to <code>git rebase</code>). Irmin will only generate a <code>Conflict</code> and signal an
abort if the client would now see different results to those it has already
received (imagine reading a key twice within an isolated transaction and seeing
two different values). In the case of parallel VM starts, the keys are disjoint
by construction so all transactions are merged trivially; clients never receive
abort signals; and therefore the system makes steady, predictable progress
starting the VMs.</p>
<h3>Trying it out</h3>
<p>The Irmin Xenstore is under <a href="https://github.com/mirage/ocaml-xenstore-server">active development</a>
but you can try it by:</p>
<p>Install basic development tools along with the xen headers and xenstore tools (NB you don't
actually have to run Xen):</p>
<pre><code>  sudo apt-get install libxen-dev xenstore-utils opam build-essential m4
</code></pre>
<p>Initialise opam (if you haven't already). Make sure you have OCaml 4.01:</p>
<pre><code>  opam init
  opam update
  opam switch 4.01.0
</code></pre>
<p>Install the OCaml build dependencies:</p>
<pre><code>  opam install lwt irmin git sexplib cstruct uri sexplib cmdliner xen-evtchn shared-memory-ring io-page ounit
</code></pre>
<p>Clone the code and build it:</p>
<pre><code>  git clone git://github.com/mirage/ocaml-xenstore-server
  cd ocaml-xenstore-server
  make
</code></pre>
<p>Run a server (as a regular user):</p>
<pre><code>  ./main.native --database /tmp/db --enable-unix --path /tmp/xenstored
</code></pre>
<p>In a separate terminal, perform some operations:</p>
<pre><code>  export XENSTORED_PATH=/tmp/xenstored
  xenstore-write -s /one/two/three 4 /five/six/seven 8
  xenstore-ls -s /
</code></pre>
<p>Next check out the git repo generated by Irmin:</p>
<pre><code>  cd /tmp/db
  git log
</code></pre>
<p>Comments and/or contributions are welcome: join the <a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">Mirage email list</a> and say hi!</p>
|js};
      };
      {
        updated = {js|2014-07-18 13:00|js};
        authors =
          [
            {
              name = {js|Thomas Gazagnaire|js};
              uri = Some {js|http://gazagnaire.org|js};
              email = Some {js|thomas@gazagnaire.org|js};
            };
          ];
        subject =
          {js|Introducing Irmin: Git-like distributed, branchable storage|js};
        permalink = {js|introducing-irmin|js};
        body =
          {js|<blockquote>
<p>This is the first post in a series which will describe <a href="https://github.com/mirage/irmin">Irmin</a>,
the new Git-like storage layer for Mirage OS 2.0. This post gives a
high-level description on Irmin and its overall architecture, and
later posts will detail how to use Irmin in real systems.</p>
</blockquote>
<p><a href="https://github.com/mirage/irmin">Irmin</a> is a library to persist and synchronize distributed
data structures both on-disk and in-memory. It enables a style of
programming very similar to the <a href="http://git-scm.com/">Git</a> workflow, where
distributed nodes fork, fetch, merge and push data between
each other. The general idea is that you want every active node to
get a local (partial) copy of a global database and always be very
explicit about how and when data is shared and migrated.</p>
<p>Irmin is <em>not</em>, strictly speaking, a full database engine. It
is, as are all other components of Mirage OS, a collection of
libraries designed to solve different flavours of the challenges raised
by the <a href="http://en.wikipedia.org/wiki/CAP_theorem">CAP theorem</a>. Each application can select the right
combination of libraries to solve its particular distributed problem. More
precisely, Irmin consists of a core of well-defined low-level
data structures that specify how data should be persisted
and be shared across nodes. It defines algorithms for efficient
synchronization of those distributed low-level constructs. It also
builds a collection of higher-level data structures, like persistent
<a href="https://github.com/mirage/merge-queues">mergeable queues</a>, that can be used by developers without
having to know precisely how Irmin works underneath.</p>
<p>Since it's a part of Mirage OS, Irmin does not make strong assumptions about the
OS environment that it runs in. This makes the system very portable, and the
details below hold for in-memory databases as well as for slower persistent
serialization such as SSDs, hard drives, web browser local storage, or even
the Git file format.</p>
<h3>Persistent Data Structures</h3>
<p>Persistent data structures are well known and used pervasively in many
different areas. The programming language community has
investigated the concepts <a href="https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf">widely</a> (and this is <a href="http://en.wikipedia.org/wiki/Object_copy">not
limited</a> to functional programming), and in the meantime,
the systems community experimented with various persistent
strategies such as <a href="http://en.wikipedia.org/wiki/Copy-on-write">copy-on-write</a> filesystems. In most of these
systems, the main concern is how to optimize the space complexity by
maximizing the sharing of immutable sub-structures.</p>
<p>The Irmin design ideas share roots with previous works on persistent data
structures, as it provides an efficient way to <em>fork</em> data structures,
but it also explores new strategies and mechanisms to be able to
efficiently <em>merge</em> back these forked structures. This offers
programming constructs very similar to the Git workflow.</p>
<p>Irmin focuses on two main aspects:</p>
<ul>
<li>
<p><strong>Semantics</strong>: what properties the resulting merged objects should
verify.</p>
</li>
<li>
<p><strong>Complexity</strong>: how to design efficient merge and synchronization
primitives, taking advantage of the immutable nature of the underlying
objects.</p>
</li>
</ul>
<p>Although it is pervasively used, <em>data persistence</em> has a very broad and
fuzzy meaning. In this blog post, I will refer to data persistence as
a way for:</p>
<ul>
<li>
<p>a single process to lazily populate a process memory on startup.
You need this when you want the process to be able to resume while
holding part of its previous state if it crashes</p>
</li>
<li>
<p>concurrent processes to share references between objects living in
a global pool of data. Sharing references, as opposed to sharing
values, reduces memory copies and allow different processes to
concurrently update a shared store.</p>
</li>
</ul>
<p>In both cases, you need a global pool of data (the Irmin <em>block store</em>)
and a way to name values in that pool (the Irmin <em>tag store</em>).</p>
<h3>The Block Store: a Virtual Heap</h3>
<p>Even high-level data structures need to be allocated in memory, and it
is the purpose of the runtime to map such high-level constructs into
low-level memory graph blocks. One of the strengths of <a href="http://ocaml.org">OCaml</a>
is the very simple and deterministic mapping from high-level data
structures to low-level block representations (the <em>heap</em>): see for
instance, the excellent series of blog posts on <a href="http://rwmj.wordpress.com/2009/08/04/ocaml-internals/">OCaml
internals</a> by Richard W. Jones, or
<a href="https://realworldocaml.org/v1/en/html/memory-representation-of-values.html">Chapter 20: Memory Representation of Values</a> in
<a href="https://realworldocaml.org">Real World OCaml</a>.</p>
<p>An Irmin <em>block store</em> can be seen as a virtual OCaml heap that uses a more
abstract way of connecting heap blocks. Instead of using the concrete physical
memory addresses of blocks, Irmin uses the hash of the block contents as an
address. As for any <a href="http://en.wikipedia.org/wiki/Content-addressable_storage">content-addressable storage</a>, this gives Irmin
block stores a lot of nice properties and greatly simplifies the way distributed
stores can be synchronized.</p>
<p><em>Persistent</em> data structures are immutable, and once a block is created in
the block store, its contents will never change again.
Updating an immutable data structure means returning a completely new
structure, while trying to share common sub-parts to avoid the cost of
making new allocations as much as possible. For instance, modifying a
value in a persistent tree means creating a chain of new blocks, from
the root of the tree to the modified leaf.
For convenience, Irmin only considers acyclic block graphs --
it is difficult in a non-lazy pure language to generate complex cyclic
values with reasonable space usage.</p>
<p>Conceptually, an Irmin block store has the following signature:</p>
<pre><code class="language-ocaml">type t
(** The type for Irmin block store. *)

type key
(** The type for Irmin pointers *)

type value = ...
(** The type for Irmin blocks *)

val read: t -&gt; key -&gt; value option
(** [read t k] is the block stored at the location [k] of the
store. It is [None] if no block is available at that location. *)

val add: t -&gt; key -&gt; value -&gt; t
(** [add t k v] is the *new* store storing the block [v] at the
location [k]. *)
</code></pre>
<p>Persistent data structures are very efficient to store in memory and on
disk as you do not need <a href="http://en.wikipedia.org/wiki/Write_barrier">write barriers</a>, and updates
can be written <a href="http://en.wikipedia.org/wiki/Write_amplification#Sequential_writes">sequentially</a> instead of requiring random
access into the data structure.</p>
<h3>The Tag Store: Controlled Mutability and Concurrency</h3>
<p>So far, we have only discussed purely functional data structures,
where updating a structure means returning a pointer to a new
structure in the heap that shares most of its contents with the previous
one. This style of programming is appealing when implementing
<a href="https://mirage.io/blog/ocaml-tls-api-internals-attacks-mitigation">complex protocols</a> as it leads to better compositional properties.</p>
<img src="/graphics/irmin-stores.png" alt="Irmin Stores" style="float:right; border: 5px" width="250px" />
<p>However, this makes sharing information between processes much more
difficult, as you need a way to &quot;inject&quot; the state of one structure into another process's memory. In order to do so, Irmin borrows the concept of
<em>branches</em> from Git by relating every operation to a branch name, and
modifying the tip of the branch if it has side-effects.
The Irmin <em>tag store</em> is the only mutable part of the whole system and
is responsible for mapping some global (branch) names to blocks in the
block store. These tag names can then be used to pass block references between
different processes.</p>
<p>A block store and a tag store can be combined to build
a higher-level store (the Irmin store) with fine concurrency control
and atomicity guarantees. As mutation happens only in the tag store,
we can ensure that as long a given tag is not updated, no change made
in the block store will be visible by anyone. This also gives a nice
story for concurrency: as in Git, creating a concurrent view of the
store is the straightforward operation of creating a new tag that
denotes a new branch. All concurrent operations can then happen on
different branches:</p>
<pre><code class="language-ocaml">type t
(** The type for Irmin store. *)

type tag
(** Mutable tags *)

type key = ...
(** The type for user-defined keys (for instance a list of strings) *)

type value = ...
(** The type for user-defined values *)

val read: t -&gt; ?branch:tag -&gt; key -&gt; value option
(** [read t ?branch k] reads the contents of the key [k] in the branch
[branch] of the store [t]. If no branch is specified, then use the
[&quot;HEAD&quot;] one. *)

val update: t -&gt; ?branch:tag -&gt; key -&gt; value -&gt; unit
(** [update t ?branch k v] *updates* the branch [branch] of the store
[t] the association of the key [key] to the value [value]. *)
</code></pre>
<p>Interactions between concurrent processes are completely explicit and
need to happen via synchronization points and merge events (more on
this below). It is also possible to emulate the behaviour of
transactions by recording the sequence of operations (<code>read</code> and
<code>update</code>) on a given branch -- that sequence is used before a merge
to check that all the operations are valid (i.e. that all reads in the
transaction still return the same result on the current tip of the
store) and it can be discarded after the merge takes place.</p>
<h3>Merging Data Structures</h3>
<p>To merge two data structures in a consistent way, one has to compute
the sequence of operations which leads, from an initial common state, to two
diverging states (the ones that you want to merge). Once these two
sequences of operations have been found, they must be combined (if
possible) in a sensible way and then applied again back on the initial
state, in order to get the new merged state. This mechanism sounds
nice, but in practice it has two major drawbacks:</p>
<ul>
<li>It does not specify how we find the initial state from two diverging
states -- this is generally not possible (think of diverging
counters); and
</li>
<li>It means we need to compute the sequence of <code>update</code> operations
that leads from one state to an other.  This is easier than finding
the common initial state between two branches, but is still generally
not very efficient.
</li>
</ul>
<p>In Irmin, we solve these problems using two mechanisms.</p>
<p>First of all, an interesting observation is that that we can model the
sequence of store tips as a purely functional data-structure. We model
the partial order of tips as a directed acyclic graph where nodes are
the tips, and there is an edge between two tips if either <em>(i)</em> one is
the result of applying a sequence of <code>update</code>s to the other, or <em>(ii)</em>
one is the result of a merge operation between the other and some
other tips. Practically speaking, that means that every tip should
contains the list of its predecessors as well as the actual data it
associated to. As it is purely functional, we can (and we do) store
that graph in an Irmin block store.</p>
<img src="/graphics/irmin-merge.png" alt="Finding a common ancestor" style="float:right; border:5px" width="150px" />
<p>Having a persistent and immutable history is good for various obvious
reasons, such as access to a forensics if an error occurs or
snapshot and rollback features for free. But another less obvious
useful property is that we can now find the greatest common
ancestors of two data structures without an expensive global search.</p>
<p>The second mechanism is that we require the data structures used in
Irmin to be equipped with a well-defined 3-way merge operation, which
takes two diverging states, the corresponding initial state (computed
using the previous mechanism) and that return either a new state or a
conflict (similar to the <code>EAGAIN</code> exception that you get when you try
to commit a conflicting transaction in more traditional transactional
databases). Having access to the common ancestors makes a great
difference when designing new merge functions, as usually no
modification is required to the data-structure itself. In contrast,
the conventional approach is more invasive as it requires the data
structure to carry more information about the operation history
(for instance <a href="http://hal.upmc.fr/docs/00/55/55/88/PDF/techreport.pdf">conflict-free replicated
datatypes</a>, which relies on unbounded vector clocks).</p>
<p>We have thus been designing interesting data structure equipped with a 3-way
merge, such as counters, <a href="https://github.com/mirage/merge-queues">queues</a> and ropes.</p>
<p>This is what the implementation of distributed and mergeable counters
looks like:</p>
<pre><code class="language-ocaml">type t = int
(** distributed counters are just normal integers! *)

let merge ~old t1 t2 = old + (t1-old) + (t2-old)
(** Merging counters means:
   - computing the increments of the two states [t1] and [t2]
     relatively to the initial state [old]; and
   - and add these two increments to [old]. *)
</code></pre>
<h3>Next steps, how to git at your data</h3>
<p>From a design perspective, having access to the history makes it easier to
design complex data structures with good compositional properties to use in
unikernels. Moreover, as we made few assumptions on how the substrate of the
low-level constructs need to be implemented, the Irmin engine can be be ported
to many exotic backends such as JavaScript or anywhere else that Mirage OS
runs: this is just a matter of implementing a rather trivial
<a href="https://github.com/mirage/irmin/blob/4b06467ddee1e20c35bad64812769587fb9fa8a4/lib/core/irminStore.mli#L61">signature</a>.</p>
<p>From a developer perspective, this means that the full history of operations is
available to inspect, and that the history model is very similar to the Git
workflow that is increasingly familiar. So similar, in fact, that we've
developed a bidirectional mapping between Irmin data structures and the Git
format to permit the <code>git</code> command-line to interact with.</p>
<p>The <a href="https://mirage.io/blog/introducing-irmin-in-xenstore">next post in our series</a> explains what <a href="http://dave.recoil.org/">Dave Scott</a> has been doing
with the new version of the <a href="http://wiki.xen.org/wiki/XenStoreReference">Xenstore</a> database that powers every Xen host,
where the entire database is stored in a prefix-tree Irmin data-structure and exposed
as a Git repository which is live-updated!  Here's a sneak preview...</p>
<div class="flex-video">
  <iframe width="480" height="360" src="//www.youtube-nocookie.com/embed/DSzvFwIVm5s" frameborder="0" allowfullscreen="1"></iframe>
</div>
|js};
      };
      {
        updated = {js|2014-07-17 13:00|js};
        authors =
          [
            {
              name = {js|Mindy Preston|js};
              uri = Some {js|https://github.com/yomimono|js};
              email = Some {js|mindy.preston@cl.cam.ac.uk|js};
            };
          ];
        subject = {js|Fitting the modular MirageOS TCP/IP stack together|js};
        permalink = {js|intro-tcpip|js};
        body =
          {js|<p>A critical part of any unikernel is its network stack -- it's difficult to
think of a project that needs a cloud platform or runs on a set-top box with no
network communications.</p>
<p>Mirage provides a number of <a href="https://github.com/mirage/mirage/tree/master/types">module
types</a> that abstract
interfaces at different layers of the network stack, allowing unikernels to
customise their own stack based on their deployment needs. Depending on the
abstractions your unikernel uses, you can fulfill these abstract interfaces
with implementations ranging from the venerable and much-imitated Unix sockets
API to a clean-slate Mirage <a href="https://github.com/mirage/mirage-tcpip">TCP/IP
stack</a> written from the ground up in
pure OCaml!</p>
<p>A Mirage unikernel will not use <em>all</em> these interfaces, but will pick those that
are appropriate for the particular application at hand. If your unikernel just
needs a standard TCP/IP stack, the <code>STACKV4</code> abstraction will be sufficient.
However, if you want more control over the implementation of the different
layers in the stack or you don't need TCP support, you might construct your
stack by hand using just the <a href="https://github.com/mirage/mirage/blob/8b59fbf0b223b3c5c70d4939b5674ecdd7521804/types/V1.mli#L263">NETWORK</a>, <a href="https://github.com/mirage/mirage/blob/8b59fbf0b223b3c5c70d4939b5674ecdd7521804/types/V1.mli#L316">ETHIF</a>, <a href="https://github.com/mirage/mirage/blob/8b59fbf0b223b3c5c70d4939b5674ecdd7521804/types/V1.mli#L368">IPV4</a> and <a href="https://github.com/mirage/mirage/blob/8b59fbf0b223b3c5c70d4939b5674ecdd7521804/types/V1.mli#L457">UDPV4</a> interfaces.</p>
<h2>How a Stack Looks to a Mirage Application</h2>
<p>Mirage provides a high-level interface to a TCP/IP network stack through the module type
<a href="https://github.com/mirage/mirage/blob/8b59fbf0b223b3c5c70d4939b5674ecdd7521804/types/V1.mli#L581">STACKV4</a>.
(Currently this can be included with <code>open V1_LWT</code>, but soon <code>open V2_LWT</code> will also bring this module type into scope as well when Mirage 2.0 is released.)</p>
<pre><code class="language-OCaml">(** Single network stack *)                                                     
module type STACKV4 = STACKV4                                                   
  with type 'a io = 'a Lwt.t                                                    
   and type ('a,'b,'c) config = ('a,'b,'c) stackv4_config                       
   and type ipv4addr = Ipaddr.V4.t                                              
   and type buffer = Cstruct.t 
</code></pre>
<p><code>STACKV4</code> has useful high-level functions, a subset of which are reproduced below:</p>
<pre><code class="language-OCaml">    val listen_udpv4 : t -&gt; port:int -&gt; UDPV4.callback -&gt; unit
    val listen_tcpv4 : t -&gt; port:int -&gt; TCPV4.callback -&gt; unit
    val listen : t -&gt; unit io
</code></pre>
<p>as well as submodules that include functions for data transmission:</p>
<pre><code class="language-OCaml">    module UDPV4 :
      sig
        type callback =
            src:ipv4addr -&gt; dst:ipv4addr -&gt; src_port:int -&gt; buffer -&gt; unit io
        val input :
          listeners:(dst_port:int -&gt; callback option) -&gt; t -&gt; ipv4input
        val write :
          ?source_port:int -&gt;
          dest_ip:ipv4addr -&gt; dest_port:int -&gt; t -&gt; buffer -&gt; unit io
</code></pre>
<pre><code class="language-OCaml">    module TCPV4 :
      sig
        type flow
        type callback = flow -&gt; unit io
        val read : flow -&gt; [ `Eof | `Error of error | `Ok of buffer ] io
        val write : flow -&gt; buffer -&gt; unit io
        val close : flow -&gt; unit io
        val create_connection :
          t -&gt; ipv4addr * int -&gt; [ `Error of error | `Ok of flow ] io
        val input : t -&gt; listeners:(int -&gt; callback option) -&gt; ipv4input
</code></pre>
<p>These should look rather familiar if you've used the Unix sockets
API before, with one notable difference: the stack accepts functional
callbacks to react to events such as a new connection request.  This
permits callers of the library to define the precise datastructures that
are used to store intermediate state (such as active connections).
This becomes important when building very scalable systems that have
to deal with <a href="https://en.wikipedia.org/wiki/C10k_problem">lots of concurrent connections</a>
efficiently.</p>
<h2>Configuring a Stack</h2>
<p>The <code>STACKV4</code> signature shown so far is just a module signature, and you
need to find a concrete module that satisfies that signature.  The known
implementations of a module can be found in the <code>mirage</code> CLI frontend,
which provids the <a href="https://github.com/mirage/mirage/blob/8b59fbf0b223b3c5c70d4939b5674ecdd7521804/lib/mirage.mli#L266">configuration API</a> for unikernels.<br />
There are currently two implementations for <code>STACKV4</code>: <code>direct</code> and <code>socket</code>.</p>
<pre><code class="language-OCaml">module STACKV4_direct: CONFIGURABLE with                                        
  type t = console impl * network impl * [`DHCP | `IPV4 of ipv4_config]         
                                                                                
module STACKV4_socket: CONFIGURABLE with                                        
  type t = console impl * Ipaddr.V4.t list  
</code></pre>
<p>The <code>socket</code> implementations rely on an underlying OS kernel to provide the
transport, network, and data link layers, and therefore can't be used for a Xen
guest VM deployment.  Currently, the only way to use <code>socket</code> is by configuring
your Mirage project for Unix with <code>mirage configure --unix</code>.  This is the mode
you will most often use when developing high-level application logic that doesn't
need to delve into the innards of the network stack (e.g. a REST website).</p>
<p>The <code>direct</code> implementations use the <a href="https://github.com/mirage/mirage-tcpip">mirage-tcpip</a> implementations of the
transport, network, and data link layers.  When you use this stack, all the network
traffic from the Ethernet level up will be handled in pure OCaml.  This means that the
<code>direct</code> stack will work with either a Xen
guest VM (provided there's a valid network configuration for the unikernel's
running environment of course), or a Unix program if there's a valid <a href="https://en.wikipedia.org/wiki/TUN/TAP">tuntap</a> interface.
<code>direct</code> this works with both <code>mirage configure --xen</code> and <code>mirage configure --unix</code>
as long as there is a corresponding available device when the unikernel is run.</p>
<p>There are a few Mirage functions that provide IPv4 (and UDP/TCP) stack
implementations (of type <code>stackv4 impl</code>), usable from your application code.
The <code>stackv4 impl</code> is generated in <code>config.ml</code> by some logic set when the
program is <code>mirage configure</code>'d - often by matching an environment variable.
This means it's easy to flip between different stack implementations when
developing an application just be recompiling the application.  The <code>config.ml</code>
below allows the developer to build socket code with <code>NET=socket make</code> and
direct code with <code>NET=direct make</code>.</p>
<pre><code class="language-OCaml">let main = foreign &quot;Services.Main&quot; (console @-&gt; stackv4 @-&gt; job)

let net =
  try match Sys.getenv &quot;NET&quot; with
    | &quot;direct&quot; -&gt; `Direct
    | &quot;socket&quot; -&gt; `Socket
    | _        -&gt; `Direct
  with Not_found -&gt; `Direct

let dhcp =
  try match Sys.getenv &quot;ADDR&quot; with
    | &quot;dhcp&quot;   -&gt; `Dhcp
    | &quot;static&quot; -&gt; `Static
    | _ -&gt; `Dhcp
  with Not_found -&gt; `Dhcp

let stack console =
  match net, dhcp with
  | `Direct, `Dhcp   -&gt; direct_stackv4_with_dhcp console tap0
  | `Direct, `Static -&gt; direct_stackv4_with_default_ipv4 console tap0
  | `Socket, _       -&gt; socket_stackv4 console [Ipaddr.V4.any]

let () =
  register &quot;services&quot; [
    main $ default_console $ stack default_console
  ]
</code></pre>
<p>Moreover, it's possible to configure multiple stacks individually for use in
the same program, and to <code>register</code> multiple modules from the same <code>config.ml</code>.
This means functions can be written such that they're aware of the network
stack they ought to be using, and no other - a far cry from developing network
code over most socket interfaces, where it can be quite difficult to separate
concerns nicely.</p>
<pre><code class="language-OCaml">let client = foreign &quot;Unikernel.Client&quot; (console @-&gt; stackv4 @-&gt; job)
let server = foreign &quot;Unikernel.Server&quot; (console @-&gt; stackv4 @-&gt; job) 

let client_netif = (netif &quot;0&quot;)
let server_netif = (netif &quot;1&quot;) 

let client_stack = direct_stackv4_with_dhcp default_console client_netif
let server_stack = direct_stackv4_with_dhcp default_console server_netif

let () = 
  register &quot;unikernel&quot; [
    main $ default_console $ client_stack;
    server $ default_console $ server_stack 
  ]

</code></pre>
<h2>Acting on Stacks</h2>
<p>Most network applications will either want to listen for incoming connections
and respond to that traffic with information, or to connect to some remote
host, execute a query, and receive information.  <code>STACKV4</code> offers simple ways
to define functions implementing either of these patterns.</p>
<h3>Establishing and Communicating Across Connections</h3>
<p><code>STACKV4</code> offers <code>listen_tcpv4</code> and <code>listen_udpv4</code> functions for establishing
listeners on specific ports.  Both take a <code>stack impl</code>, a named <code>port</code>, and a
<code>callback</code> function.</p>
<p>For UDP listeners, which are datagram-based rather than connection-based,
<code>callback</code> is a function of the source IP, destination IP, source port, and the
<code>Cstruct.t</code> that contains the payload data.  Applications that wish to respond
to incoming UDP packets with their own UDP responses (e.g., DNS servers) can
use this information to construct reply packets and send them with
<code>UDPV4.write</code> from within the callback function.</p>
<p>For TCP listeners, <code>callback</code> is a function of <code>TCPV4.flow -&gt; unit Lwt.t</code>.  <code>STACKV4.TCPV4</code> offers <code>read</code>, <code>write</code>, and <code>close</code> on <code>flow</code>s for application writers to build higher-level protocols on top of.</p>
<p><code>TCPV4</code> also offers <code>create_connection</code>, which allows client application code to establish TCP connections with remote servers.  In success cases, <code>create_connection</code> returns a <code>TCPV4.flow</code>, which can be acted on just as the data in a <code>callback</code> above.  There's also a polymorphic variant for error conditions, such as an unreachable remote server.</p>
<h3>A Simple Example</h3>
<p>Some very simple examples of user-level TCP code are included in <a href="https://github.com/mirage/mirage-tcpip/tree/master/examples">mirage-tcpip/examples</a>.  <code>config.ml</code> is identical to the first configuration example above, and will build a <code>direct</code> stack by default.</p>
<p>Imagine a very simple application - one which simply repeats any data back to the sender, until the sender gets bored and wanders off (<a href="https://en.wikipedia.org/wiki/Echo_Protocol">RFC 862</a>, for the curious).</p>
<pre><code class="language-OCaml">open Lwt
open V1_LWT

module Main (C: V1_LWT.CONSOLE) (S: V1_LWT.STACKV4) = struct
  let report_and_close c flow message =
    C.log c message;
    S.TCPV4.close flow

  let rec echo c flow =
    S.TCPV4.read flow &gt;&gt;= fun result -&gt; (
      match result with  
        | `Eof -&gt; report_and_close c flow &quot;Echo connection closure initiated.&quot;
        | `Error e -&gt; 
          let message = 
          match e with 
            | `Timeout -&gt; &quot;Echo connection timed out; closing.\\n&quot;
            | `Refused -&gt; &quot;Echo connection refused; closing.\\n&quot;
            | `Unknown s -&gt; (Printf.sprintf &quot;Echo connection error: %s\\n&quot; s)
             in
          report_and_close c flow message
        | `Ok buf -&gt;
            S.TCPV4.write flow buf &gt;&gt;= fun () -&gt; echo c flow
        ) 

  let start c s = 
    S.listen_tcpv4 s ~port:7 (echo c);
    S.listen s

end
</code></pre>
<p>All the application programmer needs to do is define functionality in relation to <code>flow</code> for sending and receiving data, establish this function as a callback with <code>listen_tcpv4</code>, and start a listening thread with <code>listen</code>.</p>
<h2>More Complex Uses</h2>
<p>An OCaml HTTP server, <a href="http://www.github.com/mirage/ocaml-cohttp">Cohttp</a>, is currently powering this very blog.  A simple static webserver using Cohttp <a href="https://github.com/mirage/mirage-skeleton/tree/master/static_website">is included in <code>mirage-skeleton</code></a>.</p>
<p><a href="https://tls.nqsb.io/">The OCaml-TLS demonstration server</a> announced here <a href="http://mirage.io/blog/introducing-ocaml-tls">just a few days ago</a> is also running atop Cohttp - <a href="https://github.com/mirleft/tls-demo-server">source is available on Github</a>.</p>
<h2>The future</h2>
<p>Mirage's TCP/IP stack is under active development!  <a href="https://github.com/mirage/mirage-tcpip/search?q=TODO&amp;ref=cmdform">Some low-level details</a> are still stubbed out, and we're working on implementing some of the trickier corners of TCP, as well as <a href="http://somerandomidiot.com/blog/2014/05/22/throwing-some-fuzzy-dice/">doing automated testing</a> on the stack.  We welcome testing tools, bug reports, bug fixes, and new protocol implementations!</p>
|js};
      };
      {
        updated = {js|2014-07-16 12:00|js};
        authors =
          [
            {
              name = {js|Jon Ludlam|js};
              uri = Some {js|http://jon.recoil.org|js};
              email = Some {js|jon@recoil.org|js};
            };
          ];
        subject = {js|Vchan: Low-latency inter-VM communication channels|js};
        permalink = {js|update-on-vchan|js};
        body =
          {js|<p><em>Today's post is an update to <a href="https://github.com/vbmithr">Vincent Bernardoff's</a>
<a href="https://mirage.io/blog/introducing-vchan">introducing vchan</a> blog
post, updated to use the modern build scheme for Mirage.</em></p>
<p>Unless you are familiar with Xen's source code, there is little chance
that you've ever heard of the <em>vchan</em> library or
protocol. Documentation about it is very scarce: a description can be
found on vchan's
<a href="http://xenbits.xen.org/gitweb/?p=xen.git;a=blob;f=xen/include/public/io/libxenvchan.h;hb=HEAD">public header file</a>,
that I quote here for convenience:</p>
<blockquote>
<p>Originally borrowed from the
<a href="http://www.qubes-os.org">Qubes OS Project</a>, this code (i.e. libvchan)
has been substantially rewritten [...]
This is a library for inter-domain communication.  A standard Xen ring
buffer is used, with a datagram-based interface built on top.  The
grant reference and event channels are shared in XenStore under a
user-specified path.</p>
</blockquote>
<p>This protocol uses shared memory for inter-domain communication,
i.e. between two VMs residing in the same Xen host, and uses Xen's
mechanisms -- more specifically,
<a href="http://www.informit.com/articles/article.aspx?p=1160234&amp;seqNum=3">ring buffers</a>
and
<a href="http://xenbits.xen.org/gitweb/?p=xen.git;a=blob;f=tools/libxc/xenctrl.h;h=f2cebafc9ddd4815ffc73fcf9e0d292b1d4c91ff;hb=HEAD#l934">event channels</a>
-- in order to achieve its aims. The term <em>datagram-based interface</em> simply
means that the
<a href="http://xenbits.xen.org/gitweb/?p=xen.git;a=blob;f=tools/libvchan/libxenvchan.h;h=6365d36a06f8c8f56454724cefc4c2f1d39beba2;hb=HEAD">interface</a>
resembles UDP, although there is support for stream based communication (like
TCP) as well.</p>
<p>The <code>vchan</code> protocol is an important feature in MirageOS 2.0 since it
forms the foundational communication mechanism for <strong>building distributed
clusters of unikernels</strong> that cooperate to solve problems that are beyond
the power of a single node.  Instead of forcing communication between
nodes via a conventional wire protocol like TCP, it permits highly efficient
low-overhead communication to nodes that are colocated on the same Xen
host machine.</p>
<p>Before diving into vchan, I thought I'd also take the opportunity to describe the
<a href="http://releases.ubuntu.com/14.04/">Ubuntu-Trusty</a> environment for developing
and running <a href="http://www.xenproject.org/">Xen</a> unikernels.</p>
<h3>Installing Xen on Ubuntu</h3>
<p>Ubuntu 14.04 has good support for running Xen 4.4, the most recent release (at time of writing).
For running VMs it's a good idea to install Ubuntu on an LVM volume rather than directly on a
partition, which allows the use of LVs as the virtual disks for your VMs. On my system I have
a 40 Gig partition for '/', an 8 Gig swap partition and the rest is free for my VMs:</p>
<pre><code class="language-console">$ sudo lvs
   LV     VG      Attr      LSize  Pool Origin Data%  Move Log Copy%  Convert
   root   st28-vg -wi-ao--- 37.25g
   swap_1 st28-vg -wi-ao---  7.99g
</code></pre>
<p>In this particular walkthough I won't be using disks, but later posts will.
Install Xen via the meta-package. This brings in all you will need to run VMs:</p>
<pre><code class="language-console">$ sudo apt-get install xen-system-amd64
</code></pre>
<p>It used to be necessary to reorder the grub entries to make sure Xen was started
by default, but this is no longer necessary. Once the machine has rebooted, you
should be able to verify you're running virtualized by invoking 'xl':</p>
<pre><code class="language-console">$ sudo xl list
Name                                        ID   Mem VCPUs      State   Time(s)
Domain-0                                     0  7958     6     r-----       9.7
</code></pre>
<p>My machine has 8 Gigs of memory, and this list shows that it's all being used by
my dom0, so I'll need to either balloon down dom0 or reboot with a lower maximum
memory. Ballooning is the most straightfoward:</p>
<pre><code class="language-console">$ sudo xenstore-write /local/domain/0/memory/target 4096000
$ sudo xl list
Name                                        ID   Mem VCPUs      State   Time(s)
Domain-0                                     0  4000     6     r-----      12.2
</code></pre>
<p>This is handy for quick testing, but is <a href="http://wiki.xenproject.org/wiki/Xen_Project_Best_Practices">discouraged</a> by the Xen folks. So alternatively, change the xen command line by
editing <code>/etc/default/grub</code> and add the line:</p>
<pre><code class="language-console">GRUB_CMDLINE_XEN_DEFAULT=&quot;dom0_mem=4096M,max:4096M&quot;
</code></pre>
<p>Once again, update-grub and reboot.</p>
<h3>Mirage</h3>
<p>Now lets get Mirage up and running. Install ocaml, opam and set up the opam environment:</p>
<pre><code class="language-console">$ sudo apt-get install ocaml opam ocaml-native-compilers camlp4-extra
...
$ opam init
...
$ eval `opam config env`
</code></pre>
<p>Don't forget the <code>ocaml-native-compilers</code>, as without this we can't
compile the unikernels. Now we are almost ready to install Mirage; we
need two more dependencies, and then we're good to go.</p>
<pre><code class="language-console">$ sudo apt-get install m4 libxen-dev
$ opam install mirage mirage-xen mirage-unix vchan
</code></pre>
<p>Where <code>m4</code> is for ocamlfind, and <code>libxen-dev</code> is required to compile the
unix variants of the <code>xen-evtchn</code> and <code>xen-gnt</code> libraries. Without these
installing vchan will complain that there is no <code>xen-evtchn.lwt</code>
library installed.</p>
<p>This second line installs the various Mirage and vchan libraries, but
doesn't build the demo unikernel and Unix CLI.  To get them, clone
the ocaml-vchan repository:</p>
<pre><code class="language-console">$ git clone https://github.com/mirage/ocaml-vchan
</code></pre>
<p>The demo unikernel is a very straightforward capitalizing echo server.
The <a href="https://github.com/mirage/ocaml-vchan/blob/master/test/echo.ml#L13">main function</a> simply consists of</p>
<pre><code class="language-ocaml">let (&gt;&gt;=) = Lwt.bind

let (&gt;&gt;|=) m f = m &gt;&gt;= function
| `Ok x -&gt; f x
| `Eof -&gt; Lwt.fail (Failure &quot;End of file&quot;)
| `Error (`Not_connected state) -&gt;
    Lwt.fail (Failure (Printf.sprintf &quot;Not in a connected state: %s&quot;
      (Sexplib.Sexp.to_string (Node.V.sexp_of_state state))))

let rec echo vch =
  Node.V.read vch &gt;&gt;|= fun input_line -&gt;
  let line = String.uppercase (Cstruct.to_string input_line) in
  let buf = Cstruct.create (String.length line) in
  Cstruct.blit_from_string line 0 buf 0 (String.length line);
  Node.V.write vch buf &gt;&gt;|= fun () -&gt;
  echo vch
</code></pre>
<p>where we've defined an error-handling monadic bind (<code>&gt;&gt;|=</code>) which
is then used to sequence the read and write operations.</p>
<p>Building the CLI is done simply via <code>make</code>.</p>
<pre><code class="language-console">$ make
...
$ ls -l node_cli.native
lrwxrwxrwx 1 jludlam jludlam 52 Jul 14 14:56 node_cli.native -&gt; /home/jludlam/ocaml-vchan/_build/cli/node_cli.native
</code></pre>
<p>Building the unikernel is done via the <code>mirage</code> tool:</p>
<pre><code class="language-console">$ cd test
$ mirage configure --xen
...
$ make depend
...
$ make
...
$ ls -l mir-echo.xen echo.xl
-rw-rw-r-- 1 jludlam jludlam     596 Jul 14 14:58 echo.xl
-rwxrwxr-x 1 jludlam jludlam 3803982 Jul 14 14:59 mir-echo.xen
</code></pre>
<p>This make both the unikernel binary (the mir-echo.xen file) and a convenient
xl script to run it. To run, we use the xl tool, passing '-c' to connect
directly to the console so we can see what's going on:</p>
<pre><code class="language-console">$ sudo xl create -c echo.xl
Parsing config from echo.xl
kernel.c: Mirage OS!
kernel.c:   start_info: 0x11cd000(VA)
kernel.c:     nr_pages: 0x10000
kernel.c:   shared_inf: 0xdf2f6000(MA)
kernel.c:      pt_base: 0x11d0000(VA)
kernel.c: nr_pt_frames: 0xd
kernel.c:     mfn_list: 0x114d000(VA)
kernel.c:    mod_start: 0x0(VA)
kernel.c:      mod_len: 0
kernel.c:        flags: 0x0
kernel.c:     cmd_line:
x86_setup.c:   stack:      0x144f40-0x944f40
mm.c: MM: Init
x86_mm.c:       _text: 0x0(VA)
x86_mm.c:      _etext: 0xb8eec(VA)
x86_mm.c:    _erodata: 0xde000(VA)
x86_mm.c:      _edata: 0x1336f0(VA)
x86_mm.c: stack start: 0x144f40(VA)
x86_mm.c:        _end: 0x114d000(VA)
x86_mm.c:   start_pfn: 11e0
x86_mm.c:     max_pfn: 10000
x86_mm.c: Mapping memory range 0x1400000 - 0x10000000
x86_mm.c: setting 0x0-0xde000 readonly
x86_mm.c: skipped 0x1000
mm.c: MM: Initialise page allocator for 0x1256000 -&gt; 0x10000000
mm.c: MM: done
x86_mm.c: Pages to allocate for p2m map: 2
x86_mm.c: Used 2 pages for map
x86_mm.c: Demand map pfns at 10001000-2010001000.
Initialising timer interface
Initializing Server domid=0 xs_path=data/vchan
gnttab_stubs.c: gnttab_table mapped at 0x10001000
Server: right_order = 13, left_order = 13
allocate_buffer_locations: gntref = 9
allocate_buffer_locations: gntref = 10
allocate_buffer_locations: gntref = 11
allocate_buffer_locations: gntref = 12
Writing config into the XenStore
Shared page is:

00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0d 00 0d 00 02 01 01 00 09 00 00 00 0a 00 00 00
0b 00 00 00 0c 00 00 00
Initialization done!
</code></pre>
<p>Vchan is domain-to-domain communication, and relies on Xen's grant
tables to share the memory. The entries in the grant tables have
domain-level access control, so we need to know the domain ID of the
client and server in order to set up the communications. The test
unikernel server is hard-coded to talk to domain 0, so we only need to
know the domain ID of our echo server. In another terminal,</p>
<pre><code class="language-console">$ sudo xl list
Name                                        ID   Mem VCPUs      State   Time(s)
Domain-0                                     0  4095     6     r-----    1602.9
echo                                         2   256     1     -b----       0.0
</code></pre>
<p>In this case, the domain ID is 2, so we invoke the CLI as follows:</p>
<pre><code class="language-console">$ sudo ./node_cli.native 2
Client initializing: Received gntref = 8, evtchn = 4
Mapped the ring shared page:

00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0d 00 0d 00 02 01 01 00 09 00 00 00 0a 00 00 00
0b 00 00 00 0c 00 00 00
Correctly bound evtchn number 71
</code></pre>
<p>We're now connected via vchan to the Mirage domain. The test server
is simply a capitalisation service:</p>
<pre><code class="language-console">hello from dom0
HELLO FROM DOM0
</code></pre>
<p>Ctrl-C to get out of the CLI, and destroy the domain with an <code>xl destroy</code>:</p>
<pre><code class="language-console">$ sudo xl destroy test
</code></pre>
<p><code>vchan</code> is a very low-level communication mechanism, and so our next post on
this topic will address how to use it in combination with a name resolver
to intelligently map connection requests to use <code>vchan</code> if available, and
otherwise fall back to normal TCP or TCP+TLS.</p>
|js};
      };
      {
        updated = {js|2014-07-15 12:00|js};
        authors =
          [
            {
              name = {js|Jeremy Yallop|js};
              uri = Some {js|https://github.com/yallop|js};
              email = Some {js|jeremy.yallop@cl.cam.ac.uk|js};
            };
          ];
        subject = {js|Modular foreign function bindings|js};
        permalink = {js|modular-foreign-function-bindings|js};
        body =
          {js|<p>One of the most frequent questions about MirageOS from developers is
&quot;do I really need to write all my code in OCaml&quot;?  There are, of
course, very good reasons to build the core system in pure OCaml: the
module system permits reusing algorithmic abstractions at scale, and
OCaml's static type checking makes it possible to enforce lightweight
invariants across interfaces.  However, it's ultimately necessary to
support interfacing to existing code, and this blog post will describe
what we're doing to make this possible this without sacrificing the
security benefits afforded by unikernels.</p>
<p>A MirageOS application works by abstracting the <em>logic</em> of the
application from the details of <em>platform</em> that it is compiled for.
The <code>mirage</code> CLI tool parses a configuration file that represents the
desired hardware target, which can be a Unix binary or a specialized
Xen guest OS.  Our foreign function interface design elaborates on
these design principles by separating the <em>description</em> of the C
foreign functions from how we <em>link</em> to that code.  For instance, a
Unix unikernel could use the normal <code>ld.so</code> to connect to a shared
library, while in Xen we would need to interface to that C library
through some other mechanism (for instance, a separate VM could be
spawned to run the untrusted OpenSSL code).  If you're curious about
how this works, this blog post is for you!</p>
<h3>Introducing ctypes</h3>
<p><a href="https://github.com/ocamllabs/ocaml-ctypes">ocaml-ctypes</a> (&quot;ctypes&quot; for short) is a library for
gluing together OCaml code and C code without writing any C.  This
post introduces the ctypes library with a couple of simple examples,
and outlines how OCaml's module system makes it possible to write
high-level bindings to C that are independent of any particular
linking mechanism.</p>
<h3>Hello, C</h3>
<p>Binding a C function using ctypes involves two steps.</p>
<ul>
<li>First, construct an OCaml value that represents the type of the function
</li>
<li>Second, use the type representation and the function name to resolve and bind the function
</li>
</ul>
<p>For example, here's a binding to C's <code>puts</code> function, which prints a string to
standard output and returns the number of characters written:</p>
<pre><code class="language-ocaml">let puts = foreign &quot;puts&quot; (string @-&gt; returning int)
</code></pre>
<p>After the call to <code>foreign</code> the bound function is available to OCaml
immediately.  Here's a call to <code>puts</code> from the interactive top level:</p>
<pre><code class="language-ocaml"># puts &quot;Hello, world&quot;;;
Hello, world
- : int = 13
</code></pre>
<h3>&lt;Hello-C/&gt;</h3>
<p>Now that we've had a taste of ctypes, let's look at a more realistic
example: a program that defines bindings to the <a href="http://www.libexpat.org/">expat</a> XML
parsing library, then uses them to display the structure of an XML
document.</p>
<p>We'll start by describing the types used by expat.  Since ctypes
represents C types as OCaml values, each of the types we need becomes
a value binding in our OCaml program.  The parser object involves an
incomplete (abstract) struct definition and a typedef for a pointer to
a struct:</p>
<pre><code class="language-C">struct xml_ParserStruct;
typedef xml_ParserStruct *xml_Parser;
</code></pre>
<p>In ctypes these become calls to the <code>structure</code> and <code>ptr</code> functions:</p>
<pre><code class="language-ocaml">let parser_struct : [`XML_ParserStruct] structure typ = structure &quot;xml_ParserStruct&quot;
let xml_Parser = ptr parser_struct
</code></pre>
<p>Next, we'll use the type representations to bind some functions.  The
<a href="http://www.xml.com/pub/a/1999/09/expat/reference.html#parsercreate"><code>XML_ParserCreate</code></a>
and
<a href="http://www.xml.com/pub/a/1999/09/expat/reference.html#parserfree"><code>XML_ParserFree</code></a>
functions construct and destroy parser objects.  As with <code>puts</code>, each
function binding involves a simple call to <code>foreign</code>:</p>
<pre><code class="language-ocaml">let parser_create = foreign &quot;XML_ParserCreate&quot;
  (ptr void @-&gt; returning xml_Parser)
let parser_free = foreign &quot;XML_ParserFree&quot;
  (xml_Parser @-&gt; returning void)
</code></pre>
<p>Expat operates primarily through callbacks: when start and end elements are
encountered the parser invokes user-registered functions, passing the tag names
and attributes (along with a piece of user data):</p>
<pre><code class="language-C">typedef void (*start_handler)(void *, char *, char **);
typedef void (*end_handler)(void *, char *);
</code></pre>
<p>In ctypes function pointer types are built using the <code>funptr</code> function:</p>
<pre><code class="language-ocaml">let start_handler =
  funptr (ptr void @-&gt; string @-&gt; ptr string @-&gt; returning void)
let end_handler =
  funptr (ptr void @-&gt; string @-&gt; returning void)
</code></pre>
<p>We can use the <code>start_handler</code> and <code>end_handler</code> type representations to bind
<a href="http://www.xml.com/pub/a/1999/09/expat/reference.html#elementhandler"><code>XML_SetElementHandler</code></a>, the callback-registration function:</p>
<pre><code class="language-ocaml">let set_element_handler = foreign &quot;XML_SetElementHandler&quot;
  (xml_Parser @-&gt; start_handler @-&gt; end_handler @-&gt; returning void)
</code></pre>
<p>The type that OCaml infers for <code>set_element_handler</code> reveals that the function
accepts regular OCaml functions as arguments, since the argument types are
normal OCaml function types:</p>
<pre><code class="language-ocaml">val set_element_handler :
  [ `XML_ParserStruct ] structure ptr -&gt;
  (unit ptr -&gt; string -&gt; string ptr -&gt; unit) -&gt;
  (unit ptr -&gt; string -&gt; unit) -&gt; unit
</code></pre>
<p>There's one remaining function to bind, then we're ready to use the
library.  The
<a href="http://www.xml.com/pub/a/1999/09/expat/reference.html#parse"><code>XML_Parse</code></a>
function performs the actual parsing, invoking the callbacks when tags
are encountered:</p>
<pre><code class="language-ocaml">let parse = foreign &quot;XML_Parse&quot;
  (xml_Parser @-&gt; string @-&gt; int @-&gt; int @-&gt; returning int)
</code></pre>
<p>As before, all the functions that we've bound are available for use
immediately.  We'll start by using them to define a more idiomatic OCaml entry
point to the library.  The <code>parse_string</code> function accepts the start and end
callbacks as labelled arguments, along with a string to parse:</p>
<pre><code class="language-ocaml">let parse_string ~start_handler ~end_handler s =
  let p = parser_create null in
  let () = set_element_handler p start_handler end_handler in
  let _ = parse p s (String.length s) 1 in
  parser_free p
</code></pre>
<p>Using <code>parse_string</code> we can write a program that prints out the names of each
element in an XML document, indented according to nesting depth:</p>
<pre><code class="language-ocaml">let depth = ref 0

let start_handler _ name _ =
  Printf.printf &quot;%*s%s\\n&quot; (!depth * 3) &quot;&quot; name;
  incr depth

let end_handler _ _ =
  decr depth

let () =
  parse_string ~start_handler ~end_handler (In_channel.input_all stdin)
</code></pre>
<p>The full source of the program is <a href="https://github.com/yallop/ocaml-ctypes-expat-example">available on github</a>.</p>
<p>Here's the program in action:</p>
<pre><code class="language-bash">$ ocamlfind opt -thread -package core,ctypes.foreign expat_example.ml \\
   -linkpkg -cclib -lexpat -o expat_example
$ wget -q https://mirage.io/blog/atom.xml -O /dev/stdout \\
  | ./expat_example
feed
   id
   title
   subtitle
   rights
   updated
   link
   link
   contributor
      email
      uri
      name
[...]
</code></pre>
<p>Since this is just a high-level overview we've passed over a number of
details.  The interested reader can find a more comprehensive introduction to
using ctypes in <a href="https://realworldocaml.org/v1/en/html/foreign-function-interface.html">Chapter 19: Foreign Function Interface</a> of <a href="https://realworldocaml.org">Real World OCaml</a>.</p>
<h3>Dynamic vs static</h3>
<p>Up to this point we've been using a single function, <code>foreign</code>, to
make C functions available to OCaml.  Although <code>foreign</code> is simple to
use, there's quite a lot going on behind the scenes.  The two
arguments to <code>foreign</code> are used to dynamically construct an OCaml
function value that wraps the C function: the name is used to resolve
the code for the C function, and the type representation is used to
construct a call frame appropriate to the C types invovled and to the
underlying platform.</p>
<p>The dynamic nature of <code>foreign</code> that makes it convenient for
interactive use, also makes it unsuitable for some environments.
There are three main drawbacks:</p>
<ul>
<li>
<p>Binding functions dynamically involves a certain loss of <em>safety</em>:
since C libraries typically don't maintain information about the
types of the functions they contain, there's no way to check whether
the type representation passed to <code>foreign</code> matches the actual type of
the C function.</p>
</li>
<li>
<p>Dynamically constructing calls introduces a certain <em>interpretative
overhead</em>.  In mitigation, this overhead is much less than might be supposed,
since much of the work can be done when the function is bound rather than
when the call is made, and <code>foreign</code> has been used to bind C functions in
<a href="http://erratique.ch/software/tgls">performance-sensitive applications</a> without problems.</p>
</li>
<li>
<p>The implementation of <code>foreign</code> uses a low-level library, <a href="https://sourceware.org/libffi/">libffi</a>,
to deal with calling conventions across platforms.  While libffi is mature
and widely supported, it's not appropriate for use in every environment.
For example, introducing such a (relatively) large and complex library into
Mirage would compromise many of the benefits of writing the rest of the
system in OCaml.</p>
</li>
</ul>
<p>Happily, there's a solution at hand.  As the introduction hints, <code>foreign</code> is
one of a number of binding strategies, and OCaml's module system makes it easy
to defer the choice of which strategy to use when writing the actual code.
Placing the <code>expat</code> bindings in a functor (parameterised module) makes it
possible to abstract over the linking strategy:</p>
<pre><code class="language-ocaml">module Bindings(F : FOREIGN) =
struct
  let parser_create = F.foreign &quot;XML_ParserCreate&quot;
    (ptr void @-&gt; returning xml_Parser)
  let parser_free = F.foreign &quot;XML_ParserFree&quot;
    (xml_Parser @-&gt; returning void)
  let set_element_handler = F.foreign &quot;XML_SetElementHandler&quot;
    (xml_Parser @-&gt; start_handler @-&gt; end_handler @-&gt; returning void)
  let parse = F.foreign &quot;XML_Parse&quot;
    (xml_Parser @-&gt; string @-&gt; int @-&gt; int @-&gt; returning int)
end
</code></pre>
<p>The <code>Bindings</code> module accepts a single parameter of type <code>FOREIGN</code>, which
encodes the binding strategy to use.  Instantiating <code>Bindings</code> with a module
containing the <code>foreign</code> function used above recovers the
dynamically-constructed bindings that we've been using so far.  However, there
are now other possibilities available.  In particular, we can instantiate
<code>Bindings</code> with code generators that output code to expose the bound functions
to OCaml.  The actual instantiation is hidden behind a couple of convenient
functions, <code>write_c</code> and <code>write_ml</code>, which accept <code>Bindings</code> as a parameter
and write to a <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Format.html#TYPEformatter">formatter</a>:</p>
<pre><code class="language-ocaml">Cstubs.write_c formatter ~prefix:&quot;expat&quot; ~bindings:(module Bindings)
Cstubs.write_ml formatter ~prefix:&quot;expat&quot; ~bindings:(module Bindings)
</code></pre>
<p>Generating code in this way eliminates the concerns associated with
constructing calls dynamically:</p>
<ul>
<li>
<p>The C compiler checks the types of the generated calls against the C
headers (the API), so the safety concerns associated with linking
directly against the C library binaries (the ABI) don't apply.</p>
</li>
<li>
<p>There's no interpretative overhead, since the generated code is
(statically) compiled.</p>
</li>
<li>
<p>The dependency on libffi disappears altogether.</p>
</li>
</ul>
<p>How easy is it in practice to switch between dynamic and static
binding strategies?  It turns out that it's quite straightforward,
even for code that was originally written without parameterisation.
Bindings written using early releases of ctypes used the dynamic
strategy exclusively, since dynamic binding was then the only option
available.  The commit logs for projects that switched over to static
generation and linking (e.g. <a href="https://github.com/whitequark/ocaml-lz4/commit/acc257ea1">ocaml-lz4</a> and
<a href="https://github.com/janestreet/async_ssl/commit/ab5ea6f55e">async-ssl</a>) when it became available show that
moving to the new approach involved only straightforward and localised
changes.</p>
<h3>Local vs remote</h3>
<p>Generating code is safer than constructing calls dynamically, since it
allows the C compiler to check the types of function calls against
declarations.  However, there are some safety problems that even C's
type checking doesn't detect.  For instance, the following call is
type correct (given suitable definitions of <code>p</code> and <code>q</code>), but is
likely to misbehave at run time:</p>
<pre><code class="language-C">memcpy(p, q, SIZE_MAX)
</code></pre>
<p>In contrast, code written purely in OCaml detects and prevents
attempts to write beyond the bounds of allocated objects:</p>
<pre><code class="language-ocaml"># StringLabels.blit ~src ~dst ~src_pos:0 ~dst_pos:0 ~len:max_int;;
Exception: Invalid_argument &quot;String.blit&quot;.
</code></pre>
<p>It seems a shame to weaken OCaml's safety guarantees by linking in C
code that can potentially write to any region of memory, but what is
the alternative?</p>
<p>One possibility is to use <a href="http://en.wikipedia.org/wiki/Privilege_separation">privilege separation</a> to separate
trusted OCaml code from untrusted C functions.  The modular design of
ctypes means that privilege separation can be treated as one more
linking strategy: we can run C code in an entirely separate process
(or for Mirage/Xen, in a separate virtual machine), and instantiate
<code>Bindings</code> with a strategy that forwards calls to the process using
standard inter-process communication.  The remote calling strategy is
not supported in the <a href="https://github.com/ocamllabs/ocaml-ctypes/releases/tag/0.3.2">current release</a> of ctypes, but
it's scheduled for a future version.  As with the switch from dynamic
to static bindings, we anticipate that updating existing bindings to
use cross-process calls will be straightforward.</p>
<p>This introductory post should give you a sense of the power of the unikernel
approach in Mirage.  By turning the FFI into just another library (for the C
interface description) and protocol (for the linkage model), we can use code
generation to map application logic onto the privilege model most suitable for
the target hardware platform.  This starts with Unix processes, continues onto Xen
paravirtualization, and could even extend into <a href="http://www.cl.cam.ac.uk/research/security/ctsrd/cheri/">CHERI</a> fine-grained
compartmentalization.</p>
<h3>Further examples</h3>
<p>Although ctypes is a fairly new library, it's already in use in a
number of projects across a variety of domains: <a href="http://erratique.ch/software/tgls">graphics</a>,
<a href="http://erratique.ch/software/tsdl">multimedia</a>, <a href="https://github.com/whitequark/ocaml-lz4">compression</a>, <a href="https://github.com/dsheets/ocaml-sodium">cryptography</a>,
<a href="https://github.com/nojb/ocaml-gsasl">security</a>, <a href="https://github.com/hcarty/ocaml-gdal">geospatial data</a>, <a href="http://github.com/rgrinberg/onanomsg">communication</a>,
and many others.  Further resources (documentation, forums, etc.) are
available via the <a href="https://github.com/ocamllabs/ocaml-ctypes">home page</a>.</p>
|js};
      };
      {
        updated = {js|2014-07-14 12:00|js};
        authors =
          [
            {
              name = {js|David Kaloper|js};
              uri = Some {js|https://github.com/pqwy|js};
              email = Some {js|david.mersinjak@cl.cam.ac.uk|js};
            };
            {
              name = {js|Hannes Mehnert|js};
              uri = Some {js|https://github.com/hannesm|js};
              email = Some {js|hm519@cam.ac.uk|js};
            };
          ];
        subject =
          {js|OCaml-TLS: the protocol implementation and mitigations to known attacks|js};
        permalink = {js|ocaml-tls-api-internals-attacks-mitigation|js};
        body =
          {js|<p><em>This is the fifth in a series of posts that introduce new libraries for a pure OCaml implementation of TLS.
You might like to begin with the <a href="http://mirage.io/blog/introducing-ocaml-tls">introduction</a>.</em></p>
<p><a href="https://github.com/mirleft/ocaml-tls">ocaml-tls</a> is the new, clean-slate implementation of TLS in OCaml
that we've been working on for the past six months. In this post we
try to document some of its internal design, the reasons for the
decisions we made, and the current security status of that work. Try
our <a href="https://tls.nqsb.io">live interactive demonstration server</a> which visualises TLS
sessions.</p>
<h3>The OCaml-TLS architecture</h3>
<p>The OCaml ecosystem has several distinct ways of interacting with the outside world
(and the network in particular): straightforward <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html">unix</a> interfaces
and the asynchronous programming libraries <a href="http://ocsigen.org/lwt/">lwt</a> and <a href="https://realworldocaml.org/v1/en/html/concurrent-programming-with-async.html">async</a>. One of the
early considerations was not to restrict ourselves to any of those -- we wanted
to support them all.</p>
<p>There were also two distinct basic &quot;platforms&quot; we wanted to target from the
outset: the case of a simple executable, and the case of <code>Mirage</code> unikernels.</p>
<p>So one of the first questions we faced was deciding how to represent
interactions with the network in a portable way. This can be done by
systematically abstracting out the API boundary which gives access to network
operations, but we had a third thing in mind as well: we wanted to exploit the
functional nature of OCaml to its fullest extent!</p>
<p>Our various prior experiences with Haskell and Idris convinced us to adopt
what is called &quot;purely functional&quot; technique. We believe it to be an approach
which first forces the programmer to give principled answers to all the
difficult design questions (errors and global data-flow) <em>in advance</em>, and then
leads to far cleaner and composable code later on. A purely functional system
has all the data paths made completely explicit in the form of function
arguments and results. There are no unaccounted-for interactions between
components mediated by shared state, and all the activity of the parts of the
system is exposed through types since, after all, it's only about computing
values from values.</p>
<p>For these reasons, the library is split into two parts: the directory <code>/lib</code>
(and the corresponding findlib package <code>tls</code>) contains the core TLS logic, and
<code>/mirage</code> and <code>/lwt</code> (packaged as <code>tls.mirage</code> and <code>tls.lwt</code> respectively)
contain front-ends that tie the core to <code>Mirage</code> and <code>Lwt_unix</code>.</p>
<h3>Core</h3>
<p>The <a href="https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/engine.mli">core</a> library is purely functional. A TLS session is represented by the
abstract type <code>Tls.Engine.state</code>, and various functions consume this session
type together with raw bytes (<code>Cstruct.t</code> -- which is by itself mutable, but
<code>ocaml-tls</code> eschews this) and produce new session values and resulting buffers.</p>
<p>The central entry point is <a href="https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/engine.ml#L321">handle_tls</a>, which transforms an input state and a
buffer to an output state, a (possibly empty) buffer to send to the
communication partner, and an optional buffer of data intended to be received by
the application:</p>
<pre><code class="language-OCaml">type state

type ret = [
  | `Ok of [ `Ok of state | `Eof | `Alert of alert ] *
      [ `Response of Cstruct.t ] * [ `Data of Cstruct.t option ]
  | `Fail of alert * [ `Response of Cstruct.t ]
]

val handle_tls : state -&gt; Cstruct.t -&gt; ret
</code></pre>
<p>As the signature shows, errors are signalled through the <code>ret</code> type, which is a <a href="https://realworldocaml.org/v1/en/html/variants.html#polymorphic-variants">polymorphic variant</a>. This
reflects the actual internal structure: all the errors are represented as
values, and operations are composed using an error <a href="https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/control.ml">monad</a>.</p>
<p>Other entry points share the same basic behaviour: they transform the prior
state and input bytes into the later state and output bytes.</p>
<p>Here's a rough outline of what happens in <code>handle_tls</code>:</p>
<ul>
<li>
<p>TLS packets consist of a header, which contains the protocol
version, length, and content type, and the payload of the given
content type. Once inside our <a href="https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/engine.ml#L321">main handler</a>, we
<a href="https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/engine.ml#L150">separate</a> the buffer into TLS records, and
<a href="https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/engine.ml#L275">process</a> each individually. We first check that
the version number is correct, then <a href="https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/engine.ml#L95">decrypt</a>, and <a href="https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/engine.ml#L85">verify
the mac</a>.</p>
</li>
<li>
<p>Decrypted data is then <a href="https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/engine.ml#L240">dispatched</a> to one of four
sub-protocol handlers (Handshake, Change Cipher Spec, Alert and
Application Data). Each handler can <a href="https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/state.ml#L109">return</a> a new
handshake state, outgoing data, application data, the new decryption
state or an error (with the outgoing data being an interleaved list
of buffers and new encryption states).</p>
</li>
<li>
<p>The outgoing buffers and the encryption states are
<a href="https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/engine.ml#L48">traversed</a> to produce the final output to be sent to the
communication partner, and the final encryption, decryption and
handshake states are combined into a new overall state which is
returned to the caller.</p>
</li>
</ul>
<p>Handshake is (by far) the most complex TLS sub-protocol, with an elaborate state
machine. Our <a href="https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/handshake_client.ml#L285">client</a> and <a href="https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/handshake_server.ml#L247">server</a> encode
this state as a &quot;flat&quot; <a href="https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/state.ml#L61">sum type</a>, with exactly one incoming
message allowed per state. The handlers first <a href="https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/reader.ml#L361">parse</a> the
handshake packet (which fails in case of malformed or unknown data) and then
dispatch it to the handling function. The <a href="https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/state.ml#L92">handshake state</a> is
carried around and a fresh one is returned from the handler in case it needs
updates. It consists of a protocol version, the handshake state, configuration,
renegotiation data, and possibly a handshake fragment.</p>
<p>Logic of both handshake handlers is very localised, and does not mutate any
global data structures.</p>
<h3>Core API</h3>
<p>OCaml permits the implementation a module to be exported via a more
abstract <em>signature</em> that hides the internal representation
details. Our public API for the core library consists of the
<a href="https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/engine.mli">Tls.Engine</a> and <a href="https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/config.mli">Tls.Config</a> modules.</p>
<p><code>Tls.Engine</code> contains the basic reactive function <code>handle_tls</code>, mentioned above,
which processes incoming data and optionally produces a response, together with
several operations that allow one to initiate message transfer like
<code>send_application_data</code> (which processes application-level messages for
sending), <code>send_close_notify</code> (for sending the ending message) and <code>reneg</code>
(which initiates full TLS renegotiation).</p>
<p>The module also contains the only two ways to obtain the initial state:</p>
<pre><code class="language-OCaml">val client : Config.client -&gt; (state * Cstruct.t)
val server : Config.server -&gt; state
</code></pre>
<p>That is, one needs a configuration value to create it. The <code>Cstruct.t</code>
that <code>client</code> emits is the initial Client Hello since in TLS,
the client starts the session.</p>
<p><code>Tls.Config</code> synthesizes configurations, separately for client and server
endpoints, through the functions <code>client_exn</code> and <code>server_exn</code>. They take a
number of parameters that define a TLS session, check them for consistency, and
return the sanitized <code>config</code> value which can be used to create a <code>state</code> and,
thus, a session. If the check fails, they raise an exception.</p>
<p>The parameters include the pair of a certificate and its private key for the
server, and an <code>X509.Authenticator.t</code> for the client, both produced by our
<a href="https://github.com/mirleft/ocaml-x509">ocaml-x509</a> library and described in a <a href="http://mirage.io/blog/introducing-x509">previous article</a>.</p>
<p>This design reflects our attempts to make the API as close to &quot;fire and forget&quot;
as we could, given the complexity of TLS: we wanted the library to be relatively
straightforward to use, have a minimal API footprint and, above all, fail very
early and very loudly when misconfigured.</p>
<h3>Effectful front-ends</h3>
<p>Clearly, reading and writing network data <em>does</em> change the state of the world.
Having a pure value describing the state of a TLS session is not really useful
once we write something onto the network; it is certainly not the case that we
can use more than one distinct <code>state</code> to process further data, as only one
value is in sync with the other endpoint at any given time.</p>
<p>Therefore we wrap the core types into stateful structures loosely inspired by
sockets and provide IO operations on those. The structures of <code>mirage</code> and <code>lwt</code>
front-ends mirror one another.</p>
<p>In both cases, the structure is pull-based in the sense that no processing is
done until the client requires a read, as opposed to a callback-driven design
where the client registers a callback and the library starts spinning in a
listening loop and invoking it as soon as there is data to be processed. We do
this because in an asynchronous context, it is easy to create a callback-driven
interface from a demand-driven one, but the opposite is possible only with
unbounded buffering of incoming data.</p>
<p>One exception to demand-driven design is the initial session creation: the
library will only yield the connection after the first handshake is over,
ensuring the invariant that it is impossible to interact with a connection if it
hasn't already been fully established.</p>
<p><strong>Mirage</strong></p>
<p>The <code>Mirage</code> <a href="https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/mirage/tls_mirage_types.mli">interface</a> matches the <a href="https://github.com/mirage/mirage/blob/ae3c966f8d726dc97208595b8005e02e39478cb1/types/V1.mli#L136">FLOW</a>
signature (with additional TLS-specific operations). We provide a functor that
needs to be applied to an underlying TCP module, to obtain a TLS transport on
top. For example:</p>
<pre><code class="language-OCaml">module Server (Stack: STACKV4) (Entropy: ENTROPY) (KV: KV_RO) =
struct

  module TLS  = Tls_mirage.Make (Stack.TCPV4) (Entropy)
  module X509 = Tls_mirage.X509 (KV) (Clock)

  let accept conf flow =
    TLS.server_of_tcp_flow conf flow &gt;&gt;= function
    | `Ok tls -&gt;
      TLS.read tls &gt;&gt;= function
      | `Ok buf -&gt;
        TLS.write tls buf &gt;&gt;= fun () -&gt; TLS.close buf

  let start stack e kv =
    TLS.attach_entropy e &gt;&gt;= fun () -&gt;
    lwt authenticator = X509.authenticator kv `Default in
    let conf          = Tls.Config.server_exn ~authenticator () in
    Stack.listen_tcpv4 stack 4433 (accept conf) ;
    Stack.listen stack

end
</code></pre>
<p><strong>Lwt</strong></p>
<p>The <code>lwt</code> interface has <a href="https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lwt/tls_lwt.mli">two layers</a>. <code>Tls_lwt.Unix</code> is loosely based
on read/write operations from <code>Lwt_unix</code> and provides in-place update of
buffers. <code>read</code>, for example, takes a <code>Cstruct.t</code> to write into and returns the
number of bytes read. The surrounding module, <code>Tls_lwt</code>, provides a simpler,
<code>Lwt_io</code>-compatible API built on top:</p>
<pre><code class="language-OCaml">let main host port =
  Tls_lwt.rng_init () &gt;&gt;= fun () -&gt;
  lwt authenticator = X509_lwt.authenticator (`Ca_dir nss_trusted_ca_dir) in
  lwt (ic, oc)      = Tls_lwt.connect ~authenticator (host, port) in
  let req = String.concat &quot;\\r\\n&quot; [
    &quot;GET / HTTP/1.1&quot; ; &quot;Host: &quot; ^ host ; &quot;Connection: close&quot; ; &quot;&quot; ; &quot;&quot;
  ] in
  Lwt_io.(write oc req &gt;&gt;= fun () -&gt; read ic &gt;&gt;= print)
</code></pre>
<p>We have further plans to provide wrappers for <a href="https://realworldocaml.org/v1/en/html/concurrent-programming-with-async.html"><code>Async</code></a> and plain <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html"><code>Unix</code></a> in a
similar vein.</p>
<h3>Attacks on TLS</h3>
<p>TLS the most widely deployed security protocol on the Internet and, at
over 15 years, is also showing its age. As such, a flaw is a valuable
commodity due to the commercially sensitive nature of data that is
encrypted with TLS. Various vulnerabilities on different layers of TLS
have been found - <a href="https://en.wikipedia.org/wiki/Heartbleed">heartbleed</a> and others are implementation
specific, advancements in cryptanalysis such as <a href="http://eprint.iacr.org/2005/067">collisions of
MD5</a> lead to vulnerabilities, and even others are due
to incorrect usage of TLS (<a href="http://www.theregister.co.uk/2013/08/01/gmail_hotmail_hijacking/">truncation attack</a> or
<a href="http://breachattack.com/">BREACH</a>). Finally, some weaknesses are in the protocol
itself. Extensive <a href="http://eprint.iacr.org/2013/049.pdf">overviews</a> of <a href="http://www.mitls.org/wsgi/tls-attacks">attacks on
TLS</a> are available.</p>
<p>We look at protocol level attacks of TLS and how <a href="https://github.com/mirleft/ocaml-tls">ocaml-tls</a>
implements mitigations against these.  <a href="https://tools.ietf.org/html/rfc5246#appendix-D.4">TLS 1.2 RFC</a> provides an
overview of attacks and mitigations, and we <a href="https://github.com/mirleft/ocaml-tls/issues/31">track</a> our progress in
covering them. This is slightly out of date as the RFC is roughly six years old and
in the meantime more attacks have been published, such as the <a href="http://www.educatedguesswork.org/2009/11/understanding_the_tls_renegoti.html">renegotiation
flaw</a>.</p>
<p>As <a href="http://mirage.io/blog/introducing-ocaml-tls">already mentioned</a>, we track all our
<a href="https://github.com/mirleft/ocaml-tls/issues?labels=security+concern&amp;page=1&amp;state=closed">mitigated</a> and <a href="https://github.com/mirleft/ocaml-tls/issues?labels=security+concern&amp;page=1&amp;state=open">open</a> security issues on our GitHub
issue tracker.</p>
<p>Due to the choice of using OCaml, a memory managed programming
language, we obstruct entire bug classes, namely temporal and spatial
memory safety.</p>
<p>Cryptanalysis and improvement of computational power weaken some
ciphers, such as RC4 and 3DES (see <a href="https://github.com/mirleft/ocaml-tls/issues/8">issue 8</a> and <a href="https://github.com/mirleft/ocaml-tls/issues/10">issue
10</a>). If we phase these two ciphers out, there wouldn't be
any matching ciphersuite left to communicate with some compliant TLS-1.0
implementations, such as Windows XP, that do not support AES.</p>
<p><strong>Timing attacks</strong></p>
<p>When the timing characteristics between the common case and the error
case are different, this might potentially leak confidential
information. Timing is a very prominent side-channel and there are a huge
variety of timing attacks on different layers, which are observable by
different attackers. Small differences in timing behaviour might
initially be exploitable only by a local attacker, but advancements to
the attack (e.g. increasing the number of tests) might allow a
remote attacker to filter the noise and exploit the different timing
behaviour.</p>
<p><strong>Timing of cryptographic primitives</strong></p>
<p>We <a href="http://mirage.io/blog/introducing-nocrypto">already mentioned</a> <a href="http://www.cs.tau.ac.il/~tromer/papers/cache.pdf">cache</a> <a href="http://cr.yp.to/antiforgery/cachetiming-20050414.pdf">timing</a>
attacks on our AES implementation, and that we use <a href="https://en.wikipedia.org/wiki/Blinding_(cryptography)">blinding</a>
techniques to mitigate RSA timing attacks.</p>
<p>By using a memory managed programming language, we open the attack
vector of garbage collector (GC) timing attacks (also mentioned <a href="http://mirage.io/blog/introducing-nocrypto">in
our nocrypto introduction</a>).</p>
<p>Furthermore, research has been done on virtual machine side channels
(<a href="http://eprint.iacr.org/2013/448.pdf">l3</a>, <a href="http://www.cs.unc.edu/~reiter/papers/2012/CCS.pdf">cross vm</a> and <a href="http://fc12.ifca.ai/pre-proceedings/paper_70.pdf">cache timing</a>), which we
will need to study and mitigate appropriately.</p>
<p><strong>For the time being we suggest to not use the stack on a multi-tenant
shared host or on a shared host which malicious users might have
access to.</strong></p>
<p><strong>Bleichenbacher</strong></p>
<p>In 1998, Daniel Bleichenbacher discovered a <a href="http://archiv.infsec.ethz.ch/education/fs08/secsem/Bleichenbacher98.pdf">timing flaw in the
PKCS1</a> encoding of the premaster secret: the TLS server
failed faster when the padding was wrong than when the decryption
failed. Using this timing, an attacker can run an adaptive chosen
ciphertext attack and find out the plain text of a PKCS1 encrypted
message. In TLS, when RSA is used as the key exchange method, this
leads to discovery of the premaster secret, which is used to derive the
keys for the current session.</p>
<p>The mitigation is to have both padding and decryption failures use the
exact same amount of time, thus there should not be any data-dependent
branches or different memory access patterns in the code. We
implemented this mitigation in <a href="https://github.com/mirleft/ocaml-tls/blob/c06cbaaffe49024d8570916b70f7839603a54692/lib/handshake_server.ml#L45">Handshake_server</a>.</p>
<p><strong>Padding oracle and CBC timing</strong></p>
<p><a href="http://www.iacr.org/archive/eurocrypt2002/23320530/cbc02_e02d.pdf">Vaudenay</a> discovered a vulnerability involving block ciphers: if an
attacker can distinguish between bad mac and bad padding, recovery of
the plaintext is possible (within an adaptive chosen ciphertext
attack). Another approach using the same issue is to use
<a href="http://lasecwww.epfl.ch/memo/memo_ssl.shtml">timing</a> information instead of separate error messages.
Further details are described <a href="https://www.openssl.org/~bodo/tls-cbc.txt">here</a>.</p>
<p>The countermeasure, which we implement <a href="https://github.com/mirleft/ocaml-tls/blob/c06cbaaffe49024d8570916b70f7839603a54692/lib/engine.ml#L100">here</a>, is to continue
with the mac computation even though the padding is
incorrect. Furthermore, we send the same alert (<code>bad_record_mac</code>)
independent of whether the padding is malformed or the mac is
incorrect.</p>
<p><strong>Lucky 13</strong></p>
<p>An advancement of the CBC timing attack was discovered in 2013, named
<a href="http://www.isg.rhul.ac.uk/tls/Lucky13.html">Lucky 13</a>. Due to the fact that the mac is computed over the
plaintext without padding, there is a slight (but measurable)
difference in timing between computing the mac of the plaintext and
computing the fake mac of the ciphertext. This leaks information. We
do not have proper mitigation against Lucky 13 in place yet.  You can
find further discussion in <a href="https://github.com/mirleft/ocaml-tls/issues/7">issue 7</a> and <a href="https://github.com/mirleft/ocaml-tls/pull/49">pull request
49</a>.</p>
<p><strong>Renegotiation not authenticated</strong></p>
<p>In 2009, Marsh Ray published a vulnerability of the TLS protocol which
lets an attacker prepend arbitrary data to a session due to
<a href="http://www.educatedguesswork.org/2009/11/understanding_the_tls_renegoti.html">unauthenticated renegotiation</a>. The attack
exploits the fact that a renegotiation of ciphers and key material is
possible within a session, and this renegotiated handshake is not
authenticated by the previous handshake. A man in the middle can
initiate a session with a server, send some data, and hand over the
session to a client. Neither the client nor the server can detect the
man in the middle.</p>
<p>A fix for this issue is the <a href="https://tools.ietf.org/html/rfc5746">secure renegotiation extension</a>,
which embeds authenticated data of the previous handshake into the
client and server hello messages. Now, if a man in the middle
initiates a renegotiation, the server will not complete it due to
missing authentication data (the client believes this is the first
handshake).</p>
<p>We implement and require the secure renegotiation extension by
default, but it is possible to configure <code>ocaml-tls</code> to not require
it -- to be able to communicate with servers and
clients which do not support this extension.</p>
<p>Implementation of the mitigation is on the server side in
<a href="https://github.com/mirleft/ocaml-tls/blob/c06cbaaffe49024d8570916b70f7839603a54692/lib/handshake_server.ml#L85">ensure_reneg</a> and on the client side in <a href="https://github.com/mirleft/ocaml-tls/blob/c06cbaaffe49024d8570916b70f7839603a54692/lib/handshake_client.ml#L50">validate_reneg</a>. The
data required for the secure renegotiation is stored in
<a href="https://github.com/mirleft/ocaml-tls/blob/c06cbaaffe49024d8570916b70f7839603a54692/lib/state.ml#L97"><code>handshake_state</code></a> while sending and receiving Finished
messages. You can find further discussion in <a href="https://github.com/mirleft/ocaml-tls/issues/3">issue 3</a>.</p>
<p><strong>TLS 1.0 and known-plaintext (BEAST)</strong></p>
<p>TLS 1.0 reuses the last ciphertext block as IV in CBC mode. If an attacker
has a (partially) known plaintext, she can find the remaining plaintext.
This is known as the <a href="http://vnhacker.blogspot.co.uk/2011/09/beast.html">BEAST</a> attack and there is a <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=665814">long discussion</a>
about mitigations. Our mitigation is to prepend each TLS-1.0
application data fragment with an empty fragment to randomize the IV.
We do this exactly <a href="https://github.com/mirleft/ocaml-tls/blob/c06cbaaffe49024d8570916b70f7839603a54692/lib/engine.ml#L375">here</a>. There is further discussion in
<a href="https://github.com/mirleft/ocaml-tls/issues/2">issue 2</a>.</p>
<p>Our mitigation is slightly different from the 1/n-1 splitting proposed
<a href="https://community.qualys.com/blogs/securitylabs/2013/09/10/is-beast-still-a-threat">here</a>: we split every application data frame into a 0 byte
and n byte frame, whereas they split into a 1 byte and a n-1 byte
frame.</p>
<p>Researchers have exploited this vulnerability in 2011, although it was
known since <a href="http://eprint.iacr.org/2006/136">2006</a>. TLS versions 1.1 and 1.2 use an explicit IV,
instead of reusing the last cipher block on the wire.</p>
<p><strong>Compression and information leakage (CRIME)</strong></p>
<p>When using compression on a chosen-plaintext, encrypting this can leak
information, known as <a href="http://arstechnica.com/security/2012/09/crime-hijacks-https-sessions/">CRIME</a>. <a href="http://breachattack.com/">BREACH</a> furthermore
exploits application layer compression, such as HTTP compression. We
mitigate CRIME by not providing any TLS compression support, while we
cannot do anything to mitigate BREACH.</p>
<p><strong>Traffic analysis</strong></p>
<p>Due to limited amount of padding data, the actual size of transmitted
data can be recovered. The mitigation is to implement <a href="http://tools.ietf.org/html/draft-pironti-tls-length-hiding-02">length hiding
policies</a>. This is tracked as <a href="https://github.com/mirleft/ocaml-tls/issues/162">issue 162</a>.</p>
<p><strong>Version rollback</strong></p>
<p>SSL-2.0 is insecure, a man in the middle can downgrade the version to
SSL-2.0. The mitigation we implement is that we do not support
SSL-2.0, and thus cannot be downgraded. Also, we check that the
version of the client hello matches the first two bytes in the
premaster secret <a href="https://github.com/mirleft/ocaml-tls/blob/c06cbaaffe49024d8570916b70f7839603a54692/lib/handshake_server.ml#L55">here</a>. You can find further discussion in
<a href="https://github.com/mirleft/ocaml-tls/issues/5">issue 5</a>.</p>
<p><strong>Triple handshake</strong></p>
<p>A vulnerability including session resumption and renegotiation was
discovered by the <a href="http://www.mitls.org">miTLS team</a>, named <a href="https://secure-resumption.com/">triple
handshake</a>.  Mitigations include disallowing renegotiation,
disallowing modification of the certificate during renegotiation, or
a hello extension. Since we do not support session resumption yet, we
have not yet implemented any of the mentioned mitigations. There is
further discussion in <a href="https://github.com/mirleft/ocaml-tls/issues/9">issue 9</a>.</p>
<p><strong>Alert attack</strong></p>
<p>A <a href="http://www.mitls.org/wsgi/alert-attack">fragment of an alert</a> can be sent by a man in the
middle during the initial handshake. If the fragment is not cleared
once the handshake is finished, the authentication of alerts is
broken. This was discovered in 2012; our mitigation is to discard
fragmented alerts.</p>
<h3>EOF.</h3>
<p>Within six months, two hackers managed to develop a clean-slate TLS
stack, together with required crypto primitives, ASN.1, and X.509
handling, in a high-level pure language. We interoperate with widely
deployed TLS stacks, as shown by our <a href="https://tls.nqsb.io">demo server</a>.  The code
size is nearly two orders of magnitude smaller than OpenSSL, the most
widely used open source library (written in C, which a lot of
programming languages wrap instead of providing their own TLS
implementation). Our code base seems to be robust -- the <a href="https://tls.nqsb.io">demo
server</a> successfully finished over 22500 sessions in less than a
week, with only 11 failing traces.</p>
<p>There is a huge need for high quality TLS implementations, because
several TLS implementations suffered this year from severe security
problems, such as <a href="https://en.wikipedia.org/wiki/Heartbleed">heartbleed</a>, <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-1266">goto fail</a>, <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-3466">session
id</a>, <a href="http://armoredbarista.blogspot.de/2014/04/easter-hack-even-more-critical-bugs-in.html">Bleichenbacher</a>, <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0224">change cipher
suite</a> and <a href="https://polarssl.org/tech-updates/security-advisories/polarssl-security-advisory-2014-02">GCM DoS</a>. The main cause is
implementation complexity due to lack of abstraction, and memory
safety issues.</p>
<p>We still need to address some security issues, and improve our performance. We
invite people to do rigorous code audits (both manual and automated) and try
testing our code in their services.</p>
<p><strong>Please be aware that this release is a <em>beta</em> and is missing external code audits.
It is not yet intended for use in any security critical applications.</strong></p>
<h3>Acknowledgements</h3>
<p>Since this is the final post in our series, we would like to thank all
people who reported issues so far: <a href="http://anil.recoil.org/">Anil Madhavapeddy</a>, <a href="https://github.com/edwintorok">Török
Edwin</a>, <a href="http://erratique.ch/">Daniel Bünzli</a>, <a href="http://blog.andreas.org/">Andreas Bogk</a>, <a href="http://gregorkopf.de/blog/">Gregor Kopf</a>, <a href="https://twitter.com/graham_steel">Graham
Steel</a>, <a href="https://github.com/vouillon">Jerome Vouillon</a>, <a href="http://amirchaudhry.com/">Amir Chaudhry</a>,
<a href="http://ashishagarwal.org">Ashish Agarwal</a>. Additionally, we want to thank the
<a href="http://www.mitls.org">miTLS</a> team (especially Cedric and Karthikeyan) for fruitful
discussions, as well as the <a href="http://www.cl.cam.ac.uk/projects/ocamllabs/">OCaml Labs</a> and
<a href="http://mirage.io">Mirage</a> teams. And thanks to <a href="http://www.cl.cam.ac.uk/~pes20/">Peter Sewell</a> and
<a href="http://www.cs.nott.ac.uk/~rmm/">Richard Mortier</a> for funding within the <a href="http://rems.io">REMS</a>, <a href="http://usercentricnetworking.eu/">UCN</a>, and <a href="http://www.horizon.ac.uk">Horizon</a>
projects. The software was started in <a href="http://www.aftasmirleft.com/">Aftas beach house</a> in
Mirleft, Morocco.</p>
<img src="/graphics/aftas-mirleft.jpg" alt="Aftas Beach" />
<hr />
<p>Posts in this TLS series:</p>
<ul>
<li><a href="http://mirage.io/blog/introducing-ocaml-tls">Introducing transport layer security (TLS) in pure OCaml</a>
</li>
<li><a href="http://mirage.io/blog/introducing-nocrypto">OCaml-TLS: building the nocrypto library core</a>
</li>
<li><a href="http://mirage.io/blog/introducing-x509">OCaml-TLS: adventures in X.509 certificate parsing and validation</a>
</li>
<li><a href="http://mirage.io/blog/introducing-asn1">OCaml-TLS: ASN.1 and notation embedding</a>
</li>
<li><a href="http://mirage.io/blog/ocaml-tls-api-internals-attacks-mitigation">OCaml-TLS: the protocol implementation and mitigations to known attacks</a>
</li>
</ul>
|js};
      };
      {
        updated = {js|2014-07-11 12:00|js};
        authors =
          [
            {
              name = {js|David Kaloper|js};
              uri = Some {js|https://github.com/pqwy|js};
              email = Some {js|david.mersinjak@cl.cam.ac.uk|js};
            };
          ];
        subject = {js|OCaml-TLS: ASN.1 and notation embedding|js};
        permalink = {js|introducing-asn1|js};
        body =
          {js|<p><em>This is the fourth in a series of posts that introduce new libraries for a pure OCaml implementation of TLS.
You might like to begin with the <a href="https://mirage.io/blog/introducing-ocaml-tls">introduction</a>.</em></p>
<p><a href="https://github.com/mirleft/ocaml-asn1-combinators">asn1-combinators</a> is a library that allows one to express
<a href="https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One">ASN.1</a> grammars directly in OCaml, manipulate them as first-class entities,
combine them with one of several ASN encoding rules and use the result to parse
or serialize values.</p>
<p>It is the parsing and serialization backend for our <a href="https://github.com/mirleft/ocaml-x509">X.509</a>
certificate library, which in turn provides certificate handling for
<a href="https://github.com/mirleft/ocaml-tls">ocaml-tls</a>.
We wrote about the X.509 certificate handling <a href="https://mirage.io/blog/introducing-x509">yesterday</a>.</p>
<h3>What is ASN.1, really?</h3>
<p><a href="https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One">ASN.1</a> (Abstract Syntax Notation, version one) is a way to describe
on-the-wire representation of messages. It is split into two components: a way
to describe the content of a message, i.e. a notation for its abstract syntax,
and a series of standard encoding rules that define the exact byte
representations of those syntaxes. It is defined in ITU-T standards X.680-X.683
and X.690-X.695.</p>
<p>The notation itself contains primitive grammar elements, such as <code>BIT STRING</code> or
<code>GeneralizedTime</code>, and constructs that allow for creation of compound grammars
from other grammars, like <code>SEQUENCE</code>. The notation is probably best introduced
through a real-world example:</p>
<pre><code>-- Simple name bindings
UniqueIdentifier ::= BIT STRING

-- Products
Validity ::= SEQUENCE {
  notBefore Time,
  notAfter  Time
}

-- Sums
Time ::= CHOICE {
  utcTime     UTCTime,
  generalTime GeneralizedTime
}
</code></pre>
<p>(Example from <a href="http://tools.ietf.org/html/rfc5280#appendix-A.2">RFC 5280</a>, the RFC that describes X.509
certificates which heavily rely on ASN.)</p>
<p>The first definition shows that we can introduce an alias for any existing ASN
grammar fragment, in this case the primitive <code>BIT STRING</code>. The second and third
definitions are, at least morally, a product and a sum.</p>
<p>At their very core, ASN grammars look roughly like algebraic data types, with a
range of pre-defined primitive grammar fragments like <code>BIT STRING</code>, <code>INTEGER</code>,
<code>NULL</code>, <code>BOOLEAN</code> or even <code>GeneralizedTime</code>, and a number of combining
constructs that can be understood as denoting sums and products.</p>
<p>Definitions such as the above are arranged into named modules. The standard even
provides for some abstractive capabilities: initially just a macro facility, and
later a form of parameterized interfaces.</p>
<p>To facilitate actual message transfer, a grammar needs to be coupled with an
encoding. By far the most relevant ones are Basic Encoding Rules (BER) and
Distinguished Encoding Rules (DER), although other encodings exist.</p>
<p>BER and DER are tag-length-value (TLV) encodings, meaning that every value is
encoded as a triplet containing a tag that gives the interpretation of its
contents, a length field, and the actual contents which can in turn contain
other TLV triplets.</p>
<p>Let's drop the time from the example above, as time encoding is a little
involved, and assume a simpler version for a moment:</p>
<pre><code>Pair ::= SEQUENCE {
  car Value,
  cdr Value
}

Value ::= CHOICE {
  v_str UTF8String,
  v_int INTEGER
}
</code></pre>
<p>Then two possible BER encodings of a <code>Pair</code> <code>(&quot;foo&quot;, 42)</code> are:</p>
<pre><code>  30         - SEQUENCE            30         - SEQUENCE
  08         - length              0c         - length
  [ 0c       - UTF8String          [ 2c       - UTF8String, compound
    03       - length                07       - length
    [ 66     - 'f'                   [ 0c     - UTF8String
      6f     - 'o'                     01     - length
      6f ]   - 'o'                     [ 66 ] - 'f'
    02       - INTEGER                 0c     - UTF8String
    01       - length                  02     - length
    [ 2a ] ] - 42                      [ 6f   - 'o'
                                         6f ] - 'o'
                                     02       - INTEGER
                                     01       - length
                                     [ 2a ] ] - 42
</code></pre>
<p>The left one is also the only valid DER encoding of this value: BER allows
certain freedoms in encoding, while DER is just a BER subset without those
freedoms. The property of DER that any value has exactly one encoding is useful,
for example, when trying to digitally sign a value.</p>
<p>If this piqued your curiosity about ASN, you might want to take a detour and
check out this <a href="http://luca.ntop.org/Teaching/Appunti/asn1.html">excellent writeup</a>.</p>
<h3>A bit of history</h3>
<p>The description above paints a picture of a technology a little like <a href="https://code.google.com/p/protobuf/">Google's
Protocol Buffers</a> or <a href="https://thrift.apache.org/">Apache Thrift</a>: a way to declaratively
specify the structure of a set of values and derive parsers and serializers,
with the addition of multiple concrete representations.</p>
<p>But the devil is in the detail. For instance, the examples above intentionally
gloss over the fact that often concrete tag values <a href="http://tools.ietf.org/html/rfc5280#page-128">leak</a> into
the grammar specifications for various disambiguation reasons. And ASN has more
than 10 different <a href="http://www.obj-sys.com/asn1tutorial/node128.html">string types</a>, most of which use
long-obsolete character encodings. Not to mention that the full standard is
close to 200 pages of relatively dense language and quite difficult to
follow. In general, ASN seems to have too many features for the relatively
simple task it is solving, and its specification has evolved over decades, apparently
trying to address various other semi-related problems, such as providing a
general <a href="https://en.wikipedia.org/wiki/Information_Object_Class_(ASN.1)">Interface Description Language</a>.</p>
<p>Which is to say, ASN is <em>probably</em> not what you are looking for. So why
implement it?</p>
<p>Developed in the context of the telecom industry around 30 years ago, modified
several times after that and apparently suffering from a lack of a coherent
goal, by the early 90s ASN was still probably the only universal, machine- and
architecture-independent external data representation.</p>
<p>So it came easily to hand around the time RSA Security started publishing its
series of <a href="https://en.wikipedia.org/wiki/PKCS">PKCS</a> standards, aimed at the standardization of
cryptographic material exchange. RSA keys and digital signatures are often
exchanged ASN-encoded.</p>
<p>At roughly the same time, ITU-T started publishing the <a href="https://en.wikipedia.org/wiki/X.500">X.500</a> series
of standards which aimed to provide a comprehensive directory service. Much of
this work ended up as LDAP, but one little bit stands out in particular: the
<a href="https://en.wikipedia.org/wiki/X.509">X.509</a> PKI certificate.</p>
<p>So a few years later, when Netscape tried to build an authenticated and
confidential layer to tunnel HTTP through, they based it on -- amongst other
things -- X.509 certificates. Their work went through several revisions as SSL
and was finally standardized as TLS. Modern TLS still requires X.509.</p>
<p>Thus, even though TLS uses ASN only for encoding certificates (and the odd PKCS1
signature), every implementation needs to know how to deal with ASN. In fact,
many other general cryptographic libraries also need to deal with ASN, as various PKCS
standards mandate ASN as the encoding for exchange of cryptographic material.</p>
<h3>The grammar of the grammar</h3>
<p>As its name implies, ASN was meant to be used with a specialized compiler. ASN
is really a standard for <em>writing down</em> abstract syntaxes, and ASN compilers
provided with the target encoding will generate code in your programming
language of choice that, when invoked, parses to or serializes from ASN.</p>
<p>As long as your programming language of choice is C, C++, Java or C#, obviously
-- there doesn't seem to be one freely available that targets OCaml. In any case, generating code for such a high-level language feels wrong somehow. In
its effort to be language-neutral, ASN needs to deal with things like modules,
abstraction and composition. At this point, most functional programmers reading
this are screaming: &quot;I <em>already</em> have a language that can deal with modules,
abstraction and composition perfectly well!&quot;</p>
<p>So we're left with implementing ASN in OCaml.</p>
<p>One strategy is to provide utility functions for parsing elements of ASN and
simply invoke them in the appropriate order, as imposed by the target grammar.
This amounts to hand-writing the parser and is what TLS libraries in C
typically do.</p>
<p>As of release 1.3.7, <a href="https://github.com/polarssl/polarssl/tree/development/library">PolarSSL</a> includes ~7,500 lines of rather
beautifully written C, that implement a specialized parser for dealing with
X.509. OpenSSL's <a href="https://github.com/openssl/openssl">libcrypto</a> contains ~50,000 lines of C in its
<a href="https://github.com/openssl/openssl/tree/e3ba6a5f834f24aa5ffe9bc1849e3410c87388d5/crypto/asn1">'asn1'</a>, <a href="https://github.com/openssl/openssl/tree/e3ba6a5f834f24aa5ffe9bc1849e3410c87388d5/crypto/x509">'x509'</a> and
<a href="https://github.com/openssl/openssl/tree/e3ba6a5f834f24aa5ffe9bc1849e3410c87388d5/crypto/x509v3">'x509v3'</a> directories, and primarily deals with X.509
specifically as required by TLS.</p>
<p>In both cases, low-level control flow is intertwined with the parsing logic and,
above the ASN parsing level, the code that deals with interpreting the ASN
structure is not particularly concise.
It is certainly a far cry from the (relatively)
simple grammar description ASN itself provides.</p>
<p>Since in BER every value fully describes itself, another strategy is to parse
the input stream without reference to the grammar. This produces a value that
belongs to the general type of all ASN-encoded trees, after which we need to
process the <em>structure</em> according to the grammar. This is similar to a common
treatment of JSON or XML, where one decouples parsing of bytes from the
higher-level concerns about the actual structure contained therein. The problem
here is that either the downstream client of such a parser needs to constantly
re-check whether the parts of the structure it's interacting with are really
formed according to the grammar (probably leading to a tedium of
pattern-matches), or we have to turn around and solve the parsing problem
<em>again</em>, mapping the uni-typed contents of a message to the actual, statically
known structure we require the message to have.</p>
<p>Surely we can do better?</p>
<h3>LAMBDA: The Ultimate Declarative</h3>
<p>Again, ASN is a language with a number of built-in primitives, a few combining
constructs, (recursive) name-binding and a module system. Our target language is
a language with a perfectly good module system and it can certainly express
combining constructs. It includes an abstraction mechanism arguably far simpler
and easier to use than those of ASN, namely, functions. And the OCaml compilers
can already parse OCaml sources. So why not just reuse this machinery?</p>
<p>The idea is familiar. Creating embedded languages for highly declarative
descriptions within narrowly defined problem spaces is the staple of functional
programming. In particular, combinatory parsing has been known, studied and
used for <a href="http://comjnl.oxfordjournals.org/content/32/2/108.short">decades</a>.</p>
<p>However, we also have to diverge from traditional parser combinators in two major ways.
Firstly, a single grammar expression needs to be able to generate
different concrete parsers, corresponding to different ASN encodings. More
importantly, we desire our grammar descriptions to act <strong>bidirectionally</strong>,
producing both parsers and complementary deserializers.</p>
<p>The second point severely restricts the signatures we can support. The usual
monadic parsers are off the table because the expression such as:</p>
<pre><code class="language-OCaml">( (pa : a t) &gt;&gt;= fun (a : a) -&gt;
  (pb : b t) &gt;&gt;= fun (b : b) -&gt;
  return (b, b, a) ) : (b * b * a) t
</code></pre>
<p>... &quot;hides&quot; parts of the parser inside the closures, especially the method of
mapping the parsed values into the output values, and can not be run &quot;in
reverse&quot; [<a href="#footnote-1">1</a>].</p>
<p>We have a similar problem with <a href="http://www.soi.city.ac.uk/~ross/papers/Applicative.html">applicative functors</a>:</p>
<pre><code class="language-OCaml">( (fun a b -&gt; (b, b, a))
  &lt;$&gt; (pa : a t)
  &lt;*&gt; (pb : b t) ) : (b * b * a) t
</code></pre>
<p>(Given the usual <code>&lt;$&gt; : ('a -&gt; 'b) -&gt; 'a t -&gt; 'b t</code> and <code>&lt;*&gt; : ('a -&gt; 'b) t -&gt; 'a t -&gt; 'b t</code>.) Although the elements of ASN syntax are now exposed, the process
of going from intermediate parsing results to the result of the whole is still
not accessible.</p>
<p>Fortunately, due to the regular structure of ASN, we don't really <em>need</em> the
full expressive power of monadic parsing. The only occurrence of sequential
parsing is within <code>SEQUENCE</code> and related constructs, and we don't need
look-ahead. All we need to do is provide a few specialized combinators to handle
those cases -- combinators the likes of which would be derived in a
more typical setting.</p>
<p>So if we imagine we had a few values, like:</p>
<pre><code class="language-OCaml">val gen_time : gen_time t
val utc_time : utc_time t
val choice   : 'a t -&gt; 'b t -&gt; ('a, 'b) choice t
val sequence : 'a t -&gt; 'b t -&gt; ('a * 'b) t
</code></pre>
<p>Assuming appropriate OCaml types <code>gen_time</code> and <code>utc_time</code> that reflect their
ASN counterparts, and a simple sum type <code>choice</code>, we could express the
<code>Validity</code> grammar above using:</p>
<pre><code class="language-OCaml">type time = (gen_time, utc_time) choice
let time     : time t          = choice gen_time utc_time
let validity : (time * time) t = sequence time time
</code></pre>
<p>In fact, ASN maps quite well to algebraic data types. Its <code>SEQUENCE</code> corresponds
to n-ary products and <code>CHOICE</code> to sums. ASN <code>SET</code> is a lot like <code>SEQUENCE</code>,
except the elements can come in any order; and <code>SEQUENCE_OF</code> and <code>SET_OF</code> are
just lifting an <code>'a</code>-grammar into an <code>'a list</code>-grammar.</p>
<p>A small wrinkle is that <code>SEQUENCE</code> allows for more contextual information on its
components (so does <code>CHOICE</code> in reality, but we ignore that): elements can carry
labels (which are not used for parsing) and can be marked as optional. So
instead of working directly on the grammars, our <code>sequence</code> must work on their
annotated versions. A second wrinkle is the arity of the <code>sequence</code> combinator.</p>
<p>Thus we introduce the type of annotated grammars, <code>'a element</code>, which
corresponds to one <code>,</code>-delimited syntactic element in ASN's own <code>SEQUENCE</code>
grammar, and the type <code>'a sequence</code>, which describes the entire contents (<code>{ ... }</code>) of a <code>SEQUENCE</code> definition:</p>
<pre><code class="language-OCaml">val required : 'a t -&gt; 'a element
val optional : 'a t -&gt; 'a option element
val ( -@ )   : 'a element -&gt; 'b element -&gt; ('a * 'b) sequence
val ( @ )    : 'a element -&gt; 'a sequence -&gt; ('a * 'b) sequence
val sequence : 'a sequence -&gt; 'a t
</code></pre>
<p>The following are then equivalent:</p>
<pre><code>Triple ::= SEQUENCE {
  a INTEGER,
  b BOOLEAN,
  c BOOLEAN OPTIONAL
}
</code></pre>
<pre><code class="language-OCaml">let triple : (int * (bool * bool option)) t =
  sequence (
      required int
    @ required bool
   -@ optional bool
  )
</code></pre>
<p>We can also re-introduce functions, but in a controlled manner:</p>
<pre><code class="language-OCaml">val map : ('a -&gt; 'b) -&gt; ('b -&gt; 'a) -&gt; 'a t -&gt; 'b t
</code></pre>
<p>Keeping in line with the general theme of bidirectionality, we require functions
to come in pairs. The deceptively called <code>map</code> could also be called <code>iso</code>, and
comes with a nice property: if the two functions are truly inverses,
the serialization process is fully reversible, and so is parsing, under
single-representation encodings (DER)!</p>
<h3>ASTs of ASNs</h3>
<p>To go that last mile, we should probably also <em>implement</em> what we discussed.</p>
<p>Traditional parser combinators look a little like this:</p>
<pre><code class="language-OCaml">type 'a p = string -&gt; 'a * string

let bool : bool p = fun str -&gt; (s.[0] &lt;&gt; &quot;\\000&quot;, tail_of_string str)
</code></pre>
<p>Usually, the values inhabiting the parser type are the actual parsing functions,
and their composition directly produces larger parsing functions. We would
probably need to represent them with <code>'a p * 'a s</code>, pairs of a parser and its
inverse, but the same general idea applies.</p>
<p>Nevertheless, we don't want to do this.
The grammars need to support more than one concrete
parser/serializer, and composing what is common between them and extracting out
what is not would probably turn into a tangled mess. That is one reason. The other is that if we encode the grammar purely as
(non-function) value, we can traverse it for various other purposes.</p>
<p>So we turn from what is sometimes called &quot;shallow embedding&quot; to &quot;deep
embedding&quot; and try to represent the grammar purely as an algebraic data type.</p>
<p>Let's try to encode the parser for bools, <code>boolean : bool t</code>:</p>
<pre><code class="language-OCaml">type 'a t =
  | Bool
  ...

let boolean : bool t = Bool
</code></pre>
<p>Unfortunately our constructor is fully polymorphic, of type <code>'a. 'a t</code>. We can
constrain it for the users, but once we traverse it there is nothing left to
prove its intended association with booleans!</p>
<p>Fortunately, starting with the release of <a href="http://ocaml.org/releases/4.00.1.html">OCaml 4.00.0</a>,
OCaml joined the ranks of
languages equipped with what is probably the supreme tool of deep embedding,
<a href="http://en.wikipedia.org/wiki/Generalized_algebraic_data_type">GADTs</a>. Using them, we can do things like:</p>
<pre><code class="language-OCaml">type _ t =
  | Bool   : bool t
  | Pair   : ('a t * 'b t) -&gt; ('a * 'b) t
  | Choice : ('a t * 'b t) -&gt; ('a, 'b) choice t
  ...
</code></pre>
<p>In fact, this is very close to how the library is <a href="https://github.com/mirleft/ocaml-asn1-combinators/blob/4328bf5ee6f20ad25ff7971ee8013f79e5bfb036/src/core.ml#L19">actually</a>
implemented.</p>
<p>There is only one thing left to worry about: ASN definitions can be recursive.
We might try something like:</p>
<pre><code class="language-OCaml">let rec list = choice null (pair int list)
</code></pre>
<p>But this won't work. Being just trees of applications, our definitions never
contain <a href="http://caml.inria.fr/pub/docs/manual-ocaml-400/manual021.html#toc70">statically constructive</a> parts -- this expression could never
terminate in a strict language.</p>
<p>We can get around that by wrapping grammars in <code>Lazy.t</code> (or just closures), but
this would be too awkward to use. Like many other similar libraries, we need to
provide a fixpoint combinator:</p>
<pre><code class="language-OCaml">val fix : ('a t -&gt; 'a t) -&gt; 'a t
</code></pre>
<p>And get to write:</p>
<pre><code class="language-OCaml">let list = fix @@ fun list -&gt; choice null (pair int list)
</code></pre>
<p>This introduces a small problem. So far we simply reused binding inherited
from OCaml without ever worrying about identifiers and references, but with a
fixpoint, the grammar encodings need to be able to somehow express a cycle.</p>
<p>Borrowing an idea from higher-order abstract syntax, we can represent the entire
fixpoint node using exactly the function provided to define it, re-using OCaml's
own binding and identifier resolution:</p>
<pre><code class="language-OCaml">type _ t =
  | Fix : ('a t -&gt; 'a t) -&gt; 'a t
  ...
</code></pre>
<p>This treatment completely sidesteps the problems with variables. We need no
binding environments or De Brujin indices, and need not care about the desired
scoping semantics. A little trade-off is that with this simple encoding it
becomes more difficult to track cycles (when traversing the AST, if we keep
applying a <code>Fix</code> node to itself while descending into it, it looks like an
infinite tree), but with a little opportunistic caching it all plays out well
[<a href="#footnote-2">2</a>].</p>
<p>The <a href="https://github.com/mirleft/ocaml-asn1-combinators/blob/4328bf5ee6f20ad25ff7971ee8013f79e5bfb036/src/ber_der.ml#L49">parser</a> and <a href="https://github.com/mirleft/ocaml-asn1-combinators/blob/4328bf5ee6f20ad25ff7971ee8013f79e5bfb036/src/ber_der.ml#L432">serializer</a> proper then emerge as interpreters for
this little language of typed trees, traversing them with an input string, and
parsing it in a fully type-safe manner.</p>
<h3>How does it play out?</h3>
<p>The entire ASN library comes down to ~1,700 lines of OCaml, with around ~1,100
more in tests, giving a mostly-complete treatment of BER and DER.</p>
<p>Its main use so far is in the context of the <code>X.509</code> library
(discussed <a href="https://mirage.io/blog/introducing-x509">yesterday</a>). It allowed the
grammar of certificates and RSA keys, together with a number of transformations
from the raw types to more pleasant, externally facing ones, to be written in
~900 <a href="https://github.com/mirleft/ocaml-x509/blob/6c96f11a2c7911ae0b308af9b328aee38f48b270/lib/asn_grammars.ml">lines</a> of OCaml. And the code looks a lot like the
actual standards the grammars were taken from -- the fragment from the beginning
of this article becomes:</p>
<pre><code class="language-OCaml">let unique_identifier = bit_string_cs

let time =
  map (function `C1 t -&gt; t | `C2 t -&gt; t) (fun t -&gt; `C2 t)
      (choice2 utc_time generalized_time)

let validity =
  sequence2
    (required ~label:&quot;not before&quot; time)
    (required ~label:&quot;not after&quot;  time)
</code></pre>
<p>We added <code>~label</code> to <code>'a element</code>-forming injections, and have:</p>
<pre><code class="language-OCaml">val choice2 : 'a t -&gt; 'b t -&gt; [ `C1 of 'a | `C2 of 'b ] t
</code></pre>
<p>To get a sense of how the resulting system eases the translation of standardized
ASN grammars into working code, it is particularly instructive to compare
<a href="https://github.com/polarssl/polarssl/blob/b9e4e2c97a2e448090ff3fcc0f99b8f6dbc08897/library/x509_crt.c#L531">these</a> <a href="https://github.com/mirleft/ocaml-x509/blob/7bd25d152445263d7659c653e4a761222f43c75b/lib/asn_grammars.ml#L772">two</a> definitions.</p>
<p>Reversibility was a major simplifying factor during development. Since the
grammars are traversable, it is easy to generate their <a href="https://github.com/mirleft/ocaml-asn1-combinators/blob/cf1a1ffb4a31d02979a6a0bca8fe58856f8907bf/src/asn_random.ml">random</a>
inhabitants, encode them, parse the result and verify the reversibility still
<a href="https://github.com/mirleft/ocaml-asn1-combinators/blob/cf1a1ffb4a31d02979a6a0bca8fe58856f8907bf/tests/testlib.ml#L83">holds</a>. This can't help convince us the parsing/serializing pair
is actually correct with respect to ASN, but it gives a simple tool to generate
large amounts of test cases and convince us that that pair is <em>equivalent</em>. A
number of hand-written cases then check the conformance to the actual ASN.</p>
<p>As for security, there were two concerns we were aware of. There is a history of
catastrophic <a href="https://technet.microsoft.com/en-us/library/security/ms04-007.aspx">buffer overruns</a> in some ASN.1 implementations,
but -- assuming our compiler and runtime system are correct -- we are immune to
these as we are subject to bounds-checking. And
there are some documented <a href="https://www.viathinksoft.de/~daniel-marschall/asn.1/oid_facts.html">problems</a> with security of X.509
certificate verification due to overflows of numbers in ASN OID types, which we
explicitly guard against.</p>
<p>You can check our security status on our <a href="https://github.com/mirleft/ocaml-asn1-combinators/issues?state=open">issue tracker</a>.</p>
<h4>Footnotes</h4>
<ol>
<li>
<p><a name="footnote-1"> </a> In fact, the problem with embedding functions in
combinator languages, and the fact that in a functional language it is not
possible to extract information from a function other than by applying it,
was discussed more than a decade ago. Such discussions led to the development of
<a href="http://www.haskell.org/arrows/biblio.html#Hug00">Arrows</a>, amongst other things.</p>
</li>
<li>
<p><a name="footnote-2"> </a> Actually, a version of the library used the more
<a href="http://dl.acm.org/citation.cfm?id=1411226">proper</a> encoding to be able to inject results of reducing
referred-to parts of the AST into the referring sites directly, roughly
like <code>Fix : ('r -&gt; ('a, 'r) t) -&gt; ('a, 'r) t</code>. This approach was abandoned because terms need to be polymorphic in <code>'r</code>, and this becomes
impossible to hide from the user of the library, creating unwelcome noise.</p>
</li>
</ol>
<hr />
<p>Posts in this TLS series:</p>
<ul>
<li><a href="https://mirage.io/blog/introducing-ocaml-tls">Introducing transport layer security (TLS) in pure OCaml</a>
</li>
<li><a href="https://mirage.io/blog/introducing-nocrypto">OCaml-TLS: building the nocrypto library core</a>
</li>
<li><a href="https://mirage.io/blog/introducing-x509">OCaml-TLS: adventures in X.509 certificate parsing and validation</a>
</li>
<li><a href="https://mirage.io/blog/introducing-asn1">OCaml-TLS: ASN.1 and notation embedding</a>
</li>
<li><a href="https://mirage.io/blog/ocaml-tls-api-internals-attacks-mitigation">OCaml-TLS: the protocol implementation and mitigations to known attacks</a>
</li>
</ul>
|js};
      };
      {
        updated = {js|2014-07-10 13:00|js};
        authors =
          [
            {
              name = {js|Hannes Mehnert|js};
              uri = Some {js|https://github.com/hannesm|js};
              email = Some {js|hm519@cam.ac.uk|js};
            };
          ];
        subject =
          {js|OCaml-TLS: Adventures in X.509 certificate parsing and validation|js};
        permalink = {js|introducing-x509|js};
        body =
          {js|<p><em>This is the third in a series of posts that introduce new libraries for a pure OCaml implementation of TLS.
You might like to begin with the <a href="http://mirage.io/blog/introducing-ocaml-tls">introduction</a>.</em></p>
<h3>The problem of authentication</h3>
<p>The authenticity of the remote server needs to be verified while
establishing a secure connection to it, or else an
attacker (<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">MITM</a>) between the client and the server can eavesdrop on
the transmitted data. To the best of our knowledge, authentication
cannot be done solely in-band, but needs external
infrastructure. The most common methods used in practice rely on
public key encryption.</p>
<p><em>Web of trust</em> (used by <a href="https://en.wikipedia.org/wiki/OpenPGP">OpenPGP</a>) is a decentralised public key
infrastructure. It relies on out-of-band verification of public keys
and transitivity of trust. If Bob signed Alice's public key, and
Charlie trusts Bob (and signed his public key), then Charlie can trust
that Alice's public key is hers.</p>
<p><em>Public key infrastructure</em> (used by <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">TLS</a>) relies on trust
anchors which are communicated out-of-band (e.g. distributed with the
client software). In order to authenticate a server, a chain of trust
between a trust anchor and the server certificate (public key) is
established. Only those clients which have the trust anchor deployed
can verify the authenticity of the server.</p>
<h3>X.509 public key infrastructure</h3>
<p><a href="https://en.wikipedia.org/wiki/X.509">X.509</a> is an ITU standard for a public key infrastructure,
developed in 1988. Amongst other things, it specifies the format of
certificates, their attributes, revocation lists, and a path
validation algorithm. X.509 certificates are encoded using abstract
syntax notation one (ASN.1).</p>
<p>A <em>certificate</em> contains a public key, a subject (server name), a
validity period, a purpose (i.e. key usage), an issuer, and
possibly other extensions. All components mentioned in the certificate
are signed by an issuer.</p>
<p>A <em>certificate authority</em> (CA) receives a certificate signing request
from a server operator. It verifies that this signing request is
legitimate (e.g. requested server name is owned by the server
operator) and signs the request. The CA certificate must be trusted by
all potential clients. A CA can also issue intermediate CA
certificates, which are allowed to sign certificates.</p>
<p>When a server certificate or intermediate CA certificate is
compromised, the CA publishes this certificate in its certificate
revocation list (CRL), which each client should poll periodically.</p>
<p>The following certificates are exchanged before a TLS session:</p>
<ul>
<li>CA -&gt; Client: CA certificate, installed as trust anchor on the client
</li>
<li>Server -&gt; CA: certificate request, to be signed by the CA
</li>
<li>CA -&gt; Server: signed server certificate
</li>
</ul>
<p>During the TLS handshake the server sends the certificate chain to the
client. When a client wants to verify a certificate, it has to verify
the signatures of the entire chain, and find a trust anchor which
signed the outermost certificate. Further constraints, such as the
maximum chain length and the validity period, are checked as
well. Finally, the server name in the server certificate is checked to
match the expected identity.
For an example, you can see the sequence diagram of the TLS handshake your browser makes when you visit our <a href="https://tls.nqsb.io">demonstration server</a>.</p>
<h3>Example code for verification</h3>
<p>OpenSSL implements <a href="https://tools.ietf.org/html/rfc5280">RFC5280</a> path validation, but there is no
implementation to validate the identity of a certificate. This has to
be implemented by each client, which is rather complex (e.g. in
<a href="https://github.com/freebsd/freebsd/blob/bf1a15b165af779577b0278b3d47151edb0d47f9/lib/libfetch/common.c#L326-665">libfetch</a> it spans over more than 300 lines). A client of the
<code>ocaml-x509</code> library (such as our <a href="https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lwt/examples/http_client.ml">http-client</a>) has to
write only two lines of code:</p>
<pre><code class="language-OCaml">lwt authenticator = X509_lwt.authenticator (`Ca_dir ca_cert_dir) in
lwt (ic, oc) =
  Tls_lwt.connect_ext
    (Tls.Config.client_exn ~authenticator ())
    (host, port)
</code></pre>
<p>The authenticator uses the default directory where trust anchors are
stored (<a href="https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lwt/examples/ex_common.ml#L6">'ca_cert_dir'</a>), and this authenticator is
passed to the <a href="https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lwt/tls_lwt.ml#L227">'connect_ext'</a> function. This initiates
the TLS handshake, and passes the trust anchors and the hostname to
the TLS library.</p>
<p>During the client handshake when the certificate chain is received by
the server, the given authenticator and hostname are used to
authenticate the certificate chain (in <a href="https://github.com/mirleft/ocaml-tls/blob/6dc9258a38489665abf2bd6cdbed8a1ba544d522/lib/handshake_client.ml#L84">'validate_chain'</a>):</p>
<pre><code class="language-OCaml">match
 X509.Authenticator.authenticate ?host:server_name authenticator stack
with
 | `Fail SelfSigned         -&gt; fail Packet.UNKNOWN_CA
 | `Fail NoTrustAnchor      -&gt; fail Packet.UNKNOWN_CA
 | `Fail CertificateExpired -&gt; fail Packet.CERTIFICATE_EXPIRED
 | `Fail _                  -&gt; fail Packet.BAD_CERTIFICATE
 | `Ok                      -&gt; return server_cert
</code></pre>
<p>Internally, <code>ocaml-x509</code> extracts the hostname list from a
certificate in <a href="https://github.com/mirleft/ocaml-x509/blob/7bd25d152445263d7659c653e4a761222f43c75b/lib/certificate.ml#L134-144">'cert_hostnames'</a>, and the
<a href="https://github.com/mirleft/ocaml-x509/blob/7bd25d152445263d7659c653e4a761222f43c75b/lib/certificate.ml#L325-L346">wildcard or strict matcher</a> compares it to the input.
In total, this is less than 50 lines of pure OCaml code.</p>
<h3>Problems in X.509 verification</h3>
<p>Several weaknesses in the verification of X.509 certificates have been
discovered, ranging from cryptographic attacks due to
<a href="http://www.win.tue.nl/~bdeweger/CollidingCertificates/ddl-full.pdf">collisions in hash algorithms</a> (<a href="http://www.win.tue.nl/hashclash/rogue-ca/">practical</a>) over
<a href="http://www.blackhat.com/presentations/bh-usa-09/MARLINSPIKE/BHUSA09-Marlinspike-DefeatSSL-SLIDES.pdf">misinterpretation of the name</a> in the certificate (a C
string is terminated by a null byte), and treating X.509 version 1
certificates always as a <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0092">trust anchor in GnuTLS</a>.</p>
<p>An <a href="https://crypto.stanford.edu/~dabo/pubs/abstracts/ssl-client-bugs.html">empirical study of software that does certificate
verification</a> showed that badly designed APIs are the
root cause of vulnerabilities in this area. They tested various
implementations by using a list of certificates, which did not form a
chain, and would not authenticate due to being self-signed, or
carrying a different server name.</p>
<p>Another recent empirical study (<a href="http://www.cs.utexas.edu/~suman/publications/frankencert.pdf">Frankencert</a>) generated random
certificates and validated these with various stacks. They found lots
of small issues in nearly all certificate verification stacks.</p>
<p>Our implementation mitigates against some of the known attacks: we
require a complete valid chain, check the extensions of a certificate,
and implement hostname checking as specified in <a href="https://tools.ietf.org/html/rfc6125">RFC6125</a>. We have a
<a href="https://github.com/mirleft/ocaml-x509/tree/master/tests">test suite</a> with over 3200 tests and multiple CAs. We do not yet discard
certificates which use MD5 as hash algorithm. Our TLS stack
requires certificates to have at least 1024 bit RSA keys.</p>
<h3>X.509 library internals</h3>
<p>The <code>x509</code> library uses <a href="https://github.com/mirleft/ocaml-asn-combinators">asn-combinators</a> to parse X.509 certificates and
the <a href="https://github.com/mirleft/ocaml-nocrypto">nocrypto</a> library for signature verification
(which we wrote about <a href="http://mirage.io/blog/introducing-nocrypto">previously</a>).
At the moment we do not yet
expose certificate builders from the library, but focus on certificate parsing
and certificate authentication.</p>
<p>The <a href="https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/x509.ml">x509</a> module provides modules which parse
PEM-encoded (<a href="https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/x509.ml#L18">pem</a>) certificates (<a href="https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/x509.ml#L85">Cert</a>)
and private keys
(<a href="https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/x509.ml#L105">Pk</a>), and an authenticator module
(<a href="https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/x509.ml#L123">Authenticators</a>).</p>
<p>So far we have two authenticators implemented:</p>
<ul>
<li><a href="https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/x509.ml#L137">'chain_of_trust'</a>, which implements the basic path
validation algorithm from <a href="https://tools.ietf.org/html/rfc5280">RFC5280</a> (section 6) and the hostname
validation from <a href="https://tools.ietf.org/html/rfc6125">RFC6125</a>. To construct such an authenticator, a
timestamp and a list of trust anchors is needed.
</li>
<li><a href="https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/x509.ml#L142">'null'</a>, which always returns success.
</li>
</ul>
<p>The method <a href="https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/x509.mli#L42">'authenticate'</a>, to be called when a
certificate stack should be verified, receives an authenticator, a
hostname and the certificate stack. It returns either <code>Ok</code> or <code>Fail</code>.</p>
<p>Our <a href="https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/asn_grammars.ml#L734">certificate type</a> is very similar to the described structure in the RFC:</p>
<pre><code class="language-OCaml">type tBSCertificate = {
  version    : [ `V1 | `V2 | `V3 ] ;
  serial     : Z.t ;
  signature  : Algorithm.t ;
  issuer     : Name.dn ;
  validity   : Time.t * Time.t ;
  subject    : Name.dn ;
  pk_info    : PK.t ;
  issuer_id  : Cstruct.t option ;
  subject_id : Cstruct.t option ;
  extensions : (bool * Extension.t) list
}

type certificate = {
  tbs_cert       : tBSCertificate ;
  signature_algo : Algorithm.t ;
  signature_val  : Cstruct.t
}
</code></pre>
<p>The certificate itself wraps the to be signed part (<a href="https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/asn_grammars.ml#L734">'tBSCertificate'</a>),
the used signature algorithm, and the actual signature. It consists of
a version, serial number, issuer, validity, subject, public key
information, optional issuer and subject identifiers, and a list of
extensions -- only version 3 certificates may have extensions.</p>
<p>The <a href="https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/certificate.mli">'certificate'</a> module implements the actual
authentication of certificates, and provides some useful getters such
as <a href="https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/certificate.ml#L91">'cert_type'</a>, <a href="https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/certificate.ml#L95">'cert_usage'</a>, and
<a href="https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/certificate.ml#L100">'cert_extended_usage'</a>. The main entry for
authentication is <a href="https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/certificate.ml#L419">'verify_chain_of_trust'</a>,
which checks correct signatures of the chain, extensions and validity
of each certificate, and the hostname of the server certificate.</p>
<p>The grammar of X.509 certificates is developed in the
<a href="https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/asn_grammars.ml">'asn_grammars'</a> module, and the object
identifiers are gathered in the <a href="https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/registry.ml">'registry'</a> module.</p>
<h3>Implementation of certificate verification</h3>
<p>We provide the function <a href="https://github.com/mirleft/ocaml-x509/blob/7bd25d152445263d7659c653e4a761222f43c75b/lib/certificate.ml#L438">'valid_cas'</a>, which takes a
timestamp and a list of certificate authorities. Each certificate
authority is checked to be <a href="https://github.com/mirleft/ocaml-x509/blob/7bd25d152445263d7659c653e4a761222f43c75b/lib/certificate.ml#L282">valid</a>, self-signed,
correctly signed, and having
<a href="https://github.com/mirleft/ocaml-x509/blob/7bd25d152445263d7659c653e4a761222f43c75b/lib/certificate.ml#L277">proper X.509 v3 extensions</a>.
As mentioned above, version 1 and version 2
certificates do not contain extensions. For a version 3 certificate,
<a href="https://github.com/mirleft/ocaml-x509/blob/7bd25d152445263d7659c653e4a761222f43c75b/lib/certificate.ml#L206">'validate_ca_extensions'</a> is called: The
basic constraints extensions must be present, and its value must be
true. Also, key usage must be present and the certificate must be
allowed to sign certificates. Finally, we reject the certificate if
there is any extension marked critical, apart from the two mentioned
above.</p>
<p>When we have a list of validated CA certificates, we can use these to
<a href="https://github.com/mirleft/ocaml-x509/blob/cdea2b1ae222e88a403f2d8f954a6aa31c984941/lib/certificate.ml#L419">verify the chain of trust</a>, which gets a
hostname, a timestamp, a list of trust anchors and a certificate chain
as input. It first checks that the <a href="https://github.com/mirleft/ocaml-x509/blob/7bd25d152445263d7659c653e4a761222f43c75b/lib/certificate.ml#L384">server certificate is
valid</a>, the <a href="https://github.com/mirleft/ocaml-x509/blob/7bd25d152445263d7659c653e4a761222f43c75b/lib/certificate.ml#L264">validity of the intermediate
certificates</a>, and that the <a href="https://github.com/mirleft/ocaml-x509/blob/7bd25d152445263d7659c653e4a761222f43c75b/lib/certificate.ml#L421">chain is complete</a>
(the pathlen constraint is not validated) and rooted in a trust
anchor. A server certificate is valid if the validity period matches
the current timestamp, the given hostname <a href="https://github.com/mirleft/ocaml-x509/blob/7bd25d152445263d7659c653e4a761222f43c75b/lib/certificate.ml#L333">matches</a>
its subject alternative name extension or common name (might be
wildcard or strict matching, <a href="https://tools.ietf.org/html/rfc6125">RFC6125</a>), and it does not have a
basic constraints extension which value is true.</p>
<h3>Current status of ocaml-x509</h3>
<p>We currently support only RSA certificates. We do not check revocation
lists or use the online certificate status protocol (<a href="http://en.wikipedia.org/wiki/Online_Certificate_Status_Protocol">OCSP</a>). Our
implementation does not handle name constraints and policies. However, if
any of these extensions is marked critical, we refuse to validate the
chain. To keep our main authentication free of side-effects, it currently uses
the timestamp when the authenticator was created rather than when it is used
(this isn't a problem if lifetime of the OCaml-TLS process is comparatively
short, as in the worst case the lifetime of the certificates can be extended by
the lifetime of the process).</p>
<p>We invite people to read through the
<a href="https://github.com/mirleft/ocaml-x509/blob/7bd25d152445263d7659c653e4a761222f43c75b/lib/certificate.ml">certificate verification</a> and the
<a href="https://github.com/mirleft/ocaml-x509/blob/7bd25d152445263d7659c653e4a761222f43c75b/lib/asn_grammars.ml">ASN.1 parsing</a>. We welcome discussion on the
<a href="http://lists.xenproject.org/archives/html/mirageos-devel/">mirage-devel mailing list</a> and bug reports
on the <a href="https://github.com/mirleft/ocaml-x509/issues">GitHub issue tracker</a>.</p>
<hr />
<p>Posts in this TLS series:</p>
<ul>
<li><a href="http://mirage.io/blog/introducing-ocaml-tls">Introducing transport layer security (TLS) in pure OCaml</a>
</li>
<li><a href="http://mirage.io/blog/introducing-nocrypto">OCaml-TLS: building the nocrypto library core</a>
</li>
<li><a href="http://mirage.io/blog/introducing-x509">OCaml-TLS: adventures in X.509 certificate parsing and validation</a>
</li>
<li><a href="http://mirage.io/blog/introducing-asn1">OCaml-TLS: ASN.1 and notation embedding</a>
</li>
<li><a href="http://mirage.io/blog/ocaml-tls-api-internals-attacks-mitigation">OCaml-TLS: the protocol implementation and mitigations to known attacks</a>
</li>
</ul>
|js};
      };
      {
        updated = {js|2014-07-09 16:00|js};
        authors =
          [
            {
              name = {js|David Kaloper|js};
              uri = Some {js|https://github.com/pqwy|js};
              email = Some {js|david.mersinjak@cl.cam.ac.uk|js};
            };
          ];
        subject = {js|OCaml-TLS: building the nocrypto library core|js};
        permalink = {js|introducing-nocrypto|js};
        body =
          {js|<p><em>This is the second in a series of posts that introduce new libraries for a pure OCaml implementation of TLS.
You might like to begin with the <a href="https://mirage.io/blog/introducing-ocaml-tls">introduction</a>.</em></p>
<h3>What is nocrypto?</h3>
<p><a href="https://github.com/mirleft/ocaml-nocrypto">nocrypto</a> is the small cryptographic library behind the
<a href="https://github.com/mirleft/ocaml-tls">ocaml-tls</a> project. It is built to be straightforward to use, adhere to
functional programming principles and able to run in a Xen-based unikernel.
Its major use-case is <code>ocaml-tls</code>, which we <a href="https://mirage.io/blog/introducing-ocaml-tls">announced yesterday</a>, but we do intend to provide
sufficient features for it to be more widely applicable.</p>
<p>&quot;Wait, you mean you wrote your own <em>crypto library</em>?&quot;</p>
<h3>&quot;Never write your own crypto&quot;</h3>
<p>Everybody seems to recognize that cryptography is horribly difficult. Building
cryptography, it is all too easy to fall off the deep end and end up needing to
make decisions only a few, select specialists can make. Worse, any mistake is
difficult to uncover but completely compromises the security of the system. Or
in Bruce Schneier's <a href="https://www.schneier.com/essays/archives/1998/01/security_pitfalls_in.html">words</a>:</p>
<blockquote>
<p>Building a secure cryptographic system is easy to do badly, and very difficult
to do well. Unfortunately, most people can't tell the difference. In other
areas of computer science, functionality serves to differentiate the good from
the bad: a good compression algorithm will work better than a bad one; a bad
compression program will look worse in feature-comparison charts. Cryptography
is different. Just because an encryption program works doesn't mean it is
secure.</p>
</blockquote>
<p>Obviously, it would be far wiser not to attempt to do this and instead reuse
good, proven work done by others. And with the wealth of free cryptographic
libraries around, one gets to take their pick.</p>
<p>So to begin with, we turned to <a href="https://forge.ocamlcore.org/projects/cryptokit/">cryptokit</a>, the more-or-less
standard cryptographic library in the OCaml world. It has a decent coverage of
the basics: some stream ciphers (ARC4), some block ciphers (AES, 3DES and
Blowfish) the core hashes (MD5, SHA, the SHA2 family and RIPEMD) and the
public-key primitives (Diffie-Hellman and RSA). It is also designed with
composability in mind, exposing various elements as stream-transforming objects
that can be combined on top of one another.</p>
<p>Unfortunately, its API was a little difficult to use. Suppose you have a secret
key, an IV and want to use AES-128 in CBC mode to encrypt a bit of data. You do
it like this:</p>
<pre><code class="language-OCaml">let key = &quot;abcd1234abcd1234&quot;
and iv  = &quot;1234abcd1234abcd&quot;
and msg = &quot;fire the missile&quot;

let aes     = new Cryptokit.Block.aes_encrypt key
let aes_cbc = new Cryptokit.Block.cbc_encrypt ~iv aes

let cip =
  let size =
    int_of_float (ceil (float String.(length msg) /. 16.) *. 16.) in
  String.create size

let () = aes_cbc#transform msg 0 cip 0
</code></pre>
<p>At this point, <code>cip</code> contains our secret message. This being CBC, both <code>msg</code> and
the string the output will be written into (<code>cip</code>) need to have a size that is a
multiple of the underlying block size. If they do not, bad things will
happen -- silently.</p>
<p>There is also the curious case of hashing-object states:</p>
<pre><code class="language-OCaml">let md5 = Cryptokit.Hash.md5 ()

let s1 = Cryptokit.hash_string md5 &quot;bacon&quot;
let s2 = Cryptokit.hash_string md5 &quot;bacon&quot;
let s3 = Cryptokit.hash_string md5 &quot;bacon&quot;

(*
  s1 = &quot;x\\019%\\142\\248\\198\\1822\\221\\232\\204\\128\\246\\189\\166/&quot;
  s2 = &quot;'\\\\F\\017\\234\\172\\196\\024\\142\\255\\161\\145o\\142\\128\\197&quot;
  s3 = &quot;'\\\\F\\017\\234\\172\\196\\024\\142\\255\\161\\145o\\142\\128\\197&quot;
*)
</code></pre>
<p>The error here is to try and carry a single instantiated hashing object around,
while trying to get hashes of distinct strings. But with the convergence after
the second step, the semantics of the hashing object still remains unclear to
us.</p>
<p>One can fairly easily overcome the API style mismatches by making a few
specialized wrappers, of course, except for two major problems:</p>
<ul>
<li>
<p>Cryptokit is pervasively stateful. While this is almost certainly a result of
performance considerations combined with its goals of ease of
compositionality, it directly clashes with the fundamental design property of
the TLS library we wanted to use it in: our <code>ocaml-tls</code> library is stateless. We need to
be able to represent the state the encryption engine is in as a value.</p>
</li>
<li>
<p>Cryptokit operates on strings. As a primary target of <code>ocaml-tls</code> was
<a href="https://mirage.io/">Mirage</a>, and Mirage uses separate, non-managed regions of memory to
store network data in, we need to be able to handle foreign-allocated
storage. This means <code>Bigarray</code> (as exposed by <code>Cstruct</code>), and it seems just
plain wrong to negate all the careful zero-copy architecture of the stack
below by copying everything into and out of strings.</p>
</li>
</ul>
<p>There are further problems. For example, Cryptokit makes no attempts to combat
well-known timing vulnerabilities. It has no support for elliptic curves. And it
depends on the system-provided random number generator, which does not exist
when running in the context of a unikernel.</p>
<p>At this point, with the <em>de facto</em> choice off the table, it's probably worth
thinking about writing OCaml bindings to a rock-solid cryptographic library
written in C.</p>
<p><a href="http://nacl.cr.yp.to/">NaCl</a> is a modern, well-regarded crypto implementation, created by a
group of pretty famous and equally well-regarded cryptographers, and was the
first choice. Or at least its more approachable and packageable <a href="http://labs.opendns.com/2013/03/06/announcing-sodium-a-new-cryptographic-library/">fork</a>
was, which already had <a href="https://github.com/dsheets/ocaml-sodium">OCaml bindings</a>. Unfortunately, <code>NaCl</code>
provides a narrow selection of implementations of various cryptographic
primitives, the ones its authors thought were best-of-breed (for example, the
only symmetric ciphers it implements are (X-)Salsa and AES in CTR mode). And
they are probably right (in some aspects they are <em>certainly</em> right), but NaCl
is best used for implementations of newly-designed security protocols. It is
simply too opinionated to support an old, standardized behemoth like TLS.</p>
<p>Then there is <a href="https://www.openssl.org/docs/crypto/crypto.html">crypto</a>, the library OpenSSL is built on top of. It
is quite famous and provides optimized implementations of a wide range of
cryptographic algorithms. It also contains upwards of 200,000 lines of C and a
very large API footprint, and it's unclear whether it would be possible to run
it in the unikernel context. Recently, the parent project it is embedded in has
become highly suspect, with one high-profile vulnerability piling on top of
another and at least <a href="http://www.libressl.org/">two</a> <a href="https://boringssl.googlesource.com/boringssl/">forks</a> so far attempting to
clean the code base. It just didn't feel like a healthy code base to build
a new project on.</p>
<p>There are other free cryptographic libraries in C one could try to bind, but at
a certain point we faced the question: is the work required to become intimately
familiar with the nuances and the API of an existing code base, and create
bindings for it in OCaml, really that much smaller than writing one from
scratch? When using a full library one commits to its security decisions and
starts depending on its authors' time to keep it up to date -- maybe this
effort is better spent in writing one in the first place.</p>
<p>Tantalizingly, the length of the single OCaml source file in <code>Cryptokit</code> is
2260 lines.</p>
<p>Maybe if we made <strong>zero</strong> decisions ourselves, informed all our work by published
literature and research, and wrote the bare minimum of code needed, it might not
even be dead-wrong to do it ourselves?</p>
<p>And that is the basic design principle. Do nothing fancy. Do only documented
things. Don't write too much code. Keep up to date with security research. Open
up and ask people.</p>
<h3>The anatomy of a simple crypto library</h3>
<p><code>nocrypto</code> uses bits of C, similarly to other cryptographic libraries written in
high-level languages.</p>
<p>This was actually less of a performance concern, and more of a security one: for
the low-level primitives which are tricky to implement and for which known,
compact and widely used code already exists, the implementation is probably
better reused. The major pitfall we hoped to avoid that way are side-channel
attacks.</p>
<p>We use public domain (or BSD licenced) <a href="https://github.com/mirleft/ocaml-nocrypto/tree/master/src/native">C sources</a> for the
simple cores of AES, 3DES, MD5, SHA and SHA2. The impact of errors in this code
is constrained: they contain no recursion, and they perform no allocation,
simply filling in caller-supplied fixed-size buffer by appropriate bytes.</p>
<p>The block implementations in C have a simple API that requires us to provide the
input and output buffers and a key, writing the single encrypted (or decrypted)
block of data into the buffer. Like this:</p>
<pre><code class="language-C">void rijndaelEncrypt(const unsigned long *rk, int nrounds,
  const unsigned char plaintext[16], unsigned char ciphertext[16]);

void rijndaelDecrypt(const unsigned long *rk, int nrounds,
  const unsigned char ciphertext[16], unsigned char plaintext[16]);
</code></pre>
<p>The hashes can initialize a provided buffer to serve as an empty accumulator,
hash a single chunk of data into that buffer and convert its contents into a
digest, which is written into a provided fixed buffer.</p>
<p>In other words, all the memory management happens exclusively in OCaml and all
the buffers passed into the C layer are tracked by the garbage collector (GC).</p>
<h3>Symmetric ciphers</h3>
<p>So far, the only provided ciphers are AES, 3DES and ARC4, with ARC4 implemented
purely in OCaml (and provided only for TLS compatibility and for testing).</p>
<p>AES and 3DES are based on core C code, on top of which we built some standard
<a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation">modes of operation</a> in OCaml. At the moment we support ECB, CBC
and CTR. There is also a nascent <a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode">GCM</a> implementation which is, at the time
of writing, known not to be optimal and possibly prone to timing attacks, and
which we are still working on.</p>
<p>The exposed API strives to be simple and value-oriented. Each mode of each
cipher is packaged up as a module with a similar signature, with a pair of
functions for encryption and decryption. Each of those essentially takes a key
and a byte buffer and yields the resulting byte buffer, minimising hassle.</p>
<p>This is how you encrypt a message:</p>
<pre><code class="language-OCaml">open Nocrypto.Block

let key = AES.CBC.of_secret Cstruct.(of_string &quot;abcd1234abcd1234&quot;)
and iv  = Cstruct.of_string &quot;1234abcd1234abcd&quot;
and msg = Cstruct.of_string &quot;fire the missile&quot;

let { AES.CBC.message ; iv } = AES.CBC.encrypt ~key ~iv msg
</code></pre>
<p>The hashes implemented are just MD5, SHA and the SHA2 family. Mirroring the
block ciphers, they are based on C cores, with the HMAC construction provided in
OCaml. The API is similarly simple: each hash is a separate module with the same
signature, providing a function that takes a byte buffer to its digest, together
with several stateful operations for incremental computation of digests.</p>
<p>Of special note is that our current set of C sources will probably soon be
replaced. AES uses code that is vulnerable to a <a href="http://cr.yp.to/antiforgery/cachetiming-20050414.pdf">timing attack</a>,
stemming from the fact that substitution tables are loaded into the CPU cache
as-needed. The code does not take advantage of the <a href="https://en.wikipedia.org/wiki/AES_instruction_set">AES-NI</a>
instructions present in modern CPUs that allow AES to be hardware-assisted. SHA
and SHA2 cores turned out to be (comparatively) ill-performing, and static
analysis already uncovered some potential memory issues, so we are looking for
better implementations.</p>
<h3>Public-key cryptography</h3>
<p>Bignum arithmetic is provided by the excellent <a href="https://forge.ocamlcore.org/projects/zarith">zarith</a> library, which
in turn uses <a href="https://gmplib.org/">GMP</a>. This might create some portability problems later on,
but as GMP is widely used and well rounded code base which also includes some of
the needed auxiliary number-theoretical functions (its slightly extended
Miller-Rabin probabilistic primality test and the fast next-prime-scanning
function), it seemed like a much saner choice than redoing it from scratch.</p>
<p>The <a href="https://github.com/mirleft/ocaml-nocrypto/blob/a52bba2dcaf1c5fd45249588254dff2722e9f960/src/rsa.mli">RSA</a> module provides the basics: raw encryption and decryption,
<a href="https://en.wikipedia.org/wiki/PKCS_1">PKCS1</a>-padded versions of the same operations, and PKCS1 signing and
signature verification. It can generate RSA keys, which it does simply by
finding two large primes, in line with <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.310.4183">Rivest's</a> own
recommendation.</p>
<p>Notably, RSA implements the standard <a href="https://en.wikipedia.org/wiki/Blinding_(cryptography)">blinding</a> technique which can mitigate
some side-channel attacks, such as timing or <a href="http://www.cs.tau.ac.il/~tromer/acoustic/">acoustic</a>
cryptanalysis. It seems to foil even stronger, <a href="http://eprint.iacr.org/2013/448.pdf">cache eviction</a>
based attacks, but as of now, we are not yet completely sure.</p>
<p>The <a href="https://github.com/mirleft/ocaml-nocrypto/blob/a52bba2dcaf1c5fd45249588254dff2722e9f960/src/dh.mli">Diffie-Hellman</a> module is also relatively basic. We implement some
<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.56.1921">widely</a> <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.21.639">recommended</a> checks on the incoming public key to
mitigate some possible MITM attacks, the module can generate strong DH groups
(using safe primes) with guaranteed large prime-order subgroup, and we provide
a catalogue of published DH groups ready for use.</p>
<h3>Randomness</h3>
<p>Random number generation used to be a chronically overlooked part of
cryptographic libraries, so much so that nowadays one of the first questions
about a crypto library is, indeed, &quot;Where does it get randomness from?&quot;</p>
<p>It's an important question. A cryptographic system needs unpredictability in
many places, and violating this causes catastrophic <a href="https://www.debian.org/security/2008/dsa-1571">failures</a>.</p>
<p><code>nocrypto</code> contains its own implementation of <a href="https://www.schneier.com/fortuna.html">Fortuna</a>. Like
<a href="https://www.schneier.com/yarrow.html">Yarrow</a>, Fortuna uses a strong block cipher in CTR mode (AES in our
case) to produce the pseudo-random stream, a technique that is considered as
unbreakable as the underlying cipher.</p>
<p>The stream is both self-rekeyed, and rekeyed with the entropy gathered into its
accumulator pool. Unlike the earlier designs, however, Fortuna is built without
entropy estimators, which usually help the PRNG decide when to actually convert
the contents of an entropy pool into the new internal state. Instead, Fortuna
uses a design where the pools are fed round-robin, but activated with an
exponential backoff. There is <a href="https://eprint.iacr.org/2014/167">recent research</a> showing this
design is essentially sound: after a state compromise, Fortuna wastes no more
than a constant factor of incoming entropy -- whatever the amount of entropy is
-- before coming back to an unpredictable state. The resulting design is both
simple, and robust in terms of its usage of environmental entropy.</p>
<p>The above paper also suggests a slight improvement to the accumulator regime,
yielding a factor-of-2 improvement in entropy usage over the original. We still
haven't implemented this, but certainly intend to.</p>
<p>A PRNG needs to be fed with some actual entropy to be able to produce
unpredictable streams. The library itself contains no provisions for doing this
and its PRNG needs to be fed by the user before any output can be produced. We
are <a href="https://github.com/mirage/mirage-entropy">working with the Mirage team</a> on exposing environmental
entropy sources and connecting them to our implementation of Fortuna.</p>
<h3>Above &amp; beyond</h3>
<p><code>nocrypto</code> is still very small, providing the bare minimum cryptographic
services to support TLS and related X.509 certificate operations. One of the
goals is to flesh it out a bit, adding some more widely deployed algorithms, in
hopes of making it more broadly usable.</p>
<p>There are several specific problems with the library at this stage:</p>
<p><strong>C code</strong> - As mentioned, we are seeking to replace some of the C code we use. The hash
cores are underperforming by about a factor of 2 compared to some other
implementations. AES implementation is on one hand vulnerable to a timing attack
and, on the other hand, we'd like to make use of hardware acceleration for this
workhorse primitive -- without it we lose about an order of magnitude of
performance.</p>
<p>Several options were explored, ranging from looking into the murky waters of
OpenSSL and trying to exploit their heavily optimized primitives, to bringing
AES-NI into OCaml and redoing AES in OCaml. At this point, it is not clear which
path we'll take.</p>
<p><strong>ECC</strong> - Looking further, the library still lacks support for elliptic curve cryptography
and we have several options for solving this. Since it is used by TLS, ECC is
probably the missing feature we will concentrate on first.</p>
<p><strong>Entropy on Xen</strong> - The entropy gathering on Xen is incomplete. The current prototype uses current
time as the random seed and the effort to expose noisier sources like interrupt
timings and the RNG from dom0's kernel is still ongoing.  Dave Scott, for example, has
<a href="http://lists.xen.org/archives/html/xen-devel/2014-06/msg01492.html">submitted patches</a> to upstream Xen to make it easier to establish low-bandwidth
channels to supplies guest VMs with strong entropy from a privileged domain
that has access to physical devices and hence high-quality entropy sources.</p>
<p><strong>GC timing attacks?</strong> - There is the question of GC and timing attacks: whether doing
cryptography in a high-level language opens up a completely new surface for
timing attacks, given that GC runs are very visible in the timing profile. The
basic approach is to leave the core routines which we know are potentially
timing-sensitive (like AES) and for which we don't have explicit timing
mitigations (like RSA) to C, and invoke them atomically from the perspective of
the GC. So far, it's an open question whether the constructions built on top
of them expose further side-channels.</p>
<p>Still, we believe that the whole package is a pleasant library to work with. Its
simplicity contributes to the comparative simplicity of the entire TLS library,
and we are actively seeking input on areas that need further improvement.
Although we are obviously biased, we believe it is the best cryptographic base
library available for this project, and it might be equally suited for your next
project too!</p>
<p>We are striving to be open about the current security status of our code. You
are free to check out our <a href="https://github.com/mirleft/ocaml-nocrypto/issues?state=open">issue tracker</a> and invited to contribute
comments, ideas, and especially audits and code.</p>
<hr />
<p>Posts in this TLS series:</p>
<ul>
<li><a href="https://mirage.io/blog/introducing-ocaml-tls">Introducing transport layer security (TLS) in pure OCaml</a>
</li>
<li><a href="https://mirage.io/blog/introducing-nocrypto">OCaml-TLS: building the nocrypto library core</a>
</li>
<li><a href="https://mirage.io/blog/introducing-x509">OCaml-TLS: adventures in X.509 certificate parsing and validation</a>
</li>
<li><a href="https://mirage.io/blog/introducing-asn1">OCaml-TLS: ASN.1 and notation embedding</a>
</li>
<li><a href="https://mirage.io/blog/ocaml-tls-api-internals-attacks-mitigation">OCaml-TLS: the protocol implementation and mitigations to known attacks</a>
</li>
</ul>
|js};
      };
      {
        updated = {js|2014-07-08 15:00|js};
        authors =
          [
            {
              name = {js|Hannes Mehnert|js};
              uri = Some {js|https://github.com/hannesm|js};
              email = Some {js|hm519@cam.ac.uk|js};
            };
            {
              name = {js|David Kaloper|js};
              uri = Some {js|https://github.com/pqwy|js};
              email = Some {js|david.mersinjak@cl.cam.ac.uk|js};
            };
          ];
        subject =
          {js|Introducing transport layer security (TLS) in pure OCaml|js};
        permalink = {js|introducing-ocaml-tls|js};
        body =
          {js|<p>We announce a <strong>beta</strong> release of <code>ocaml-tls</code>, a clean-slate implementation of
<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">Transport Layer Security</a> (TLS) in
OCaml.</p>
<h3>What is TLS?</h3>
<p>Transport Layer Security (TLS) is probably the most widely deployed
security protocol on the Internet. It provides communication privacy
to prevent eavesdropping, tampering, and message forgery. Furthermore,
it optionally provides authentication of the involved endpoints. TLS
is commonly deployed for securing web services (<a href="http://tools.ietf.org/html/rfc2818">HTTPS</a>), emails,
virtual private networks, and wireless networks.</p>
<p>TLS uses asymmetric cryptography to exchange a symmetric key, and
optionally authenticate (using X.509) either or both endpoints. It
provides algorithmic agility, which means that the key exchange
method, symmetric encryption algorithm, and hash algorithm are
negotiated.</p>
<h3>TLS in OCaml</h3>
<p>Our implementation <a href="https://github.com/mirleft/ocaml-tls">ocaml-tls</a> is already able to interoperate with
existing TLS implementations, and supports several important TLS extensions
such as server name indication (<a href="https://tools.ietf.org/html/rfc4366">RFC4366</a>, enabling virtual hosting)
and secure renegotiation (<a href="https://tools.ietf.org/html/rfc5746">RFC5746</a>).</p>
<p>Our [demonstration server][^7] runs <code>ocaml-tls</code> and renders exchanged
TLS messages in nearly real time by receiving a trace of the TLS
session setup. If you encounter any problems, please give us [feedback][^14].</p>
<p><code>ocaml-tls</code> and all dependent libraries are available via [OPAM][^18] (<code>opam install tls</code>). The <a href="https://github.com/mirleft/ocaml-tls">source is available</a>
under a BSD license. We are primarily working towards completeness of
protocol features, such as client authentication, session resumption, elliptic curve and GCM
cipher suites, and have not yet optimised for performance.</p>
<p><code>ocaml-tls</code> depends on the following independent libraries: [ocaml-nocrypto][^6] implements the
cryptographic primitives, [ocaml-asn1-combinators][^5] provides ASN.1 parsers/unparsers, and
[ocaml-x509][^8] implements the X509 grammar and certificate validation (<a href="https://tools.ietf.org/html/rfc5280">RFC5280</a>). <a href="https://github.com/mirleft/ocaml-tls">ocaml-tls</a> implements TLS (1.0, 1.1 and 1.2; <a href="https://tools.ietf.org/html/rfc2246">RFC2246</a>,
<a href="https://tools.ietf.org/html/rfc4346">RFC4346</a>, <a href="https://tools.ietf.org/html/rfc5246">RFC5246</a>).</p>
<p>We invite the community to audit and run our code, and we are particularly interested in discussion of our APIs.
Please use the [mirage-devel mailing list][^9] for discussions.</p>
<p><strong>Please be aware that this release is a <em>beta</em> and is missing external code audits.
It is not yet intended for use in any security critical applications.</strong></p>
<p>In our [issue tracker][^14] we transparently document known attacks against TLS and our mitigations
([checked][^4] and [unchecked][^11]).
We have not yet implemented mitigations against either the
[Lucky13][^12] timing attack or traffic analysis (e.g. [length-hiding padding][^13]).</p>
<h3>Trusted code base</h3>
<p>Designed to run on Mirage, the trusted code base of <code>ocaml-tls</code> is small. It includes the libraries already mentioned,
<a href="https://github.com/mirleft/ocaml-tls"><code>ocaml-tls</code></a>, [<code>ocaml-asn-combinators</code>][^5], [<code>ocaml-x509</code>][^8],
and [<code>ocaml-nocrypto</code>][^6] (which uses C implementations of block
ciphers and hash algorithms). For arbitrary precision integers needed in
asymmetric cryptography, we rely on [<code>zarith</code>][^15], which wraps
[<code>libgmp</code>][^16]. As underlying byte array structure we use
[<code>cstruct</code>][^17] (which uses OCaml <code>Bigarray</code> as storage).</p>
<p>We should also mention the OCaml runtime, the OCaml compiler, the
operating system on which the source is compiled and the binary is executed, as
well as the underlying hardware. Two effectful frontends for
the pure TLS core are implemented, dealing
with side-effects such as reading and writing from the network: <a href="http://ocsigen.org/lwt/api/Lwt_unix">Lwt_unix</a> and
Mirage, so applications can run directly as a Xen unikernel.</p>
<h3>Why a new TLS implementation?</h3>
<p><strong>Update:</strong>
Thanks to <a href="http://frama-c.com/">Frama-C</a> guys for <a href="https://twitter.com/spun_off/status/486535304426188800">pointing</a> <a href="https://twitter.com/spun_off/status/486536572792090626">out</a>
that <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-1266">CVE-2014-1266</a> and <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0224">CVE-2014-0224</a> are <em>not</em> memory safety issues, but
logic errors. This article previously stated otherwise.</p>
<p>There are only a few TLS implementations publicly available and most
programming languages bind to OpenSSL, an open source implementation written
in C. There are valid reasons to interface with an existing TLS library,
rather than developing one from scratch, including protocol complexity and
compatibility with different TLS versions and implementations. But from our
perspective the disadvantage of most existing libraries is that they
are written in C, leading to:</p>
<ul>
<li>Memory safety issues, as recently observed by <a href="https://en.wikipedia.org/wiki/Heartbleed">Heartbleed</a> and GnuTLS
session identifier memory corruption (<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-3466">CVE-2014-3466</a>) bugs;
</li>
<li>Control flow complexity (Apple's goto fail, <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-1266">CVE-2014-1266</a>);
</li>
<li>And difficulty in encoding state machines (OpenSSL change cipher suite
attack, <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0224">CVE-2014-0224</a>).
</li>
</ul>
<p>Our main reasons for <code>ocaml-tls</code> are that OCaml is a modern functional
language, which allows concise and declarative descriptions of the
complex protocol logic and provides type safety and memory safety to help
guard against programming errors. Its functional nature is extensively
employed in our code: the core of the protocol is written in purely
functional style, without any side effects.</p>
<p>Subsequent blog posts <a href="https://github.com/mirage/mirage/issues/257">over the coming
days</a> will examine in more detail
the design and implementation of the four libraries, as well as the security
trade-offs and some TLS attacks and our mitigations against them.  For now
though, we invite you to try out our <strong>[demonstration server][^7]</strong>
running our stack over HTTPS.  We're particularly interested in feedback on our <a href="https://github.com/mirleft/ocaml-tls">issue tracker</a> about
clients that fail to connect, and any queries from anyone reviewing the <a href="https://github.com/mirleft/">source code</a>
of the constituent libraries.</p>
<p>[^3]: http://www.openbsd.org/papers/bsdcan14-libressl/mgp00026.html)
[^4]: https://github.com/mirleft/ocaml-tls/issues?labels=security+concern&amp;page=1&amp;state=open
[^5]: https://github.com/mirleft/ocaml-asn1-combinators
[^6]: https://github.com/mirleft/ocaml-nocrypto
[^7]: https://tls.nqsb.io/
[^8]: https://github.com/mirleft/ocaml-x509
[^9]: http://lists.xenproject.org/archives/html/mirageos-devel/
[^10]: https://github.com/mirage/mirage-entropy
[^11]: https://github.com/mirleft/ocaml-tls/issues?labels=security+concern&amp;page=1&amp;state=closed
[^12]: http://www.isg.rhul.ac.uk/tls/Lucky13.html
[^13]: http://tools.ietf.org/html/draft-pironti-tls-length-hiding-02
[^14]: https://github.com/mirleft/ocaml-tls/issues
[^15]: https://forge.ocamlcore.org/projects/zarith
[^16]: https://gmplib.org/
[^17]: https://github.com/mirage/ocaml-cstruct
[^18]: https://opam.ocaml.org/packages/tls/tls.0.1.0/</p>
<hr />
<p>Posts in this TLS series:</p>
<ul>
<li><a href="http://mirage.io/blog/introducing-ocaml-tls">Introducing transport layer security (TLS) in pure OCaml</a>
</li>
<li><a href="http://mirage.io/blog/introducing-nocrypto">OCaml-TLS: building the nocrypto library core</a>
</li>
<li><a href="http://mirage.io/blog/introducing-x509">OCaml-TLS: adventures in X.509 certificate parsing and validation</a>
</li>
<li><a href="http://mirage.io/blog/introducing-asn1">OCaml-TLS: ASN.1 and notation embedding</a>
</li>
<li><a href="http://mirage.io/blog/ocaml-tls-api-internals-attacks-mitigation">OCaml-TLS: the protocol implementation and mitigations to known attacks</a>
</li>
</ul>
|js};
      };
      {
        updated = {js|2014-07-08 11:00|js};
        authors =
          [
            {
              name = {js|Anil Madhavapeddy|js};
              uri = Some {js|http://anil.recoil.org|js};
              email = Some {js|anil@recoil.org|js};
            };
          ];
        subject = {js|MirageOS 1.2 released and the 2.0 runup begins|js};
        permalink = {js|mirage-1.2-released|js};
        body =
          {js|<p>Summer is in full swing here in MirageOS HQ with torrential rainstorms, searing
sunshine, and our <a href="http://www.oscon.com/oscon2014/public/schedule/detail/35024">OSCON 2014</a> talk
rapidly approaching in just a few weeks.  We've been steadily releasing point releases
since the <a href="/blog/mirage-1.1-released">first release</a> back in December, and today's <a href="https://github.com/mirage/mirage/releases/tag/v1.2.0">MirageOS
1.2.0</a> is the last of the <code>1.x</code> series.
The main improvements are usability-oriented:</p>
<ul>
<li>
<p>The Mirage frontend tool now generates a <code>Makefile</code> with a <code>make depend</code>
target, instead of directly invoking OPAM as part of <code>mirage configure</code>.
This greatly improves usability on slow platforms such as ARM, since the
output of OPAM as it builds can be inspected more easily. Users will now
need to run <code>make depend</code> to ensure they have the latest package set
before building their unikernel.</p>
</li>
<li>
<p>Improve formatting of the <code>mirage</code> output, including pretty colours!
This makes it easier to distinguish complex unikernel configurations
that have lots of deployment options.  The generated files are built
more verbosely by default to facilitate debugging, and with debug
symbols and backtraces enabled by default.</p>
</li>
<li>
<p>Added several <a href="https://github.com/mirage/mirage/tree/master/types">device module types</a>, including <code>ENTROPY</code> for random
noise, <code>FLOW</code> for stream-oriented connections, and exposed the <code>IPV4</code>
device in the <code>STACKV4</code> TCP/IP stack type.</p>
</li>
<li>
<p>Significant bugfixes in supporting libraries such as the TCP/IP
stack (primarily thanks to <a href="http://www.somerandomidiot.com/">Mindy Preston</a> fuzz testing
and finding some good <a href="https://github.com/mirage/mirage-tcpip/issues/56">zingers</a>).  There are too many
library releases to list individually here, but you can <a href="/releases">browse the changelog</a> for more details.</p>
</li>
</ul>
<p>#### Towards MirageOS 2.0</p>
<p>We've also been working hard on the <strong>MirageOS 2.x series</strong>, which introduces
a number of new features and usability improvements that emerged from actually
using the tools in practical projects.  Since there have been so many <a href="/blog/welcome-to-our-summer-hackers">new
contributors</a> recently,
<a href="http://amirchaudhry.com">Amir Chaudhry</a> is coordinating a <a href="https://github.com/mirage/mirage/issues/257">series of blog
posts</a> in the runup to
<a href="http://www.oscon.com/oscon2014/public/schedule/detail/35024">OSCON</a> that
explains the new work in depth.  Once the release rush has subsided, we'll
be working on integrating these posts into our <a href="/docs">documentation</a>
properly.</p>
<p>The new 2.0 features include the <a href="https://github.com/mirage/irmin">Irmin</a> branch-consistent distributed storage
library, the pure OCaml <a href="https://github.com/mirleft/">TLS stack</a>, <a href="https://github.com/mirage/mirage-platform/pull/93">Xen/ARM support</a> and the Conduit I/O
subsystem for <a href="http://anil.recoil.org/papers/2012-resolve-fable.pdf">mapping names to connections</a>.  Also included in the blog series
are some sample usecases on how these tie together for real applications (as a
teaser, here's a video of <a href="https://www.youtube.com/watch?v=DSzvFwIVm5s">Xen VMs booting using
Irmin</a> thanks to <a href="http://dave.recoil.org">Dave
Scott</a> and <a href="http://gazagnaire.org">Thomas Gazagnaire</a>!)</p>
<h4>Upcoming talks and tutorials</h4>
<p><a href="http://mort.io">Richard Mortier</a> and myself will be gallivanting around the world
to deliver a few talks this summer:</p>
<ul>
<li>The week of <a href="http://www.oscon.com/oscon2014">OSCON</a> on July 20th-24th.  Please get in touch via the conference website or a direct e-mail, or <a href="http://www.oscon.com/oscon2014/public/schedule/detail/35024">attend our talk</a> on Thursday morning.
There's a <a href="https://realworldocaml.org">Real World OCaml</a> book signing on Tuesday morning for the super keen as well.
</li>
<li>The <a href="http://ecoop14.it.uu.se/programme/ecoop-school.php">ECOOP summer school</a> in beautiful Uppsala in Sweden on Weds 30th July.
</li>
<li>I'll be presenting the Irmin and Xen integration at <a href="http://events.linuxfoundation.org/events/xen-project-developer-summit">Xen Project Developer Summit</a> in
Chicago on Aug 18th (as part of LinuxCon North America).  <a href="http://mort.io">Mort</a> and <a href="http://somerandomidiot.com">Mindy</a> (no jokes please) will be
joining the community panel about <a href="/blog/applying-for-gsoc2014">GSoC/OPW</a> participation.
</li>
</ul>
<p>As always, if there are any particular topics you would like to see more
on, then please comment on the <a href="https://github.com/mirage/mirage/issues/257">tracking issue</a>
or <a href="/community">get in touch directly</a>.  There will be a lot of releases coming out
in the next few weeks (including a beta of the new version of <a href="http://opam.ocaml.org">OPAM</a>,
so <a href="https://github.com/mirage/mirage/issues">bug reports</a> are very much appreciated for those
things that slip past <a href="http://travis-ci.org">Travis CI</a>!</p>
|js};
      };
      {
        updated = {js|2014-05-08 18:00|js};
        authors =
          [
            {
              name = {js|Anil Madhavapeddy|js};
              uri = Some {js|http://anil.recoil.org|js};
              email = Some {js|anil@recoil.org|js};
            };
          ];
        subject = {js|Welcome to the summer MirageOS hackers|js};
        permalink = {js|welcome-to-our-summer-hackers|js};
        body =
          {js|<p>Following our participation in the <a href="https://mirage.io/blog/applying-for-gsoc2014">Google Summer of Code</a> program, we've now finalised selections.  We've also got a number of other visitors joining us to hack on Mirage over the summer time, so here are introductions!</p>
<ul>
<li><strong>SSL support</strong>: <a href="https://github.com/hannesm">Hannes Mehnert</a> and <a href="https://github.com/pqwy">David Kaloper</a> have been working hard on a safe <a href="https://github.com/mirleft/ocaml-tls">OCaml TLS</a> implementation. They're going to hack on <a href="https://github.com/mirage/mirage/issues/242">integrating it all</a> into working under Xen so we can make HTTPS requests (and our Twitter bot will finally be able to tweet!).  Both are also interested in formal verification of the result, and several loooong conversations with <a href="http://www.cl.cam.ac.uk/~pes20/">Peter Sewell</a> will magically transform into machine specifications by summer's end, I'm reliably informed.
</li>
<li><strong>Cloud APIs</strong>: <a href="http://1000hippos.wordpress.com/">Jyotsna Prakash</a> will spend her summer break as part of <a href="http://www.google-melange.com/gsoc/org2/google/gsoc2014/xen_project">Google Summer of Code</a> working on improving cloud provider APIs in OCaml (modelled from her notes on how the <a href="https://github.com/avsm/ocaml-github">GitHub</a> bindings <a href="http://1000hippos.wordpress.com/2014/04/24/ocaml-github/">are built</a>).  This will let the <code>mirage</code> command-line tool have much more natural integration with remote cloud providers for executing the unikernels straight from a command-line.  If you see Jyotsna wandering around aimlessly muttering darkly about HTTP, JSON and REST, then the project is going well.
</li>
<li><strong>Network Stack fuzzing</strong>: <a href="http://www.somerandomidiot.com/">Mindy Preston</a> joins us for the summer after her <a href="https://www.hackerschool.com/">Hacker School</a> stay, courtesy of the <a href="https://opw.gnome.org">OPW</a> program.  She's been delving into the network stack running on EC2 and figuring out how to debug issues when the unikernel is running a cloud far, far away (see the post series here: <a href="http://www.somerandomidiot.com/blog/2014/03/14/its-a-mirage/">1</a>, <a href="http://www.somerandomidiot.com/blog/2014/03/24/advancing-toward-the-mirage/">2</a>, <a href="http://www.somerandomidiot.com/blog/2014/04/02/tying-the-knot/">3</a>, <a href="http://www.somerandomidiot.com/blog/2014/03/24/arriving-at-the-mirage/">4</a>).
</li>
<li><strong>Visualization</strong>: <a href="http://erratique.ch/contact.en">Daniel Buenzli</a> returns to Cambridge this summer to continue his work on extremely succinctly named graphics libaries.  His <a href="https://github.com/dbuenzli/vz">Vz</a>, <a href="https://github.com/dbuenzli/vg">Vg</a> and <a href="https://github.com/dbuenzli/gg">Gg</a> libaries build a set of primitives for 2D graphics programming.  Since the libraries compile to JavaScript, we're planning to use this as the basis for <a href="http://erratique.ch/software/vg/demos/rhtmlc">visualization</a> of Mirage applications via a built-in webserver.
</li>
<li><strong>Modular implicits</strong>: <a href="https://github.com/def-lkb">Frederic Bour</a>, author of the popular <a href="https://github.com/the-lambda-church/merlin">Merlin</a> IDE tool is also in Cambridge this summer working on adding modular implicits to the core OCaml language. Taking inspiration from <a href="http://www.mpi-sws.org/~dreyer/papers/mtc/main-long.pdf">Modular Type-classes</a> and Scala's <a href="http://twitter.github.io/scala_school/advanced-types.html">implicits</a>,  modular implcits allow functions to take implicit module arguments which will be filled-in by the compiler by searching the environment for a module with the appropriate type. This enables ad-hoc polymorphism in a very similar way to Haskell's type classes.
</li>
<li><strong>Irmin storage algorithms</strong>: Benjamin Farinier (from <a href="http://www.ens-lyon.eu/">ENS Lyon</a>) and Matthieu Journault (from <a href="http://www.ens-cachan.fr/">ENS Cachan</a>) will work on datastructures for the <a href="https://github.com/mirage/irmin/wiki/Getting-Started">Irmin</a> storage system that the next version of Mirage will use.  They'll be grabbing copies of the <a href="http://www.amazon.co.uk/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504">Okasaki</a> classic text and porting some of them into a branch-consistent form.
</li>
</ul>
<p>Of course, work continues apace by the rest of the team as usual, with a <a href="https://mirage.io/releases">steady stream of releases</a> that are building up to some exciting new features.  We'll be blogging about ARM support, PVHVM, Irmin storage and SSL integration just as soon as they're pushed into the stable branches.  As always, <a href="https://mirage.io/community/">get in touch</a> via the IRC channel (<code>#mirage</code> on Freenode) or the mailing lists with questions.</p>
|js};
      };
      {
        updated = {js|2014-02-25 18:00|js};
        authors =
          [
            {
              name = {js|Anil Madhavapeddy|js};
              uri = Some {js|http://anil.recoil.org|js};
              email = Some {js|anil@recoil.org|js};
            };
          ];
        subject = {js|MirageOS is in Google Summer of Code 2014|js};
        permalink = {js|applying-for-gsoc2014|js};
        body =
          {js|<p>MirageOS will part of the <a href="https://www.google-melange.com/gsoc/homepage/google/gsoc2014">Google Summer of Code</a> 2014
program, thanks to the Xen Project's participation!  It's been a few years
since I've mentored for GSoc, but I still have fond memories of some great
projects in the past (such as the legendary <a href="http://vmgl.sourceforge.net/">Quake testing</a>
we were forced to do for hours on end).  I've already received a number of
queries about this year's program from potential students, so here's a few
things to note to become a successful applicant.</p>
<ul>
<li>
<p>Students still need to apply and be accepted. Your chances of being
selected are much higher if you demonstrate some participation and
code contributions (even minor) <em>before</em> submitting an application.
Thus, even if you don't have a copy of Xen around, roll up your sleeves
and head over to the <a href="https://mirage.io/wiki/install">installation instructions</a>.</p>
</li>
<li>
<p>Contributions do not have to be just code.  They can be documentation,
help with packaging, wiki posts about a particular use, or test cases
to improve code coverage.</p>
</li>
<li>
<p>It's unlikely that we'll get students who are very familiar with both
OCaml and Xen (if you are, definitely get in touch with us!).  You should
therefore look over the <a href="http://wiki.xen.org/wiki/GSoc_2014#Mirage_OS">project ideas</a>
as a set of guidelines and not firm suggestions.  If you have a particular
thing you'd like to do with Mirage (for example, work on the JavaScript
backend, an <a href="https://github.com/andrewray/iocamljs">IPython interface</a> or
a particular protocol implementation such as XMPP, then that's fine.  Just
get in touch with us on the <a href="/community">mailing lists</a> or directly via
e-mail, and we can work through them.</p>
</li>
<li>
<p>Under some circumstances, we can provide resources such as a login to
a Xen machine, or delegated credits on a cloud provider.  Don't let that
stop you from applying for a project idea.  In general though, it's best
to only depend on your own computer resources if practical to do so.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2014-02-11 16:00|js};
        authors =
          [
            {
              name = {js|Anil Madhavapeddy|js};
              uri = Some {js|http://anil.recoil.org|js};
              email = Some {js|anil@recoil.org|js};
            };
          ];
        subject = {js|MirageOS 1.1.0: the eat-your-own-dogfood release|js};
        permalink = {js|mirage-1.1-released|js};
        body =
          {js|<p>We've just released <a href="https://github.com/ocaml/opam-repository/pull/1655">MirageOS 1.1.0</a> into OPAM.  Once the
live site updates, you should be able to run <code>opam update -u</code> and get the latest
version.  This release is the &quot;<a href="http://en.wikipedia.org/wiki/Eating_your_own_dog_food">eat our own
dogfood</a>&quot; release; as I
mentioned earlier in January, a number of the MirageOS developers have decided to
shift our own personal homepages onto MirageOS.  There's nothing better than
using our own tools to find all the little annoyances and shortcomings, and so
MirageOS 1.1.0 contains some significant usability and structural improvements
for building unikernels.</p>
<h4>Functional combinators to build device drivers</h4>
<p>MirageOS separates the
application logic from the concrete backend in use by writing the application
as an <a href="https://realworldocaml.org/v1/en/html/functors.html">OCaml functor</a>
that is parameterized over module types that represent the device driver
signature.  All of the module types used in MirageOS can be browsed in <a href="https://github.com/mirage/mirage/blob/1.1.0/types/V1.mli">one
source file</a>.</p>
<p>In MirageOS 1.1.0, <a href="http://gazagnaire.org/">Thomas Gazagnaire</a> implemented a
a <a href="https://github.com/mirage/mirage/blob/1.1.0/lib/mirage.mli#L28">combinator library</a>
that makes it easy to separate the definition of application logic from the details
of the device drivers that actually execute the code (be it a Unix binary or a
dedicated Xen kernel).  It lets us write code of this form
(taken from <a href="https://github.com/mirage/mirage-skeleton/tree/master/block">mirage-skeleton/block</a>):</p>
<pre><code>let () =
  let main = foreign &quot;Unikernel.Block_test&quot; (console @-&gt; block @-&gt; job) in
  let img = block_of_file &quot;disk.img&quot; in
  register &quot;block_test&quot; [main $ default_console $ img]
</code></pre>
<p>In this configuration fragment, our unikernel is defined as a functor over a
console and a block device by using <code>console @-&gt; block @-&gt; job</code>.  We then
define a concrete version of this job by applying the functor (using the <code>$</code>
combinator) to a default console and a file-backed disk image.</p>
<p>The combinator approach lets us express complex assemblies of device driver
graphs by writing normal OCaml code, and the <code>mirage</code> command line tool
parses this at build-time and generates a <code>main.ml</code> file that has all the
functors applied to the right device drivers. Any mismatches in module signatures
will result in a build error, thus helping to spot nonsensical combinations
(such as using a Unix network socket in a Xen unikernel).</p>
<p>This new feature is walked through in the <a href="/docs/hello-world">tutorial</a>, which
now walks you through several skeleton examples to explain all the different
deployment scenarios.  It's also followed by the <a href="/docs/mirage-www">website tutorial</a>
that explains how this website works, and how our <a href="/docs/deploying-via-ci">Travis autodeployment</a>
throws the result onto the public Internet.</p>
<p>Who will win the race to get our website up and running first?  Sadly for Anil,
<a href="http://www.cs.nott.ac.uk/~rmm/">Mort</a> is currently <a href="https://github.com/mor1/mort-www">in the
lead</a> with an all-singing, all-dancing shiny
new website.  Will he finish in the lead though? Stay tuned!</p>
<h4>Less magic in the build</h4>
<p>Something that's more behind-the-scenes, but important for easier development,
is a simplication in how we build libraries.  In MirageOS 1.0, we had several
packages that couldn't be simultaneously installed, as they had to be compiled
in just the right order to ensure dependencies.</p>
<p>With MirageOS 1.1.0, this is all a thing of the past.  All the libraries can
be installed fully in parallel, including the network stack.  The 1.1.0
<a href="https://github.com/mirage/mirage-tcpip">TCP/IP stack</a> is now built in the
style of the venerable <a href="http://www.cs.cmu.edu/~fox/foxnet.html">FoxNet</a> network
stack, and is parameterized across its network dependencies.  This means
that once can quickly assemble a custom network stack from modular components,
such as this little fragment below from <a href="https://github.com/mirage/mirage-skeleton/blob/master/ethifv4/unikernel.ml">mirage-skeleton/ethifv4/</a>:</p>
<pre><code>module Main (C: CONSOLE) (N: NETWORK) = struct

  module E = Ethif.Make(N)
  module I = Ipv4.Make(E)
  module U = Udpv4.Make(I)
  module T = Tcpv4.Flow.Make(I)(OS.Time)(Clock)(Random)
  module D = Dhcp_clientv4.Make(C)(OS.Time)(Random)(E)(I)(U)
  
</code></pre>
<p>This functor stack starts with a <code>NETWORK</code> (i.e. Ethernet) device, and then applies
functors until it ends up with a UDPv4, TCPv4 and DHCPv4 client.  See the <a href="https://github.com/mirage/mirage-skeleton/blob/master/ethifv4/unikernel.ml">full
file</a>
to see how the rest of the logic works, but this serves to illustrate how
MirageOS makes it possible to build custom network stacks out of modular
components.  The functors also make it easier to embed the network stack in
non-MirageOS applications, and the <code>tcpip</code> OPAM package installs pre-applied Unix
versions for your toplevel convenience.</p>
<p>To show just how powerful the functor approach is, the same stack can also
be mapped onto a version that uses kernel sockets simply by abstracting the
lower-level components into an equivalent that uses the Unix kernel to provide
the same functionality.  We explain how to swap between these variants in
the <a href="/wiki/hello-world">tutorials</a>.</p>
<h4>Lots of library releases</h4>
<p>While doing the 1.1.0 release in January, we've also released quite a few libraries
into <a href="https://opam.ocaml.org">OPAM</a>.  Here are some of the highlights.</p>
<p>Low-level libraries:</p>
<ul>
<li><a href="https://github.com/samoht/ocaml-mstruct/">mstruct</a> is a streaming layer for handling lists of memory buffers with a simpler read/write interface.
</li>
<li><a href="https://github.com/xapi-project/nbd/">nbd</a> is an implementation of the <a href="http://en.wikipedia.org/wiki/Network_block_device">Network Block Device</a> protocol for block drivers.
</li>
</ul>
<p>Networking and web libraries:</p>
<ul>
<li><a href="https://github.com/mirage/ocaml-ipaddr">ipaddr</a> now has IPv6 parsing support thanks to <a href="https://github.com/hhugo/">Hugo Heuzard</a> and David Sheets.  This is probably the hardest bit of adding IPv6 support to our network stack!
</li>
<li><a href="https://github.com/mirage/cowabloga">cowabloga</a> is slowly emerging as a library to handle the details of rendering Zurb Foundation websites.  It's still in active development, but being used for a few of our <a href="https://github.com/mor1/mort-www">personal websites</a> as well as this website.
</li>
<li><a href="https://github.com/avsm/ocaml-cohttp">cohttp</a> has had several releases thanks to external contributions, particular from <a href="https://github.com/rgrinberg">Rudy Grinberg</a> who added s-expression support and several <a href="https://github.com/avsm/ocaml-cohttp/blob/master/CHANGES">other improvements</a>.
</li>
<li><a href="https://github.com/avsm/ocaml-uri">uri</a> features performance improvements and the elimination of Scanf (considered <a href="http://www.lexifi.com/blog/note-about-performance-printf-and-format">rather slow</a> by OCaml standards).
</li>
<li><a href="https://github.com/mirage/ocaml-cow">cow</a> continues its impossible push to make coding HTML and CSS a pleasant experience, with better support for Markdown now.
</li>
<li>The <a href="https://github.com/avsm/ocaml-github">github</a> bindings are now also in use as part of an experiment to make <a href="http://gallium.inria.fr/blog/patch-review-on-github/">upstream OCaml development</a> easier for newcomers, thanks to Gabriel Scherer.
</li>
</ul>
<p><a href="http://dave.recoil.org">Dave Scott</a> led the splitting up of several low-level Xen libraries as part of the build simplication.  These now compile on both Xen (using the direct hypercall interface) and Unix (using the dom0 <code>/dev</code> devices) where possible.</p>
<ul>
<li><a href="https://github.com/xapi-project/ocaml-evtchn">xen-evtchn</a> for the event notification mechanism. There are a couple of wiki posts that explain how <a href="/wiki/xen-events">event channels</a> and <a href="/wiki/xen-suspend">suspend/resume</a> work in MirageOS/Xen guests.
</li>
<li><a href="https://github.com/xapi-project/ocaml-gnt">xen-gnt</a> for the grant table mechanism that controls inter-process memory.
</li>
<li>The <a href="https://github.com/mirage/io-page">io-page</a> library no longer needs Unix and Xen variants, as the interface has been standardized to work in both.
</li>
</ul>
<p>All of Dave's hacking on Xen device drivers is showcased in this <a href="https://mirage.io/wiki/xen-synthesize-virtual-disk">xen-disk wiki post</a> that
explains how you can synthesize your own virtual disk backends using MirageOS.  Xen uses a <a href="https://www.usenix.org/legacy/event/usenix05/tech/general/full_papers/short_papers/warfield/warfield.pdf">split device</a> model,
and now MirageOS lets us build <em>backend</em> device drivers that service VMs as well as the frontends!</p>
<p>Last, but not least, <a href="http://gazagnaire.org">Thomas Gazagnaire</a> has been building a brand new storage system for MirageOS guests that uses git-style branches under the hood to help coordinate clusters of unikernels.  We'll talk about how this works in a future update, but there are some cool libraries and prototypes available on OPAM for the curious.</p>
<ul>
<li><a href="https://github.com/samoht/ocaml-lazy-trie/">lazy-trie</a> is a lazy version of the Trie data structure, useful for exposing Git graphs.
</li>
<li><a href="https://github.com/samoht/ocaml-git">git</a> is a now-fairly complete implementation of the Git protocol in pure OCaml, which can interoperate with normal Git servers via the <code>ogit</code> command-line tool that it installs.
</li>
<li><a href="https://github.com/mirage/irmin">irmin</a> is the main library that abstracts Git DAGs into an OCaml programming API.  The homepage has <a href="https://github.com/mirage/irmin/wiki/Getting-Started">instructions</a> on how to play with the command-line frontend to experiment with the database.
</li>
<li><a href="https://github.com/samoht/git2fat">git2fat</a> converts a Git checkout into a FAT block image, useful when bundling up unikernels.
</li>
</ul>
<p>We'd also like to thank several conference organizers for giving us the opportunity to demonstrate MirageOS.  The talk video from <a href="http://www.infoq.com/presentations/mirage-os">QCon SF</a> is now live, and we also had a <em>great</em> time at <a href="http://fosdem.org">FOSDEM</a> recently (summarized by Amir <a href="http://nymote.org/blog/2014/fosdem-summary/">here</a>).
So lots of activities, and no doubt little bugs lurking in places (particularly around installation).  As always, please do let us know of any problem by <a href="https://github.com/mirage/mirage/issues">reporting bugs</a>, or feel free to <a href="/community">contact us</a> via our e-mail lists or IRC.  Next stop: our unikernel homepages!</p>
|js};
      };
      {
        updated = {js|2014-01-03 16:00|js};
        authors =
          [
            {
              name = {js|Richard Mortier|js};
              uri = Some {js|http://mort.io/|js};
              email = Some {js|mort@cantab.net|js};
            };
          ];
        subject = {js|Presenting Decks|js};
        permalink = {js|decks-n-drums|js};
        body =
          {js|<p>A few months ago, partly as a stunt, mostly because we could, Anil and I put together <a href="http://decks.openmirage.org/oscon13/">a presentation</a> for <a href="http://www.oscon.com/oscon2013/">OSCON'13</a> about Mirage in Mirage. That is, as a self-hosting Mirage web application that served up slides using <a href="http://lab.hakim.se/reveal-js/">RevealJS</a>. It was a bit of a hack, but it was cool (we thought!) and it worked. Several more presentations were written and given this way, at venues ranging from the [XenSummit 2013][xensummit] to [ACM FOCI 2013][foci] to the Cambridge Computer Lab's [MSc in Advanced Computer Science][acs].</p>
<p>[foci]: https://www.usenix.org/conference/foci13‎
[xensummit]: http://www.youtube.com/watch?v=3Jype6sP6MQ
[acs]: http://decks.openmirage.org/cam13/</p>
<p>With the <a href="https://mirage.io/blog/announcing-mirage10">release of Mirage 1.0</a>, <a href="http://github.com/mirage/ocaml-cohttp">CoHTTP</a>, <a href="http://github.com/mirage/cowabloga">Cowabloga</a> and
the new <a href="http://foundation.zurb.com/">Zurb Foundation</a> based <a href="https://mirage.io/">website</a>, it was time to refresh them
and as a little seasonal gift, give them a shiny new index with some actual CSS
styling. So <a href="http://decks.openmirage.org/">here they are</a>, a set of presentations that have been given
by various members of the Mirage team over the last 6 months or so. They cover
a range of topics, from general introductions to the Xen roadmap to more
detailed technical background. And, of course, as Mirage is under constant
rapid development, some of the older content may already be outdated. But <a href="http://github.com/mirage/mirage-decks">the
code for the site itself</a> serves as another example of a simple --
somewhat simpler than the <a href="https://mirage.io/">Mirage website</a> in fact -- Mirage web
application.</p>
|js};
      };
      {
        updated = {js|2013-12-19 23:00|js};
        authors =
          [
            {
              name = {js|Anil Madhavapeddy|js};
              uri = Some {js|http://anil.recoil.org|js};
              email = Some {js|anil@recoil.org|js};
            };
          ];
        subject =
          {js|MirageOS 1.0.3 released; tutorial on building this website available|js};
        permalink = {js|mirage-1.0.3-released|js};
        body =
          {js|<p>We've had a lot of people trying out MirageOS since the <a href="/blog/announcing-mirage10">1.0 release</a> last week, and so we've been steadily cutting point releases and new libraries to OPAM as they're done.
The most common build error by far has been people using outdated OPAM packages.  Do make sure that you have at least <a href="http://opam.ocaml.org/doc/Quick_Install.html">OPAM 1.1</a> installed, and that you've run <code>opam update -u</code> to get the latest package lists from the <a href="https://github.com/ocaml/opam-repository">package repository</a>.</p>
<p><a href="https://github.com/mirage/mirage/releases/tag/1.0.3">MirageOS 1.0.3</a> improves
Xen configuration generation, cleans up HTTP support, and adds support for FAT
filesystems.  Here are some of the libraries we've released this week to go along with it:</p>
<ul>
<li><a href="https://github.com/mirage/mirage-www">mirage-www</a> (update): the live website now runs on the 1.0 tools.  Explanation of how to build it in various configurations is available <a href="/wiki/mirage-www">here</a>.
</li>
<li><a href="https://github.com/samoht/alcotest">alcotest</a> (new): a lightweight and colourful test framework built over <a href="http://ounit.forge.ocamlcore.org/">oUnit</a>.  The interface is simpler to facilitate writing tests quickly, and it formats test results nicely.
</li>
<li><a href="https://github.com/mirage/mirage-block-xen">mirage-block-xen.1.0.0</a> (new): is the stable release of the Xen <code>Blkfront</code> driver for block devices.  The library supports both frontend and backend operation, but only the frontend is plumbed through to Mirage for now (although the backend can be manually configured).
</li>
<li><a href="https://github.com/mirage/mirage-block-unix">mirage-block-unix.1.2.0</a> (update): fixed some concurrency bugs and added support for buffered I/O to improve performance.
</li>
<li><a href="https://github.com/mirage/ocaml-fat">fat-filesystem.0.10.0</a> (update): copies with more sector sizes, uses buffered I/O on Unix, and adds a <code>KV_RO</code> key/value interface as well as a more complicated filesystem one.
</li>
<li><a href="https://github.com/mirage/mirage-fs-unix">mirage-fs-unix.1.0.0</a> (update): implements the <code>KV_RO</code> signature as a passthrough to a Unix filesystem.  This is convenient during development to avoid recompile cycles while changing data.
</li>
<li><a href="https://github.com/mirage/mirage-platform">mirage-xen.1.0.0</a> (update): removed several distracting-but-harmless linker warnings about code bloat.
</li>
<li><a href="https://github.com/mirage/ocaml-cohttp">cohttp.0.9.14</a> (update): supports Server-Side Events via better channel flushing, has a complete set of HTTP codes autogenerated from <a href="https://github.com/citricsquid/httpstatus.es">httpstatus.es</a> and exposes a platform-independent <code>Cohttp_lwt</code> module.
</li>
<li><a href="https://github.com/mirage/ocaml-cow">cow.0.8.1</a> (update): switch to the <a href="https://github.com/pw374/omd">Omd</a> library for Markdown parsing, which is significantly more compatible with other parsers.
</li>
<li><a href="https://github.com/samoht/ezjsonm">ezjsonm.0.2.0</a> (new): a combinator library to parse, select and manipulate JSON structures.
</li>
<li><a href="https://github.com/avsm/ezxmlm">ezxmlm.1.0.0</a> (new): a combinator library to parse, select and transform XML tags and attributes.
</li>
<li><a href="https://github.com/mirage/mirage-http-xen">mirage-http-xen</a> and <a href="https://github.com/mirage/mirage-http-unix">mirage-http-unix</a> provide the HTTP drivers on top of Cohttp for MirageOS. Although they are very similar at the moment, they will diverge as the Unix variant gains options to use kernel sockets instead of only the network stack.
</li>
</ul>
<p>We're making great progress on moving our personal homepages over to MirageOS.  The first two introductory wiki posts are also now available:</p>
<ul>
<li><a href="/wiki/hello-world">Building a hello world example</a> takes you through the basic steps to build a Unix and Xen binary.
</li>
<li><a href="/wiki/mirage-www">Building the MirageOS website</a> lets you build this website with several variants, demonstrating the Unix passthrough filesystem, the OCaml FAT filesystem library, and how to attach a network stack to your application.
</li>
</ul>
<p>As always, please feel free to report any issues via the <a href="https://github.com/mirage/mirage/issues">bug tracker</a> and ask questions on the <a href="mailto:mirageos-devel@lists.xenproject.org">mailing list</a>.</p>
|js};
      };
      {
        updated = {js|2013-12-09 12:00|js};
        authors =
          [
            {
              name = {js|Anil Madhavapeddy|js};
              uri = Some {js|http://anil.recoil.org|js};
              email = Some {js|anil@recoil.org|js};
            };
          ];
        subject = {js|MirageOS 1.0: not just a hallucination!|js};
        permalink = {js|announcing-mirage10|js};
        body =
          {js|<p><em>First</em>: read the <a href="/wiki/overview-of-mirage">overview</a> and
<a href="/wiki/technical-background">technical background</a> behind the project.</p>
<p>When we started hacking on MirageOS back in 2009, it started off looking like a
conventional OS, except written in OCaml.   The <a href="https://github.com/mirage/mirage/tree/old-master">monolithic
repository</a> contained all the
libraries and boot code, and exposed a big <code>OS</code> module for applications to use.
We used this to do several fun <a href="http://cufp.org/conference/sessions/2011/t3-building-functional-os">tutorials</a> at conferences
such as ICFP/CUFP and get early feedback.</p>
<p>As development continued though, we started to understand what it is we were
building: a <a href="http://anil.recoil.org/papers/2013-asplos-mirage.pdf">&quot;library operating system&quot;</a>.  As the number of libraries grew,
putting everything into one repository just wasn't scaling, and it made it hard
to work with third-party code.  We spent some time developing tools to make
Mirage fit into the broader OCaml ecosystem.</p>
<p>Three key things have emerged from this effort:</p>
<ul>
<li><a href="https://opam.ocaml.org">OPAM</a>, a source-based package manager for
OCaml. It supports multiple simultaneous compiler installations, flexible
package constraints, and a Git-friendly development workflow.  Since
releasing 1.0 in March 2013 and 1.1 in October, the community has leapt
in to contribute over 1800 packages in this short time.  All of the
Mirage libraries are now tracked using it, including the Xen libraries.
</li>
<li>The build system for embedded programming (such as the Xen target) is
a difficult one to get right.  After several experiments, Mirage provides
a single <strong><a href="https://github.com/mirage/mirage">command-line tool</a></strong> that
combines configuration directives (also written in OCaml) with OPAM to
make building Xen unikernels as easy as Unix binaries.
</li>
<li>All of the Mirage-compatible libraries satisfy a set of module type
signatures in a <strong><a href="https://github.com/mirage/mirage-types/blob/master/lib/v1.mli">single file</a></strong>.
This is where Mirage lives up to its name: we've gone from the early
monolithic repository to a single, standalone interface file that
describes the interfaces.  Of course, we also have libraries to go along
with this signature, and they all live in the <a href="https://github.com/mirage">MirageOS GitHub organization</a>.
</li>
</ul>
<p>With these components, I'm excited to announce that MirageOS 1.0 is finally ready
to see the light of day!  Since it consists of so many libraries, we've decided
not to have a &quot;big bang&quot; release where we dump fifty complex libraries on the
open-source community.  Instead, we're going to spend the month of December
writing a series of blog posts that explain how the core components work,
leading up to several use cases:</p>
<ul>
<li>The development team have all decided to shift our personal homepages to be Mirage
kernels running on Xen as a little Christmas present to ourselves, so we'll work through that step-by-step how to build
a dedicated unikernel and maintain and deploy it (<strong>spoiler:</strong> see <a href="https://github.com/mirage/mirage-www-deployment">this repo</a>).  This will culminate in
a webservice that our colleagues at <a href="http://horizon.ac.uk">Horizon</a> have been
building using Android apps and an HTTP backend.
</li>
<li>The <a href="http://xenserver.org">XenServer</a> crew at Citrix are using Mirage to build custom middlebox VMs
such as block device caches.
</li>
<li>For teaching purposes, the <a href="http://ocaml.io">Cambridge Computer Lab team</a> want a JavaScript backend,
so we'll explain how to port Mirage to this target (which is rather different
from either Unix or Xen, and serves to illustrate the portability of our approach).
</li>
</ul>
<h3>How to get involved</h3>
<p>Bear with us while we update all the documentation and start the blog posts off
today (the final libraries for the 1.0 release are all being merged into OPAM
while I write this, and the usually excellent <a href="http://travis-ci.org">Travis</a> continuous integration system is down due to a <a href="https://github.com/travis-ci/travis-ci/issues/1727">bug</a> on their side).  I'll edit this post to contain links to the future posts
as they happen.</p>
<p>Since we're now also a proud Xen and Linux Foundation incubator project, our mailing
list is shifting to <a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mirageos-devel@lists.xenproject.org</a>, and we very much
welcome comments and feedback on our efforts over there.
The <code>#mirage</code> channel on FreeNode IRC is also growing increasingly popular, as
is simply reporting issues on the main <a href="http://github.com/mirage/mirage">Mirage GitHub</a> repository.</p>
<p>Several people have also commented that they want to learn OCaml properly to
start using Mirage.  I've just co-published an O'Reilly book called
<a href="https://realworldocaml.org">Real World OCaml</a> that's available for free online
and also as hardcopy/ebook.  Our Cambridge colleague John Whittington has
also written an excellent <a href="http://ocaml-book.com/">introductory text</a>, and
you can generally find more resources <a href="http://ocaml.org/docs/">online</a>.
Feel free to ask beginner OCaml questions on our mailing lists and we'll help
as best we can!</p>
|js};
      };
      {
        updated = {js|2013-08-23 17:43|js};
        authors =
          [
            {
              name = {js|Vincent Bernardoff|js};
              uri = Some {js|https://github.com/vbmithr|js};
              email = Some {js|vb@luminar.eu.org|js};
            };
          ];
        subject = {js|Introducing vchan|js};
        permalink = {js|introducing-vchan|js};
        body =
          {js|<p><em>Editor</em>: Note that some of the toolchain details of this blog post are
now out-of-date with Mirage 1.1, so we will update this shortly.</p>
<p>Unless you are familiar with Xen's source code, there is little chance
that you've ever heard of the <em>vchan</em> library or
protocol. Documentation about it is very scarce: a description can be
found on vchan's
<a href="http://xenbits.xen.org/gitweb/?p=xen.git;a=blob;f=xen/include/public/io/libxenvchan.h;hb=HEAD">public header file</a>,
that I quote here for convenience:</p>
<blockquote>
<p>Originally borrowed from the
<a href="http://www.qubes-os.org">Qubes OS Project</a>, this code (i.e. libvchan)
has been substantially rewritten [...]
This is a library for inter-domain communication.  A standard Xen ring
buffer is used, with a datagram-based interface built on top.  The
grant reference and event channels are shared in XenStore under a
user-specified path.</p>
</blockquote>
<p>This protocol uses shared memory for inter-domain communication,
i.e. between two VMs residing in the same Xen host, and uses Xen's
mechanisms -- more specifically,
<a href="http://www.informit.com/articles/article.aspx?p=1160234&amp;seqNum=3">ring buffers</a>
and
<a href="http://xenbits.xen.org/gitweb/?p=xen.git;a=blob;f=tools/libxc/xenctrl.h;h=f2cebafc9ddd4815ffc73fcf9e0d292b1d4c91ff;hb=HEAD#l934">event channels</a>
-- in order to achieve its aims. <em>Datagram-based interface</em> simply
means that the
<a href="http://xenbits.xen.org/gitweb/?p=xen.git;a=blob;f=tools/libvchan/libxenvchan.h;h=6365d36a06f8c8f56454724cefc4c2f1d39beba2;hb=HEAD">interface</a>
resembles UDP, although there is support for stream based communication (like
TCP) as well.</p>
<p>Over the last two months or so, I worked on a <a href="http://github.com/mirage/ocaml-vchan">pure OCaml
implementation</a> of this library, meaning
that Mirage-based unikernels can now take full advantage of <em>vchan</em> to
communicate with neighboring VMs! If your endpoint -- a Linux VM or another
unikernel -- is on the same host, it is much faster and more efficient to use
vchan rather than the network stack (although unfortunately, it is currently
incompatible with existing programs written against the <code>socket</code> library under
UNIX or the <code>Flow</code> module of Mirage, although this will improve). It also
provides a higher level of security compared to network sockets as messages
will never leave the host's shared memory.</p>
<p><em>Building the vchan echo domain</em></p>
<p>Provided that you have a Xen-enabled machine, do the following from
dom0:</p>
<pre><code>    opam install mirari mirage-xen mirage vchan
</code></pre>
<p>This will install the library and its dependencies. <code>mirari</code> is
necessary to build the <em>echo unikernel</em>:</p>
<pre><code>    git clone git://github.com/mirage/ocaml-vchan
    cd test
    mirari configure --xen --no-install
    mirari build --xen
    sudo mirari run --xen
</code></pre>
<p>This will boot a <code>vchan echo domain</code> for dom0, with connection
parameters stored in xenstore at <code>/local/domain/&lt;domid&gt;/data/vchan</code>,
where <code>&lt;domid&gt;</code> is the domain id of the vchan echo domain. The echo
domain is simply an unikernel hosting a vchan server accepting
connections from dom0, and echo'ing everything that is sent to it.</p>
<p>The command <code>xl list</code> will give you the domain id of the echo
server.</p>
<p><em>Building the vchan CLI from Xen's sources</em></p>
<p>You can try it using a vchan client that can be found in Xen's sources
at <code>tools/libvchan</code>: Just type <code>make</code> in this directory. It will
compile the executable <code>vchan-node2</code> that you can use to connect to
our freshly created echo domain:</p>
<pre><code>    ./vchan-node2 client &lt;domid&gt;/local/domain/&lt;domid&gt;/data/vchan
</code></pre>
<p>If everything goes well, what you type in there will be echoed.</p>
<p>You can obtain the full API documentation for <em>ocaml-vchan</em> by doing a
<code>cd ocaml-vchan &amp;&amp; make doc</code>. If you are doing network programming
under UNIX, vchan's interface will not surprise you. If you are
already using vchan for a C project, you will see that the OCaml API
is nearly identical to what you are used to.</p>
<p>Please let us know if you use or plan to use this library in any way!
If you need tremedous speed or more security, this might fit your
needs.</p>
|js};
      };
      {
        updated = {js|2013-08-08 16:00|js};
        authors =
          [
            {
              name = {js|Richard Mortier|js};
              uri = Some {js|http://mort.io/|js};
              email = Some {js|mort@cantab.net|js};
            };
          ];
        subject = {js|MirageOS travels to OSCON'13: a trip report|js};
        permalink = {js|oscon13-trip-report|js};
        body =
          {js|<p>Now that Mirage OS is rapidly converging on a
<a href="http://github.com/avsm/mirage/issues/102">Developer Preview Release 1</a>, we
took it for a first public outing at
<a href="http://www.oscon.com/oscon2013/">OSCON'13</a>, the O'Reilly Open Source
Conference. OSCON is in its 15th year now, and is a meeting place for
developers, business people and investors. It was a great opportunity to show
MirageOS off to some of the movers and shakers in the OSS world.</p>
<p>Partly because MirageOS is about synthesising extremely specialised guest
kernels from high-level code, and partly because both Anil and I are
constitutionally incapable of taking the easy way out, we self-hosted the
slide deck on Mirage: after some last-minute hacking -- on content not Mirage
I should add! -- we built a self-contained unikernel of the talk.</p>
<p>This was what you might call a &quot;full stack&quot; presentation: the custom
unikernel (flawlessly!) ran a type-safe
<a href="https://github.com/mirage/mirage-platform/blob/master/xen/lib/netif.ml">network device driver</a>,
OCaml <a href="http://github.com/mirage/mirage-net">TCP/IP stack</a> supporting an OCaml
<a href="http://github.com/mirage/ocaml-cohttp">HTTP</a> framework that served slides
rendered using <a href="http://lab.hakim.se/reveal-js/">reveal.js</a>. The slide deck,
including the turbo-boosted
<a href="http://www.youtube.com/watch?v=2Mx8Bd5JYyo">screencast</a> of the slide deck
compilation, is hosted as another MirageOS virtual machine at
<a href="http://decks.openmirage.org/">decks.openmirage.org</a>. We hope to add more
slide decks there soon, including resurrecting the tutorial! The source code
for all this is in the <a href="http://github.com/mirage/mirage-decks">mirage-decks</a>
GitHub repo.</p>
<h3>The Talk</h3>
<p>The talk went down pretty well -- given we were in a graveyard slot on Friday
after many people had left, attendance was fairly high (around 30-40), and the
<a href="http://www.oscon.com/oscon2013/public/schedule/detail/28956">feedback scores</a>
have been positive (averaging 4.7/5) with comments including &quot;excellent
content and well done&quot; and &quot;one of the most excited projects I heard about&quot;
(though we are suspicious that just refers to Anil's usual high-energy
presentation style...).</p>
<iframe align="right" style="margin-left: 10px;" width="420" height="235" src="//www.youtube-nocookie.com/embed/2Mx8Bd5JYyo" frameborder="0" allowfullscreen="1"> </iframe>
<p>Probably the most interesting chat after the talk was with the Rust authors
at Mozilla (<a href="http://twitter.com/pcwalton">@pcwalton</a> and
<a href="https://github.com/brson">@brson</a>) about combining the Mirage
<a href="http://anil.recoil.org/papers/2013-asplos-mirage.pdf">unikernel</a> techniques
with the <a href="http://www.rust-lang.org">Rust</a> runtime. But perhaps the most
surprising feedback was when Anil and I were stopped in the street while
walking back from some well-earned sushi, by a cyclist who loudly declared
that he'd really enjoyed the talk and thought it was a really exciting project
-- never done something that achieved public acclaim from the streets before
:)</p>
<h3>Book Signing and Xen.org</h3>
<p>Anil also took some time to sit in a book signing for his forthcoming
<a href="http://realworldocaml.org">Real World OCaml</a> O'Reilly book.  This is
really important to making OCaml easier to learn, especially given that
all the Mirage libraries are using it.  Most of the dev team (and especially
thanks to <a href="https://twitter.com/heidiann360">Heidi Howard</a> who bravely worked
through really early alpha revisions) have been giving
us feedback as the book is written, using the online commenting system.</p>
<p>The Xen.org booth was also huge, and we spent quite a while plotting the
forthcoming Mirage/Xen/ARM backend. We're pretty much just waiting for the
<a href="http://cubieboard.org">Cubieboard2</a> kernel patches to be upstreamed (keep an
eye <a href="http://linux-sunxi.org/Main_Page">here</a>) so that we can boot Xen/ARM VMs
on tiny ARM devices.  There's a full report about this on the
<a href="http://blog.xen.org/index.php/2013/07/31/the-xen-project-at-oscon/">xen.org</a>
blog post about OSCon.</p>
<h3>Galois and HalVM</h3>
<p>We also stopped by the <a href="http://galois.com">Galois</a> to chat with <a href="https://twitter.com/acwpdx">Adam
Wick</a>, who is the leader of the
<a href="https://galois.com/project/halvm/">HalVM</a> project at Galois. This is a similar
project to Mirage, but, since it's written in Haskell, has more of a focus
on elegant compositional semantics rather than the more brutal performance
and predictability that Mirage currently has at its lower levels.</p>
<p>The future of all this ultimately lies in making it easier for these
multi-lingual unikernels to be managed and for all of them to communicate more
easily, so we chatted about code sharing and common protocols (such as
<a href="https://github.com/vbmithr/ocaml-vchan">vchan</a>) to help interoperability.
Expect to see more of this once our respective implementations get more
stable.</p>
<p>All-in-all OSCON'13 was a fun event and definitely one that we look forward
returning to with a more mature version of MirageOS, to build on the momentum
begun this year!  Portland was an amazing host city too, but what happens in
Portland, stays in Portland...</p>
|js};
      };
      {
        updated = {js|2013-07-18 11:20|js};
        authors =
          [
            {
              name = {js|Dave Scott|js};
              uri = Some {js|http://dave.recoil.org/|js};
              email = Some {js|dave@recoil.org|js};
            };
          ];
        subject = {js|Creating Xen block devices with MirageOS|js};
        permalink = {js|xen-block-devices-with-mirage|js};
        body =
          {js|<p><a href="https://mirage.io/">MirageOS</a> is a
<a href="http://anil.recoil.org/papers/2013-asplos-mirage.pdf">unikernel</a>
or &quot;library operating system&quot; that allows us to build applications
which can be compiled to very diverse environments: the same code can be linked
to run as a regular Unix app, relinked to run as a <a href="https://github.com/pgj/mirage-kfreebsd">FreeBSD kernel module</a>,
and even linked into a
self-contained kernel which can run on the <a href="http://www.xenproject.org/">Xen
hypervisor</a>.</p>
<p>Mirage has access to an extensive suite of pure OCaml <a href="https://github.com/mirage">libraries</a>,
covering everything from Xen <a href="https://github.com/mirage/ocaml-xen-block-driver">block</a> and <a href="https://github.com/mirage/mirage-platform/blob/master/xen/lib/netif.ml">network</a> virtual device drivers,
a <a href="https://github.com/mirage/mirage-net">TCP/IP stack</a>, OpenFlow learning switches and controllers, to
SSH and <a href="https://github.com/mirage/ocaml-cohttp">HTTP</a> server implementations.</p>
<p>I normally use Mirage to deploy applications as kernels on top of
a <a href="http://www.xenserver.org/">XenServer</a> hypervisor. I start by
first using the Mirage libraries within a normal Unix userspace
application -- where I have access to excellent debugging tools --
and then finally link my app as a high-performance Xen kernel for
production.</p>
<p>However Mirage is great for more than simply building Xen kernels.
In this post I'll describe how I've been using Mirage to create
experimental virtual disk devices for existing Xen VMs (which may
themselves be Linux, *BSD, Windows or even Mirage kernels).
The Mirage libraries let me easily
experiment with different backend file formats and protocols, all while
writing only type-safe OCaml code thats runs in userspace in a normal
Linux domain 0.</p>
<p><em>Disk devices under Xen</em></p>
<p>The protocols used by Xen disk and network devices are designed to
permit fast and efficient software implementations, avoiding the
inefficiencies inherent in emulating physical hardware in software.
The protocols are based on two primitives:</p>
<ul>
<li><em>shared memory pages</em>: used for sharing both data and metadata
</li>
<li><em>event channels</em>: similar to interrupts, these allow one side to signal the other
</li>
</ul>
<p>In the disk block protocol, the protocol starts with the client
(&quot;frontend&quot; in Xen jargon) sharing a page with the server (&quot;backend&quot;).
This single page will contain the request/response metadata, arranged
as a circular buffer or &quot;ring&quot;. The client (&quot;frontend&quot;) can then start
sharing pages containing disk blocks with the backend and pushing request
structures to the ring, updating shared pointers as it goes. The client
will give the server end a kick via an event channel signal and then both
ends start running simultaneously. There are no locks in the protocol so
updates to the shared metadata must be handled carefully, using write
memory barriers to ensure consistency.</p>
<p><em>Xen disk devices in MirageOS</em></p>
<p>Like everything else in Mirage, Xen disk devices are implemented as
libraries. The ocamlfind library called &quot;xenctrl&quot; provides support for
manipulating blocks of raw memory pages, &quot;granting&quot; access to them to
other domains and signalling event channels. There are two implementations
of &quot;xenctrl&quot;:
<a href="https://github.com/mirage/mirage-platform/tree/master/xen/lib">one that invokes Xen &quot;hypercalls&quot; directly</a>
and one which uses the <a href="https://github.com/xapi-project/ocaml-xen-lowlevel-libs">Xen userspace library libxc</a>.
Both implementations satisfy a common signature, so it's easy to write
code which will work in both userspace and kernelspace.</p>
<p>The ocamlfind library
<a href="https://github.com/mirage/shared-memory-ring">shared-memory-ring</a>
provides functions to create and manipulate request/response rings in shared
memory as used by the disk and network protocols. This library is a mix of
99.9% OCaml and 0.1% asm, where the asm is only needed to invoke memory
barrier operations to ensure that metadata writes issued by one CPU core
appear in the same order when viewed from another CPU core.</p>
<p>Finally the ocamlfind library
<a href="https://github.com/mirage/ocaml-xen-block-driver">xenblock</a>
provides functions to hotplug and hotunplug disk devices, together with an
implementation of the disk block protocol itself.</p>
<p><em>Making custom virtual disk servers with MirageOS</em></p>
<p>Let's experiment with making our own virtual disk server based on
the Mirage example program, <a href="https://github.com/mirage/xen-disk">xen-disk</a>.</p>
<p>First, install <a href="http://www.xen.org/">Xen</a>, <a href="http://www.ocaml.org/">OCaml</a>
and <a href="http://opam.ocamlpro.com/">OPAM</a>. Second initialise your system:</p>
<pre><code>  opam init
  eval `opam config env`
</code></pre>
<p>At the time of writing, not all the libraries were released as upstream
OPAM packages, so it was necessary to add some extra repositories. This
should not be necessary after the Mirage developer preview at
<a href="http://www.oscon.com/oscon2013/public/schedule/detail/28956">OSCON 2013</a>.</p>
<pre><code>  opam remote add mirage-dev git://github.com/mirage/opam-repo-dev
  opam remote add xapi-dev git://github.com/xapi-project/opam-repo-dev
</code></pre>
<p>Install the unmodified <code>xen-disk</code> package, this will ensure all the build
dependencies are installed:</p>
<pre><code>  opam install xen-disk
</code></pre>
<p>When this completes it will have installed a command-line tool called
<code>xen-disk</code>. If you start a VM using your Xen toolstack of choice
(&quot;xl create ...&quot; or &quot;xe vm-install ...&quot; or &quot;virsh create ...&quot;) then you
should be able to run:</p>
<pre><code>  xen-disk connect &lt;vmname&gt;
</code></pre>
<p>which will hotplug a fresh block device into the VM &quot;<code>&lt;vmname&gt;</code>&quot; using the
&quot;discard&quot; backend, which returns &quot;success&quot; to all read and write requests,
but actually throws all data away. Obviously this backend should only be
used for basic testing!</p>
<p>Assuming that worked ok, clone and build the source for <code>xen-disk</code> yourself:</p>
<pre><code>  git clone git://github.com/mirage/xen-disk
  cd xen-disk
  make
</code></pre>
<p><em>Making a custom virtual disk implementation</em></p>
<p>The <code>xen-disk</code> program has a set of simple built-in virtual disk implementations.
Each one satisifies a simple signature, contained in
<a href="https://github.com/mirage/xen-disk/blob/master/src/storage.mli">src/storage.mli</a>:</p>
<pre><code>type configuration = {
  filename: string;      (** path where the data will be stored *)
  format: string option; (** format of physical data *)
}
(** Information needed to &quot;open&quot; a disk *)

module type S = sig
  (** A concrete mechanism to access and update a virtual disk. *)

  type t
  (** An open virtual disk *)

  val open_disk: configuration -&gt; t option Lwt.t
  (** Given a configuration, attempt to open a virtual disk *)

  val size: t -&gt; int64
  (** [size t] is the size of the virtual disk in bytes. The actual
      number of bytes stored on media may be different. *)

  val read: t -&gt; Cstruct.t -&gt; int64 -&gt; int -&gt; unit Lwt.t
  (** [read t buf offset_sectors len_sectors] copies [len_sectors]
      sectors beginning at sector [offset_sectors] from [t] into [buf] *)

  val write: t -&gt; Cstruct.t -&gt; int64 -&gt; int -&gt; unit Lwt.t
  (** [write t buf offset_sectors len_sectors] copies [len_sectors]
      sectors from [buf] into [t] beginning at sector [offset_sectors]. *)
end
</code></pre>
<p>Let's make a virtual disk implementation which uses an existing disk
image file as a &quot;gold image&quot;, but uses copy-on-write so that no writes
persist.
This is a common configuration in Virtual Desktop Infrastructure deployments
and is generally handy when you want to test a change quickly, and
revert it cleanly afterwards.</p>
<p>A useful Unix technique for file I/O is to &quot;memory map&quot; an existing file:
this associates the file contents with a range of virtual memory addresses
so that reading and writing within this address range will actually
read or write the file contents.
The &quot;mmap&quot; C function has a number of flags, which can be used to request
&quot;copy on write&quot; behaviour. Reading the
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Bigarray.Genarray.html">OCaml manual Bigarray.map_file</a>
it says:</p>
<blockquote>
<p>If shared is true, all modifications performed on the array are reflected
in the file. This requires that fd be opened with write permissions. If
shared is false, modifications performed on the array are done in memory
only, using copy-on-write of the modified pages; the underlying file is
not affected.</p>
</blockquote>
<p>So we should be able to make a virtual disk implementation which memory
maps the image file and achieves copy-on-write by setting &quot;shared&quot; to false.
For extra safety we can also open the file read-only.</p>
<p>Luckily there is already an
<a href="https://github.com/mirage/xen-disk/blob/master/src/backend.ml#L63">&quot;mmap&quot; implementation</a>
in <code>xen-disk</code>; all we need to do is tweak it slightly.
Note that the <code>xen-disk</code> program uses a co-operative threading library called
<a href="http://ocsigen.org/lwt/">lwt</a>
which replaces functions from the OCaml standard library which might block
with non-blocking variants. In
particular <code>lwt</code> uses <code>Lwt_bytes.map_file</code> as a wrapper for the
<code>Bigarray.Array1.map_file</code> function.
In the &quot;open-disk&quot; function we simply need to set &quot;shared&quot; to &quot;false&quot; to
achieve the behaviour we want i.e.</p>
<pre><code>  let open_disk configuration =
    let fd = Unix.openfile configuration.filename [ Unix.O_RDONLY ] 0o0 in
    let stats = Unix.LargeFile.fstat fd in
    let mmap = Lwt_bytes.map_file ~fd ~shared:false () in
    Unix.close fd;
    return (Some (stats.Unix.LargeFile.st_size, Cstruct.of_bigarray mmap))
</code></pre>
<p>The read and write functions can be left as they are:</p>
<pre><code>  let read (_, mmap) buf offset_sectors len_sectors =
    let offset_sectors = Int64.to_int offset_sectors in
    let len_bytes = len_sectors * sector_size in
    let offset_bytes = offset_sectors * sector_size in
    Cstruct.blit mmap offset_bytes buf 0 len_bytes;
    return ()

  let write (_, mmap) buf offset_sectors len_sectors =
    let offset_sectors = Int64.to_int offset_sectors in
    let offset_bytes = offset_sectors * sector_size in
    let len_bytes = len_sectors * sector_size in
    Cstruct.blit buf 0 mmap offset_bytes len_bytes;
    return () 
</code></pre>
<p>Now if we rebuild and run something like:</p>
<pre><code>  dd if=/dev/zero of=disk.raw bs=1M seek=1024 count=1
  losetup /dev/loop0 disk.raw
  mkfs.ext3 /dev/loop0
  losetup -d /dev/loop0

  dist/build/xen-disk/xen-disk connect &lt;myvm&gt; --path disk.raw
</code></pre>
<p>Inside the VM we should be able to do some basic speed testing:</p>
<pre><code>  # dd if=/dev/xvdb of=/dev/null bs=1M iflag=direct count=100
  100+0 records in
  100+0 records out
  104857600 bytes (105 MB) copied, 0.125296 s, 837 MB/s
</code></pre>
<p>Plus we should be able to mount the filesystem inside the VM, make changes and
then disconnect (send SIGINT to xen-disk by hitting Control+C on your terminal)
without disturbing the underlying disk contents.</p>
<p><em>So what else can we do?</em></p>
<p>Thanks to Mirage it's now really easy to experiment with custom storage types
for your existing VMs. If you have a cunning scheme where you want to hash block contents,
and use the hashes as keys in some distributed datastructure -- go ahead, it's
all easy to do. If you have ideas for improving the low-level block access protocol
then Mirage makes those experiments very easy too.</p>
<p>If you come up with a cool example with Mirage, then send us a
<a href="https://github.com/mirage">pull request</a> or send us an email to the
<a href="https://mirage.io/about/">Mirage mailing list</a> -- we'd
love to hear about it!</p>
|js};
      };
      {
        updated = {js|2013-05-20 16:20|js};
        authors =
          [
            {
              name = {js|Anil Madhavapeddy|js};
              uri = Some {js|http://anil.recoil.org|js};
              email = Some {js|anil@recoil.org|js};
            };
          ];
        subject = {js|The road to a developer preview at OSCON 2013|js};
        permalink = {js|the-road-to-a-dev-release|js};
        body =
          {js|<p>There's been a crazy stream of activity since the start of the year, but the most important news is that we have a release target for an integrated developer preview of the Mirage stack: a talk at <a href="http://www.oscon.com/oscon2013/public/schedule/detail/28956">O'Reilly OSCon</a> in July!  Do turn up there and find <a href="http://dave.recoil.org">Dave Scott</a> and <a href="http://anil.recoil.org">Anil Madhavapeddy</a> showing off interactive demonstrations.</p>
<p>Meanwhile, another significant announcement has been that Xen is <a href="http://www.linuxfoundation.org/news-media/announcements/2013/04/xen-become-linux-foundation-collaborative-project">joining the Linux Foundation</a> as a collaborative project.  This is great news for Mirage: as a library operating system, we can operate just as easily under other hypervisors, and even on bare-metal devices such as the <a href="http://raspberrypi.org">Raspberry Pi</a>.  We're very much looking forward to getting the Xen-based developer release done, and interacting with the wider Linux community (and FreeBSD, for that matter, thanks to Gabor Pali's <a href="https://github.com/pgj/mirage-kfreebsd">kFreeBSD</a> backend).</p>
<p>Here's some other significant news from the past few months:</p>
<ul>
<li>
<p><a href="http://www.ocamlpro.com/blog/2013/03/14/opam-1.0.0.html">OPAM 1.0 was released</a>, giving Mirage a solid package manager for handling the many libraries required to glue an application together.  <a href="https://github.com/vbmithr">Vincent Bernardoff</a> joined the team at Citrix and has been building a Mirage build-frontend called <a href="https://github.com/mirage/mirari">Mirari</a> to hide much of the system complexity from a user who isn't too familiar with either Xen or OCaml.</p>
</li>
<li>
<p>A new group called the <a href="http://ocaml.io">OCaml Labs</a> has started up in the <a href="http://www.cl.cam.ac.uk">Cambridge Computer Laboratory</a>, and is working on improving the OCaml toolchain and platform.  This gives Mirage a big boost, as we can re-use several of the documentation, build and test improvements in our own releases.  You can read up on the group's activities via the <a href="http://ocaml.io/news">monthly updates</a>, or browse through the various <a href="http://ocaml.io/tasks">projects</a>.  One of the more important projects is the <a href="http://www.cl.cam.ac.uk/projects/ocamllabs/tasks/platform.html#OCamlot">OCamlot</a> continuous build infrastructure, which will also be testing Mirage kernels as one of the supported backends.</p>
</li>
<li>
<p>As we head into release mode, we've started <a href="/wiki#Weekly-calls-and-release-notes">weekly meetings</a> to coordinate all the activities.  We're keeping notes as we go along, so you should be able to skim the notes and <a href="https://lists.cam.ac.uk/pipermail/cl-mirage/">mailing list archives</a> to get a feel for the overall activities.  Anil is maintaining a <a href="https://mirage.github.io/wiki/dev-preview-checklist">release checklist</a> for the summer developer preview.</p>
</li>
<li>
<p>Anil (along with Yaron Minsky and Jason Hickey) is finishing up an O'Reilly book on <a href="http://realworldocaml.org">Real World OCaml</a>, which will be a useful guide to using OCaml for systems and network programming. If you'd like to review an early copy, please get in touch.  The final book is anticipated to be released towards the end of the year, with a <a href="http://shop.oreilly.com/category/roughcuts.do">Rough Cut</a> at the end of the summer.</p>
</li>
<li>
<p>The core system was described in an <a href="http://anil.recoil.org/papers/2013-asplos-mirage.pdf">ASPLOS 2013</a> paper, which should help you understand the background behind library operating systems. Some of the Mirage libraries are also currently being integrated into the next-generation <a href="http://blogs.citrix.com/2012/05/17/introducing-windsor-a-new-xen-based-virtualization-architecture/">Windsor</a> release of the Xen Cloud Platform, which means that several of the libraries will be used in production and hence move beyond research-quality code.</p>
</li>
</ul>
<p>In the next few months, the installation notes and getting started guides will
all be revamped to match the reality of the new tooling, so expect some flux
there.   If you want to take an early try of Mirage beforehand, don't forget to
hop on the <code>#mirage</code> IRC channel on Freenode and ping us with questions
directly.  We will also be migrating some of the project infrastructure to be fully
self-hosted on Mirage and Xen, and placing some of the services onto the new <a href="http://xenproject.org">xenproject.org</a> infrastructure.</p>
|js};
      };
      {
        updated = {js|2012-9-12 0:00|js};
        authors =
          [
            {
              name = {js|Dave Scott|js};
              uri = Some {js|http://dave.recoil.org/|js};
              email = Some {js|dave@recoil.org|js};
            };
          ];
        subject = {js|Building a "Xenstore stub domain" with MirageOS|js};
        permalink = {js|xenstore-stub-domain|js};
        body =
          {js|<p>[ <em>Due to continuing development, some of the details in this blog post are now out-of-date. It is archived here.</em> ]</p>
<p>On all hosts running <a href="http://www.xen.org/">Xen</a>, there is a critical service called <a href="http://wiki.xen.org/wiki/XenStore">xenstore</a>.
Xenstore is used to allow <em>untrusted</em> user VMs to communicate with <em>trusted</em> system VMs, so that</p>
<ul>
<li>virtual disk and network connections can be established
</li>
<li>performance statistics and OS version information can be shared
</li>
<li>VMs can be remotely power-cycled, suspended, resumed, snapshotted and migrated.
</li>
</ul>
<p>If the xenstore service fails then at best the host cannot be controlled (i.e. no VM start or shutdown)
and at worst VM isolation is compromised since an untrusted VM will be able to gain unauthorised access to disks or networks.
This blog post examines how to disaggregate xenstore from the monolithic domain 0, and run it as an independent <a href="http://www.cl.cam.ac.uk/~dgm36/publications/2008-murray2008improving.pdf">stub domain</a>.</p>
<p>Recently in the Xen community, Daniel De Graaf and Alex Zeffertt have added support for
<a href="http://lists.xen.org/archives/html/xen-devel/2012-01/msg02349.html">xenstore stub domains</a>
where the xenstore service is run directly as an OS kernel in its own isolated VM. In the world of Xen,
a running VM is a &quot;domain&quot; and a &quot;stub&quot; implies a single-purpose OS image rather than a general-purpose
machine.
Previously if something bad happened in &quot;domain 0&quot; (the privileged general-purpose OS where xenstore traditionally runs)
such as an out-of-memory event or a performance problem, then the critical xenstore process might become unusable
or fail altogether. Instead if xenstore is run as a &quot;stub domain&quot; then it is immune to such problems in
domain 0. In fact, it will even allow us to <em>reboot</em> domain 0 in future (along with all other privileged
domains) without incurring any VM downtime during the reset!</p>
<p>The new code in <a href="http://xenbits.xensource.com/xen-unstable.hg">xen-unstable.hg</a> lays the necessary groundwork
(Xen and domain 0 kernel changes) and ports the original C xenstored to run as a stub domain.</p>
<p>Meanwhile, thanks to <a href="http://tab.snarc.org">Vincent Hanquez</a> and <a href="http://gazagnaire.org">Thomas Gazagnaire</a>, we also have an
<a href="http://gazagnaire.org/pub/SSGM10.pdf">OCaml implementation of xenstore</a> which, as well as the offering
memory-safety, also supports a high-performance transaction engine, necessary for surviving a stressful
&quot;VM bootstorm&quot; event on a large server in the cloud. Vincent and Thomas' code is Linux/POSIX only.</p>
<p>Ideally we would have the best of both worlds:</p>
<ul>
<li>a fast, memory-safe xenstored written in OCaml,
</li>
<li>running directly as a Xen stub domain i.e. as a specialised kernel image without Linux or POSIX
</li>
</ul>
<p>We can now do both, using Mirage!  If you're saying, &quot;that sounds great! How do I do that?&quot; then read on...</p>
<p><em>Step 1: remove dependency on POSIX/Linux</em></p>
<p>If you read through the existing OCaml xenstored code, it becomes obvious that the main uses of POSIX APIs are for communication
with clients, both Unix sockets and for a special Xen inter-domain shared memory interface. It was a fairly
painless process to extract the required socket-like IO signature and turn the bulk of the server into
a <a href="http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual004.html">functor</a>. The IO signature ended up looking approximately like:</p>
<pre><code>    type t
    val read: t -&gt; string -&gt; int -&gt; int -&gt; int Lwt.t
    val write: t -&gt; string -&gt; int -&gt; int -&gt; unit Lwt.t
    val destroy: t -&gt; unit Lwt.t
</code></pre>
<p>For now the dependency on <a href="http://ocsigen.org/lwt/">Lwt</a> is explicit but in future I'll probably make it more abstract so we
can use <a href="https://ocaml.janestreet.com/?q=node/100">Core Async</a> too.</p>
<p><em>Step 2: add a Mirage Xen IO implementation</em></p>
<p>In a stub-domain all communication with other domains is via shared memory pages and &quot;event channels&quot;.
Mirage already contains extensive support for using these primitives, and uses them to create fast
network and block virtual device drivers. To extend the code to cover the Xenstore stub domain case,
only a few tweaks were needed to add the &quot;server&quot; side of a xenstore ring communication, in addition
to the &quot;client&quot; side which was already present.</p>
<p>In Xen, domains share memory by a system of explicit &quot;grants&quot;, where a client (called &quot;frontend&quot;)
tells the hypervisor to allow a server (called &quot;backend&quot;) access to specific memory pages. Mirage
already had code to create such grants, all that was missing was a few simple functions to receive
grants from other domains.</p>
<p>These changes are all in the current <a href="https://github.com/mirage/mirage-platform">mirage-platform</a>
tree.</p>
<p><em>Step 3: add a Mirage Xen &quot;main&quot; module and Makefile</em></p>
<p>The Mirage &quot;main&quot; module necessary for a stub domain looks pretty similar to the normal Unix
userspace case except that it:</p>
<ul>
<li>arranges to log messages via the VM console (rather than a file or the network, since a disk or network device cannot be created without a working xenstore, and it's important not to introduce a bootstrap
problem here)
</li>
<li>instantiates the server functor with the shared memory inter-domain IO module.
</li>
</ul>
<p>The Makefile looks like a regular Makefile, invoking ocamlbuild. The whole lot is built with
<a href="http://oasis.forge.ocamlcore.org/">OASIS</a> with a small extension added by <a href="http://anil.recoil.org/">Anil</a> to set a few options
required for building Xen kernels rather than regular binaries.</p>
<p>... and it all works!</p>
<p>The code is in two separate repositories:</p>
<ul>
<li><a href="https://github.com/djs55/ocaml-xenstore">ocaml-xenstore</a>: contains all the generic stuff
</li>
<li><a href="https://github.com/djs55/ocaml-xenstore-xen">ocaml-xenstore-xen</a>: contains the unix userspace
and xen stub domain IO modules and &quot;main&quot; functions
</li>
<li>(optional) To regenerate the OASIS file, grab the <code>add-xen</code> branch from this <a href="http://github.com/avsm/oasis">OASIS fork</a>.
</li>
</ul>
<p><em>Example build instructions</em></p>
<p>If you want to try building it yourself, try the following on a modern 64-bit OS. I've tested these
instructions on a fresh install of Debian Wheezy.</p>
<p>First install OCaml and the usual build tools:</p>
<pre><code>    apt-get install ocaml build-essential git curl rsync
</code></pre>
<p>Then install the OCamlPro <code>opam</code> package manager to simplify the installation of extra packages</p>
<pre><code>    git clone git://github.com/OCamlPro/opam.git
    cd opam
    make
    make install
    cd ..
</code></pre>
<p>Initialise OPAM with the default packages:</p>
<pre><code>    opam --yes init
    eval `opam config -env`
</code></pre>
<p>Add the &quot;mirage&quot; development package source (this step will not be needed once the package definitions are upstreamed)</p>
<pre><code>    opam remote -add dev git://github.com/mirage/opam-repo-dev
</code></pre>
<p>Switch to the special &quot;mirage&quot; version of the OCaml compiler</p>
<pre><code>    opam --yes switch -install 3.12.1+mirage-xen
    opam --yes switch 3.12.1+mirage-xen
    eval `opam config -env`
</code></pre>
<p>Install the generic Xenstore protocol libraries</p>
<pre><code>    opam --yes install xenstore
</code></pre>
<p>Install the Mirage development libraries</p>
<pre><code>    opam --yes install mirage
</code></pre>
<p>If this fails with &quot;+ runtime/dietlibc/lib/atof.c:1: sorry, unimplemented: 64-bit mode not compiled in&quot; it means you need a 64-bit build environment.
Next, clone the xen stubdom tree</p>
<pre><code>    git clone git://github.com/djs55/ocaml-xenstore-xen
</code></pre>
<p>Build the Xen stubdom</p>
<pre><code>    cd ocaml-xenstore-xen
    make
</code></pre>
<p>The binary now lives in <code>xen/_build/src/server_xen.xen</code></p>
<p><em>Deploying on a Xen system</em></p>
<p>Running a stub Xenstored is a little tricky because it depends on the latest and
greatest Xen and Linux PVops kernel. In the future it'll become much easier (and probably
the default) but for now you need the following:</p>
<ul>
<li>xen-4.2 with XSM (Xen Security Modules) turned on
</li>
<li>A XSM/FLASK policy which allows the stubdom to call the &quot;domctl getdomaininfo&quot;. For the moment it's safe to skip this step with the caveat that xenstored will leak connections when domains die.
</li>
<li>a Xen-4.2-compatible toolstack (either the bundled xl/libxl or xapi with <a href="http://github.com/djs55/xen-api/tree/xen-4.2">some patches</a>)
</li>
<li>Linux-3.5 PVops domain 0 kernel
</li>
<li>the domain builder binary <code>init-xenstore-domain</code> from <code>xen-4.2/tools/xenstore</code>.
</li>
</ul>
<p>To turn the stub xenstored on, you need to edit whichever <code>init.d</code> script is currently starting xenstore and modify it to call</p>
<pre><code>    init-xenstore-domain /path/to/server_xen.xen 256 flask_label
</code></pre>
|js};
      };
      {
        updated = {js|2012-10-17 17:30|js};
        authors =
          [
            {
              name = {js|Anil Madhavapeddy|js};
              uri = Some {js|http://anil.recoil.org|js};
              email = Some {js|anil@recoil.org|js};
            };
          ];
        subject = {js|Breaking up is easy to do (with OPAM)|js};
        permalink = {js|breaking-up-is-easy-with-opam|js};
        body =
          {js|<p>When we first started developing Mirage in 2009, we were rewriting huge chunks of operating system and runtime code in OCaml. This ranged from low-level device drivers to higher-level networking protocols such as TCP/IP or HTTP.  The changes weren't just straight rewrites of C code either, but also involved experimenting with interfaces such as iteratees and <a href="/wiki/tutorial-lwt">lightweight threading</a> to take advantage of OCaml's static type system.  To make all of this easy to work with, we decided to lump everything into a <a href="http://github.com/avsm/mirage">single Git repository</a> that would bootstrap the entire system with a single <code>make</code> invocation.</p>
<p>Nowadays though, Mirage is self-hosting, the interfaces are settling down, the number of libraries are growing every day, and portions of it are being used in <a href="/blog/xenstore-stub-domain">the Xen Cloud Platform</a>. So for the first developer release, we wanted to split up the monolithic repository into more manageable chunks, but still make it as easy as possible for the average OCaml developer to try out Mirage.</p>
<p>Thanks to much hard work from <a href="http://gazagnaire.org">Thomas</a> and his colleagues at <a href="http://ocamlpro.com">OCamlPro</a>, we now have <a href="http://opam.ocamlpro.com">OPAM</a>: a fully-fledged package manager for Mirage!  OPAM is a source-based package manager that supports a growing number of community OCaml libraries.  More importantly for Mirage, it can also switch between multiple compiler installations, and so support cross-compiled runtimes and modified standard libraries.</p>
<p>OPAM includes compiler variants for Mirage-friendly environments for Xen and the UNIX <code>tuntap</code> backends.  The <a href="/wiki/install">installation instructions</a> now give you instructions on how to use OPAM, and the old monolithic repository is considered deprecated.  We're still working on full documentation for the first beta release, but all the repositories are on the <a href="http://github.com/mirage">Mirage organisation</a> on Github, with some of the important ones being:</p>
<ul>
<li><a href="http://github.com/mirage/mirage-platform">mirage-platform</a> has the core runtime for Xen and UNIX, implemented as the <code>OS</code> module.
</li>
<li><a href="http://github.com/mirage/mirage-net">mirage-net</a> has the TCP/IP networking stack.
</li>
<li><a href="http://github.com/mirage/ocaml-cstruct">ocaml-cstruct</a> has the camlp4 extension to manipulate memory like C <code>struct</code>s, but with type-safe accessors in OCaml.
</li>
<li><a href="http://github.com/mirage/ocaml-xenstore">ocaml-xenstore</a> has a portable implementation of the Xenstore protocol to communicate with the Xen management stack from a VM (or even act as a <a href="/blog/xenstore-stub-domain">server in a stub domain</a>).
</li>
<li><a href="http://github.com/mirage/ocaml-dns">ocaml-dns</a> is a pure OCaml implementation of the DNS protocol, including a server and stub resolver.
</li>
<li><a href="http://github.com/mirage/ocaml-re">ocaml-re</a> is a pure OCaml version of several regular expression engines, including Perl compatibility.
</li>
<li><a href="http://github.com/mirage/ocaml-uri">ocaml-uri</a> handles parsing the surprisingly complex URI strings.
</li>
<li><a href="http://github.com/mirage/ocaml-cohttp">ocaml-cohttp</a> is a portable HTTP parser, with backends for Mirage, Lwt and Core/Async. This is a good example of how to factor out OS-specific concerns using the OCaml type system (and I plan to blog more about this soon).
</li>
<li><a href="http://github.com/mirage/ocaml-cow">ocaml-cow</a> is a set of syntax extensions for JSON, CSS, XML and XHTML, which are explained <a href="https://mirage.github.io/wiki/cow">here</a>, and used by this site.
</li>
<li><a href="http://github.com/mirage/dyntype">ocaml-dyntype</a> uses camlp4 to <a href="http://anil.recoil.org/papers/2011-dynamics-ml.pdf">generate dynamic types</a> and values from OCaml type declarations.
</li>
<li><a href="http://github.com/mirage/orm">ocaml-orm</a> auto-generates SQL scheme from OCaml types via Dyntype, and currently supports SQLite.
</li>
<li><a href="http://github.com/mirage/ocaml-openflow">ocaml-openflow</a> implements an OCaml switch and controller for the Openflow protocol.
</li>
</ul>
<p>There are quite a few more that are still being hacked for release by the team, but we're getting there very fast now. We also have the Mirage ports of <a href="http://github.com/avsm/ocaml-ssh">SSH</a> to integrate before the first release this year, and Haris has got some <a href="http://github.com/mirage/ocaml-crypto-keys">interesting DNSSEC</a> code!  If you want to get involved, join the <a href="/about">mailing list</a> or IRC channel!</p>
|js};
      };
      {
        updated = {js|2012-02-29 11:10|js};
        authors =
          [
            {
              name = {js|Richard Mortier|js};
              uri = Some {js|http://mort.io/|js};
              email = Some {js|mort@cantab.net|js};
            };
          ];
        subject = {js|Connected Cloud Control: OpenFlow in MirageOS|js};
        permalink = {js|announcing-mirage-openflow|js};
        body =
          {js|<p><strong>Due to continuing development, some of the details in this blog post are now out-of-date. It is archived here.</strong></p>
<p>Something we've been working on for a little while now that we're pretty
excited about is an <a href="http://openflow.org/">OpenFlow</a> implementation for
MirageOS. For those who're not networking types, in short, OpenFlow is a
protocol and framework for devolving network control to software running on
platforms other than the network elements themselves. It consists of three
main parts:</p>
<ul>
<li>a <em>controller</em>, responsible for exercising control over the network;
</li>
<li><em>switches</em>, consisting of switching hardware, with flow tables that apply
forwarding behaviours to matching packets; and
</li>
<li>the <em>protocol</em>, by which controllers and switches communicate.
</li>
</ul>
<p>For more -- and far clearer! -- explanations, see any of the many online
OpenFlow resources such as <a href="http://openflowhub.org">OpenFlowHub</a>.</p>
<p>Within MirageOS we have an OpenFlow implementation in two parts: individual
libraries that provide controller and switch functionality. Linking the switch
library enables your application to become a software-based OpenFlow switch.
Linking in the controller library enables your application to exercise direct
control over OpenFlow network elements.</p>
<p>The controller is modelled after the <a href="http://noxrepo.org/">NOX</a> open-source
controller and currently provides only relatively low-level access to the
OpenFlow primitives: a very cool thing to build on top of it would be a
higher-level abstraction such as that provided by
<a href="http://haskell.cs.yale.edu/?page_id=376">Nettle</a> or
<a href="http://www.frenetic-lang.org/">Frenetic</a>.</p>
<p>The switch is primarily intended as an experimental platform -- it is
hopefully easier to extend than some of the existing software switches while
still being sufficiently high performance to be interesting!</p>
<p>By way of a sample of how it fits together, here's a skeleton for a simple
controller application:</p>
<pre><code>type mac_switch = {
  addr: OP.eaddr; 
  switch: OP.datapath_id;
}

type switch_state = {
  mutable mac_cache: 
        (mac_switch, OP.Port.t) Hashtbl.t;
  mutable dpid: OP.datapath_id list
}

let switch_data = {
  mac_cache = Hashtbl.create 7; 
  dpid = [];
} 

let join_cb controller dpid evt =
  let dp = match evt with
      | OE.Datapath_join c -&gt; c
      | _ -&gt; invalid_arg &quot;bogus datapath_join&quot;
  in 
  switch_data.dpid &lt;- switch_data.dpid @ [dp]

let packet_in_cb controller dpid evt =
  (* algorithm details omitted for space *)

let init ctrl = 
  OC.register_cb ctrl OE.DATAPATH_JOIN join_cb;
  OC.register_cb ctrl OE.PACKET_IN packet_in_cb

let main () =
  Net.Manager.create (fun mgr interface id -&gt;
    let port = 6633 in 
    OC.listen mgr (None, port) init
  )
</code></pre>
<p>We've written up some of the gory details of the design, implementation and
performance in a <a href="/documents/iccsdn12-mirage.pdf">short paper</a> to the
<a href="http://www.ieee-icc.org/">ICC</a>
<a href="http://sdn12.mytestbed.net/">Software Defined Networking</a> workshop. Thanks to
some sterling work by <a href="http://www.cl.cam.ac.uk/~cr409/">Haris</a> and
<a href="mailto:balraj.singh@cl.cam.ac.uk">Balraj</a>, the headline numbers are pretty
good though: the unoptimised Mirage controller implementation is only 30--40%
lower performance than the highly optimised NOX <em>destiny-fast</em> branch, which
drops most of the programmability and flexibility of NOX; but is about <em>six
times</em> higher performance than the fully flexible current NOX release. The
switch's performance  running as a domU virtual machine is indistinguishable
from the current <a href="http://openvswitch.org/">Open vSwitch</a> release.</p>
<p>For more details see <a href="/documents/iccsdn12-mirage.pdf">the paper</a> or contact
<a href="mailto:mort@cantab.net">Mort</a>,
<a href="mailto:charalampos.rotsos@cl.cam.ac.uk">Haris</a> or
<a href="mailto:anil@recoil.org">Anil</a>. Please do get in touch if you've any comments
or questions, or you do anything interesting with it!</p>
|js};
      };
      {
        updated = {js|2011-09-29 11:10|js};
        authors =
          [
            {
              name = {js|Anil Madhavapeddy|js};
              uri = Some {js|http://anil.recoil.org|js};
              email = Some {js|anil@recoil.org|js};
            };
          ];
        subject = {js|An Outing to CUFP 2011|js};
        permalink = {js|an-outing-to-cufp|js};
        body =
          {js|<p>The team signed up to do a tutorial at <a href="http://cufp.org">CUFP</a> on the topic of <a href="http://cufp.org/conference/sessions/2011/t3-building-functional-os">Building a Functional OS</a>, which meant zooming off to Tokyo!  This was the first public show of the project, and resulted in a furious <a href="https://github.com/avsm/mirage/graphs/impact">flurry of commits</a> from the whole team to get it ready. The 45-strong crowd at the tutorial were really full of feedback, and particular thanks to <a href="http://www.deinprogramm.de/sperber/">Michael</a> for organising the event, and <a href="http://ocaml.janestreet.com/?q=blog/5">Yaron</a>, <a href="http://monkey.org/~marius/">Marius</a>, <a href="https://twitter.com/#!/stevej">Steve</a>, <a href="https://twitter.com/wil">Wil</a>, <a href="https://twitter.com/#!/adoemon">Adrian</a> and the rest for shouting out questions regularly!</p>
<ul>
<li>
<p><em>The tutorial</em> is <a href="http://github.com/avsm/mirage-tutorial">a Mirage application</a>, so you can clone it and view it locally through your web browser. The content is mirrored at <a href="http://tutorial.openmirage.org">tutorial.openmirage.org</a>, although it does require cleanup to make it suitable to an online audience. The SVG integration is awkward and it only works on Chrome/Safari, so I will probably rewrite it using <a href="http://imakewebthings.github.com/deck.js/">deck.js</a> soon. The tutorial is a good showcase of Mirage, as it compiles to Xen, UNIX (both kernel sockets and direct tuntap) with a RAMdisk or external filesystem, and is a good way to mess around with application synthesis (look at the <code>Makefile</code> targets in <code>slides/</code>).</p>
</li>
<li>
<p><em>Installation</em>: <a href="/wiki/install">instructions</a> have been simplified, and we now only require OCaml on the host and include everything else in-tree. Thomas has also made Emacs and Vim plugins that are compatible with the ocamlbuild layout.</p>
</li>
<li>
<p><em>Lwt</em>: a <a href="/wiki/tutorial-lwt">new tutorial</a> which walks you through the cooperative threading library we use, along with exercises (all available in <a href="http://github.com/avsm/mirage-tutorial">mirage-tutorial</a>). Raphael and Balraj are looking for feedback on this, so get in touch!</p>
</li>
<li>
<p><em>Javascript</em>: via <a href="http://nodejs.org">node.js</a> did not work in time for the tutorial, as integrating I/O is a tangled web that will take some time to sort out. Raphael is working on this in a <a href="https://github.com/raphael-proust/nodejs_of_ocaml">separate tree</a> for now.  As part of this effort though, he integrated a pure OCaml <a href="/blog/ocaml-regexp">regular expression library</a> that does not require C bindings, and is surprisingly fast.</p>
</li>
<li>
<p><em>Devices</em>: we can now synthesise binaries that share common code but have very different I/O interfaces. This is due to a new device manager, and David also heroically wrote a complete <a href="http://github.com/avsm/mirage/tree/master/lib/fs">FAT12/16/32 library</a> that we demonstrated.  Yaron Minsky suggested a <a href="https://gist.github.com/1245418">different approach</a> to the device manager using <a href="http://caml.inria.fr/pub/docs/manual-ocaml/extn.html#sec245">first-class modules</a> instead of objects, so I am experimentally trying this before writing documentation on it.</p>
</li>
<li>
<p><em>TCP</em>: the notorious Mirage stack is far more robust due to our resident networking guru Balraj hunting down last-minute bugs. Although it held together with sticky tape during the tutorial, he is now adding retransmission and congestion control to make it actually standards-compliant.  Still, if you dont have any packet loss, the <a href="http://xen.openmirage.org/">unikernel version</a> of this website does actually serve pages.</p>
</li>
<li>
<p><em>OpenFlow</em>: is a new <a href="http://www.openflow.org/wk/index.php/OpenFlow_v1.0">standard</a> for <a href="http://networkheresy.wordpress.com/">Software Defined Networking</a>, and Haris and Mort have been hacking away at a complete implementation directly in Mirage!  We will be giving a tutorial on this at the <a href="http://changeofelia.info.ucl.ac.be/">OFELIA summer school</a> in November (it is summer somewhere, I guess). The prospect of a high-speed unikernel switching fabric for the cloud, programmed in a functional style, is something I am really looking forward to seeing!</p>
</li>
<li>
<p><em>Jane Street Core</em>: preceeding us was Yaron's <a href="http://cufp.org/conference/sessions/2011/t2-janestreets-ocaml-core-library">Core</a> tutorial. Since Mirage provides it own complete standard library, we can adopt portions of Core that do not require OS threads or UNIX-specific features.  I really like the idea that Mirage enforces a discipline on writing portable interfaces, as dependencies on OS-specific features do sneak in insiduously and make switching to different platforms very difficult (e.g. Windows support). Incidentally, Yaron's <a href="http://queue.acm.org/detail.cfm?id=2038036&amp;ref=fullrss">ACM Queue</a> article is a great introduction to OCaml.</p>
</li>
</ul>
<p>So as you can see, it has been a busy few months!  Much of the core of Mirage is settling down now, and we are writing a paper with detailed performance benchmarks of our various backends.  Keep an eye on the <a href="https://github.com/avsm/mirage/issues?milestone=2&amp;state=open">Github milestone</a> for the preview release, join our <a href="https://lists.cam.ac.uk/mailman/listinfo/cl-mirage">new mailing list</a>, or follow the newly sentient <a href="http://twitter.com/openmirage">openmirage on twitter</a>!</p>
|js};
      };
      {
        updated = {js|2011-08-12 15:00|js};
        authors =
          [
            {
              name = {js|Raphael Proust|js};
              uri = Some {js|https://github.com/raphael-proust|js};
              email = Some {js|raphlalou@gmail.com|js};
            };
          ];
        subject = {js|Portable Regular Expressions|js};
        permalink = {js|ocaml-regexp|js};
        body =
          {js|<p>MirageOS targets different backends: micro-kernels for the Xen hypervisor, Unix
executables and Javascript programs. The recent inclusion of the Javascript
backend makes many C bindings unsuitable. In order to push backend incompatibilities
closer to the application level, it is necessary to either reimplement the C
bindings in Javascript or OCaml, or remove them completely. This is particularly
important for the standard library.</p>
<p>##The <code>Str</code> module has to go!</p>
<p><code>Str</code> provides regular expressions in a non-reentrant, non-functional fashion.
While the OCaml distribution provides it in <code>otherlibs</code>, it is installed by
default and so widely used, and implemented under the hood via a C library.
Regular expressions are used in several places in MirageOS, mainly for small
operations (splitting, getting an offset, etc.), and so having a portable
fallback written in pure OCaml would be very useful.</p>
<p>There are several possible ways to replace the <code>Str</code> module, each with its own
set of perks and drawbacks:</p>
<ul>
<li>Use a backend-neutral regexp library which &quot;translates&quot; to either <code>Str</code>
or <code>Pcre</code> for the Xen and Unix backends or Javascript native regexps for
the Javascript backend. This solution may be hard to maintain, especially if a
fourth backend is to be included. Moreover each regexp library uses a slightly
different convention for regexps (e.g. see the
<a href="http://vimdoc.sourceforge.net/htmldoc/pattern.html#/magic">magic</a> option in
vim) which means that a lot of translation code might be needed.
</li>
<li>Do string processing without regexps (using <code>String.index</code> and the likes).
This solution is portable and potentially efficient. However, the potential
efficiency comes from a low-level way of doing things.
</li>
<li>Use an OCaml regexp library without C bindings. We expected such a library to
be slower than <code>Str</code> and needed an estimation of performance cost in order to
assess the practicality of the solution.
</li>
</ul>
<p>##Benchmarking <code>Str</code></p>
<p>There is a purely OCaml regexp library readily available, called <code>Regexp</code> and
developed by Claude Marché from the LRI laboratory. You can find the
documentation and the source on the associated
<a href="http://www.lri.fr/~marche/regexp/">webpage</a>. After getting rid of mutexes
(which, in MirageOS, are of no use, because of the <code>Lwt</code> based
concurrency), we benchmarked it against <code>Str</code>. We also included the popular
<code>Pcre</code> (Perl Compatible Regular Expression) library that is widely used.</p>
<p>The benchmark (available <a href="http://github.com/raphael-proust/regexp-benchmark.git">on github</a>)
is really simple and measures three different factors:</p>
<ul>
<li>regexp construction: the transformation of a string (or another representation
available to the programmer) into the internal representation of regexps used
by the library
</li>
<li>regexp usage: the execution of operations using regexps
</li>
<li>string size: the length of the string being matched
</li>
</ul>
<p>MirageOS uses regexp in a specific pattern: a limited number of regexp
constructions with a potentially high number of invocation (e.g. HTTP header parsing).
The size of the strings on which regexps are used may vary.  Because of this pattern,
our benchmark does not take regexp construction overhead into account.</p>
<p>Here are the execution times of approximately 35000 string matching operations
on strings of 20 to 60 bytes long.</p>
<img src="/graphics/all_1_1000_10.png"/>
<p>Quite surprisingly for the string matching operation, the C based <code>Str</code> module
is less efficient than the pure OCaml <code>Regexp</code>. The <code>Pcre</code> results were even worse
than <code>Str</code>. Why?</p>
<p>###A simple library for a simple task</p>
<p>The <code>Regexp</code> library is lightweight, and so far faster than its C based
counterparts. One of the features <code>Regexp</code> lacks is &quot;group capture&quot;: the ability
to refer to blocks of a previously matched string. In <code>Pcre</code> it is possible to
explicitly and selectively turn group capturing off via special syntax,
instead of the regular parentheses. <code>Str</code> does not offer  this, and thus
imposes the runtime cost of capture even when not necessary. In other words, the
slowdown/group capturing &quot;is not a feature, it's a bug!&quot;</p>
<p>###The MirageOS Regexp library</p>
<p>With the introduction of <code>Regexp</code> into the tree, the libraries available to MirageOS
applications are now <code>Str</code>-free and safer to use across multiple backends. The main
drawback is a slight increase in verbosity of some parts of the code.
Benchmarking the substitution operation is also necessary to assess the
performance gain/loss (which we will do shortly).</p>
<p>In addition to cosmetic and speed considerations, it is important to consider the
portability increase: MirageOS's standard library is <a href="http://nodejs.org">Node.js</a> compatible,
a feature we will explore shortly!</p>
|js};
      };
      {
        updated = {js|2011-06-18 15:47|js};
        authors =
          [
            {
              name = {js|Anil Madhavapeddy|js};
              uri = Some {js|http://anil.recoil.org|js};
              email = Some {js|anil@recoil.org|js};
            };
          ];
        subject = {js|Delimited Continuations vs Lwt for Threads|js};
        permalink = {js|delimcc-vs-lwt|js};
        body =
          {js|<p>MirageOS is a fully event-driven system, with no support for conventional <a href="http://en.wikipedia.org/wiki/POSIX_Threads">preemptive threads</a>.  Instead, programs are woken by events such as incoming network packets, and event callbacks execute until they themselves need to block (due to I/O or timers) or complete their task.</p>
<p>Event-driven systems are simple to implement, scalable to lots of network clients, and very hip due to frameworks like <a href="http://nodejs.org">node.js</a>. However, programming event callbacks directly leads to the control logic being scattered across many small functions, and so we need some abstractions to hide the interruptions of registering and waiting for an event to trigger.</p>
<p>OCaml has the excellent <a href="http://ocsigen.org">Lwt</a> threading library that utilises a monadic approach to solving this.
Consider this simplified signature:</p>
<pre><code>  val return : 'a -&gt; 'a Lwt.t 
  val bind : 'a Lwt.t -&gt; ('a -&gt; 'b Lwt.t) -&gt; 'b Lwt.t
  val run : 'a Lwt.t -&gt; 'a
</code></pre>
<p>Threads have the type <code>'a Lwt.t</code>, which means that the thread will have a result of type <code>'a</code> when it finishes.
The <code>return</code> function is the simplest way to construct such a thread from an OCaml value.</p>
<p>If we then wish to use the value of thread, we must compose a function that will be called in the future when the thread completes. This is what the <code>bind</code> function above is for. For example, assume we have a function that will let us sleep for some time:</p>
<pre><code>  val sleep: int -&gt; unit Lwt.t
</code></pre>
<p>We can now use the <code>bind</code> function to do something after the sleep is complete:</p>
<pre><code>  let x = sleep 5 in
  let y = bind x (fun () -&gt; print_endline &quot;awake!&quot;) in
  run y
</code></pre>
<p><code>x</code> has the type <code>unit Lwt.t</code>, and the closure passed to <code>bind</code> will eventually be called with <code>unit</code> when the sleep finishes. Note that we also need a function to actually begin evaluating an Lwt thread, which is the <code>run</code> function.</p>
<p>##Concerns</p>
<p>MirageOS currently uses Lwt extensively, and we have been very happy with using it to build a network stack. However, I was surprised to hear a lot of debate at the <a href="http://anil.recoil.org/2011/04/15/ocaml-users-group.html">2011 OCaml Users Group</a> meeting that Lwt is not to everyone's tastes. There are a few issues:</p>
<ul>
<li>
<p>The monadic style means that existing code will not just work. Any code that might block must be adapted to use <code>return</code> and <code>bind</code>, which makes integrating third-party code problematic.</p>
</li>
<li>
<p>More concerningly, any potential blocking points require the allocation of a closure. This allocation is very cheap in OCaml, but is still not free. Jun Furuse notes that combinator-based systems are slower during the development of his <a href="http://camlspotter.blogspot.com/2011/05/planck-small-parser-combinator-library.html">Planck parser</a>.</p>
</li>
</ul>
<p>Lwt addresses the first problem via a comprehensive <a href="http://ocsigen.org/lwt/2.3.0/api/Pa_lwt">syntax extension</a> which provides Lwt equivalents for many common operations. For example, the above example with sleep can be written as:</p>
<pre><code>  lwt x = sleep 5 in
  print_endline &quot;awake&quot;
</code></pre>
<p>The <code>lwt</code> keyword indicates the result of the expression should be passed through <code>bind</code>, and this makes it possible to write code that looks more OCaml-like. There are also other keywords like <code>for_lwt</code> and <code>match_lwt</code> that similarly help with common control flow constructs.</p>
<p>##Fibers</p>
<p>After the meeting, I did get thinking about using alternatives to Lwt in MirageOS. One exciting option is the <a href="http://okmij.org/ftp/continuations/implementations.html">delimcc</a> library which implements <a href="http://en.wikipedia.org/wiki/Delimited_continuation">delimited continuations</a> for OCaml.  These can be used to implement restartable exceptions: a program can raise an exception which can be invoked to resume the execution as if the exception had never happened.
Delimcc can be combined with Lwt very elegantly, and Jake Donham did just this with the <a href="http://ambassadortothecomputers.blogspot.com/2010/08/mixing-monadic-and-direct-style-code.html">Lwt_fiber</a> library. His post also has a detailed explanation of how <code>delimcc</code> works.</p>
<p>The interface for fibers is also simple:</p>
<pre><code>  val start: (unit -&gt; 'a) -&gt; 'a Lwt.t
  val await : 'a Lwt.t -&gt; 'a
</code></pre>
<p>A fiber can be launched with <code>start</code>, and during its execution can block on another thread with <code>await</code>.  When it does block, a restartable exception saves the program stack back until the point that <code>start</code> was called, and it will be resumed when the thread it blocked on completes.</p>
<p>##Benchmarks</p>
<p>I put together a few microbenchmarks to try out the performance of Lwt threads versus fibers. The fiber test looks like this:</p>
<pre><code>  module Fiber = struct
    let basic fn yields =
      for i = 1 to 15000 do
        for x = 1 to yields do
          Lwt_fiber.await (fn ())
        done
      done

    let run fn yields =
      Lwt_fiber.start (fun () -&gt; basic fn yields)
  end
</code></pre>
<p>We invoke the run function with two arguments: a thread to use for blocking and the number of times we should yield serially (so we can confirm that an increasing number of yields scales linearly).  The Lwt version is pretty similar:</p>
<pre><code>  module LWT = struct
    let basic fn yields =
      for_lwt i = 1 to 15000 do
        for_lwt x = 1 to yields do
          fn ()
        done
      done
  
    let run = basic
  end
</code></pre>
<p>We do not need to do anything special to launch a thread since we are already in the Lwt main loop, and the syntax extension makes the <code>for</code> loops look like the Fiber example above.</p>
<p>The choice of blocking function is important. The first test runs using a fast <code>Lwt.return ()</code> that returns immediately:</p>
<img src="http://chart.apis.google.com/chart?cht=lxy&amp;chs=600x250&amp;chtt=Direct%20non-blocking%20overhead&amp;chco=FF0000,00FF00,0000FF,FFAA00,AA00FF,00FFFF&amp;chxt=x,x,y,y&amp;chxl=1:|number-of-yields|3:|seconds&amp;chds=a&amp;chg=10,10,1,5&amp;chd=t:50,100,200,300,400,600,800,1000|0.101,0.195,0.388,0.581,0.775,1.157,1.548,1.926|50,100,200,300,400,600,800,1000|0.095,0.188,0.371,0.553,0.737,1.104,1.469,1.836&amp;chdl=delimcc-basic-quick|lwt-basic-quick&amp;chdlp=t&amp;chls=2|2" />
<p>The x-axis on the above graph represents the number of yields in each loop. Both <code>Lwt_fiber</code> and pure <code>Lwt</code> optimise the case where a thread returns immediately, and so this graph simply tells us that the fast path is working (which is nice!). The next test replaces the blocking function with two alternatives that force the thread to yield:</p>
<img src="http://chart.apis.google.com/chart?cht=lxy&amp;chs=600x250&amp;chtt=Direct%20blocking%20overhead&amp;chco=FF0000,00FF00,0000FF,FFAA00,AA00FF,00FFFF&amp;chxt=x,x,y,y&amp;chxl=1:|number-of-yields|3:|seconds&amp;chds=a&amp;chg=10,10,1,5&amp;chd=t:50,100,200,300,400,600,800,1000|2.601,5.204,10.401,15.611,20.783,31.221,41.606,52.016|50,100,200,300,400,600,800,1000|1.270,2.539,5.089,7.626,10.188,15.338,20.385,25.473|50,100,200,300,400,600,800,1000|4.011,8.013,15.973,23.995,32.075,47.940,63.966,79.914|50,100,200,300,400,600,800,1000|2.433,4.861,9.692,14.543,19.702,29.579,39.458,49.260&amp;chdl=lwt-basic-slow|lwt-basic-medium|delimcc-basic-slow|delimcc-basic-medium&amp;chdlp=t&amp;chls=2|2|2|2"/>
<p>There are two blocking functions used in the graph above:</p>
<ul>
<li>the &quot;slow&quot; version is <code>Lwt_unix.sleep 0.0</code> which forces the registration of a timeout.
</li>
<li>the &quot;medium&quot; version is <code>Lwt.pause ()</code> which causes the thread to pause and drop into the thread scheduler. In the case of <code>Lwt_fiber</code>, this causes an exception to be raised so we can benchmark the cost of using a delimited continuation.
</li>
</ul>
<p>Interestingly, using a fiber is slower than normal Lwt here, even though our callstack is not very deep.  I would have hoped that fibers would be significantly cheaper with a small callstack, as the amount of backtracking should be quite low.  Lets confirm that fibers do in fact slow down as the size of the callstack increases via this test:</p>
<pre><code>  module Fiber = struct
    let recurse fn depth =
      let rec sum n = 
        Lwt_fiber.await (fn ());
        match n with
        |0 -&gt; 0
        |n -&gt; n + (sum (n-1)) 
      in
      for i = 1 to 15000 do
        ignore(sum depth)
      done

    let run fn depth = 
      Lwt_fiber.start (fun () -&gt; recurse fn depth)
  end
</code></pre>
<p>The <code>recurse</code> function is deliberately not tail-recursive, so that the callstack increases as the <code>depth</code> parameter grows.  The Lwt equivalent is slightly more clunky as we have to rewrite the loop to bind and return:</p>
<pre><code>  module LWT = struct
    let recurse fn depth =
      let rec sum n =
        lwt () = fn () in
        match n with
        |0 -&gt; return 0
        |n -&gt;
          lwt n' = sum (n-1) in 
          return (n + n')
      in
      for_lwt i = 1 to 15000 do
        lwt res = sum depth in
        return ()
      done

   let run = recurse
  end
</code></pre>
<p>We then run the experiment using the slow <code>Lwt_unix.sleep 0.0</code> function, and get this graph:</p>
<img src="http://chart.apis.google.com/chart?cht=lxy&amp;chs=600x250&amp;chtt=Recurse%20vs%20basic&amp;chco=FF0000,00FF00,0000FF,FFAA00,AA00FF,00FFFF&amp;chxt=x,x,y,y&amp;chxl=1:|stack-depth|3:|seconds&amp;chds=a&amp;chg=10,10,1,5&amp;chd=t:50,100,200,300,400,600,800,1000|6.264,15.567,44.297,86.823,142.372,310.036,603.735,939.165|50,100,200,300,400,600,800,1000|2.601,5.204,10.401,15.611,20.783,31.221,41.606,52.016|50,100,200,300,400,600,800,1000|2.769,5.564,11.497,17.631,23.826,36.700,49.314,61.794|50,100,200,300,400,600,800,1000|4.011,8.013,15.973,23.995,32.075,47.940,63.966,79.914&amp;chdl=delimcc-recurse-slow|lwt-basic-slow|lwt-recurse-slow|delimcc-basic-slow&amp;chdlp=t&amp;chls=2|2|2|2"/>
<p>The above graph shows the recursive Lwt_fiber getting slower as the recursion depth increases, with normal Lwt staying linear.  The graph also overlays the non-recursing versions as a guideline (<code>*-basic-slow</code>).</p>
<p>##Thoughts</p>
<p>This first benchmark was a little surprising for me:</p>
<ul>
<li>I would have thought that <code>delimcc</code> to be ahead of Lwt when dealing with functions with a small call-depth and a small amount of blocking (i.e. the traffic pattern that loaded network servers see). The cost of taking a restartable exception seems quite high however.
</li>
<li>The fiber tests still use the Lwt machinery to manage the callback mechanism (i.e. a <code>select</code> loop and the timer priority queue). It may be possible to create a really light-weight version just for <code>delimcc</code>, but the Lwt UNIX backend is already pretty lean and mean and uses the <a href="http://software.schmorp.de/pkg/libev.html">libev</a> to interface with the OS.
</li>
<li>The problem of having to rewrite code to be Lwt-like still exists unfortunately, but it is getting better as the <code>pa_lwt</code> syntax extension matures and is integrated into my <a href="https://github.com/raphael-proust/ocaml_lwt.vim">favourite editor</a> (thanks Raphael!)
</li>
<li>Finally, by far the biggest benefit of <code>Lwt</code> is that it can be compiled straight into Javascript using the <a href="http://ocsigen.org/js_of_ocaml/">js_of_ocaml</a> compiler, opening up the possibility of cool browser visualisations and tickets to cool <code>node.js</code> parties that I don't normally get invited to.
</li>
</ul>
<p>I need to stress that these benchmarks are very micro, and do not take into account other things like memory allocation. The standalone code for the tests is <a href="http://github.com/avsm/delimcc-vs-lwt">online at Github</a>, and I would be delighted to hear any feedback.</p>
<p>##Retesting recursion [18th Jun 2011]</p>
<p>Jake Donham comments:</p>
<blockquote>
<p>I speculated in my post that fibers might be faster if the copy/restore were amortized over a large stack. I wonder if you would repeat the experiment with versions where you call fn only in the base case of sum, instead of at every call. I think you're getting N^2 behavior here because you're copying and restoring the stack on each iteration.</p>
</blockquote>
<p>When writing the test, I figured that calling the thread waiting function more often wouldn't alter the result (careless). So I modified the test suite to have a <code>recurse</code> test that only waits a single time at the end of a long call stack (see below) as well as the original N^2 version (now called <code>recurse2</code>).</p>
<pre><code>  module Fiber = struct
    let recurse fn depth =
      let rec sum n = 
        match n with
        |0 -&gt; Lwt_fiber.await (fn ()); 0
        |n -&gt; n + (sum (n-1)) 
      in
      for i = 1 to 15000 do
        ignore(sum depth)
      done

    let run fn depth = 
      Lwt_fiber.start (fun () -&gt; recurse fn depth)
  end
</code></pre>
<p>The N^2 version below of course looks the same as the previously run tests, with delimcc getting much worse as it yields more often:</p>
<img src="http://chart.apis.google.com/chart?cht=lxy&amp;chs=600x250&amp;chtt=Recurse2%20vs%20basic&amp;chco=FF0000,00FF00,0000FF,FFAA00,AA00FF,00FFFF&amp;chxt=x,x,y,y&amp;chxl=1:|stack-depth|3:|seconds&amp;chds=a&amp;chg=10,10,1,5&amp;chd=t:50,100,200,300,400,600,800,1000|0.282,0.566,1.159,1.784,2.416,3.719,5.019,6.278|50,100,200,300,400,600,800,1000|0.658,1.587,4.426,8.837,14.508,31.066,60.438,94.708&amp;chdl=lwt-recurse2-slow|delimcc-recurse2-slow&amp;chdlp=t&amp;chls=2|2" /> 
<p>However, when we run the <code>recurse</code> test with a single yield at the end of the long callstack, the situation reverses itself and now <code>delimcc</code> is faster. Note that this test ran with more iterations than the <code>recurse2</code> test to make the results scale, and so the absolute time taken cannot be compared.</p>
<img src="http://chart.apis.google.com/chart?cht=lxy&amp;chs=600x250&amp;chtt=Recurse%20vs%20basic&amp;chco=00FF00,FF0000,0000FF,FFAA00,AA00FF,00FFFF&amp;chxt=x,x,y,y&amp;chxl=1:|stack-depth|3:|seconds&amp;chds=a&amp;chg=10,10,1,5&amp;chd=t:50,100,200,300,400,600,800,1000|0.162,0.216,0.341,0.499,0.622,0.875,1.194,1.435|50,100,200,300,400,600,800,1000|0.128,0.207,0.394,0.619,0.889,1.538,2.366,3.373&amp;chdl=delimcc-recurse-slow|lwt-recurse-slow&amp;chdlp=t&amp;chls=2|2" />
<p>The reason for Lwt being slower in this becomes more clear when we examine what the code looks like after it has been passed through the <code>pa_lwt</code> syntax extension. The code before looks like:</p>
<pre><code>  let recurse fn depth =
    let rec sum n =
      match n with
      | 0 -&gt; 
          fn () &gt;&gt; return 0
      | n -&gt;
          lwt n' = sum (n-1) in 
          return (n + n') in
</code></pre>
<p>and after <code>pa_lwt</code> macro-expands it:</p>
<pre><code>  let recurse fn depth =
    let rec sum n =
      match n with
      | 0 -&gt;
          Lwt.bind (fn ()) (fun _ -&gt; return 0)
      | n -&gt;
          let __pa_lwt_0 = sum (n - 1)
          in Lwt.bind __pa_lwt_0 (fun n' -&gt; return (n + n')) in
</code></pre>
<p>Every iteration of the recursive loop requires the allocation of a closure (the <code>Lwt.bind</code> call). In the <code>delimcc</code> case, the function operates as a normal recursive function that uses the stack, until the very end when it needs to save the stack in one pass.</p>
<p>Overall, I'm convinced now that the performance difference is insignificant for the purposes of choosing one thread system over the other for MirageOS.  Instead, the question of code interoperability is more important. Lwt-enabled protocol code will work unmodified in Javascript, and Delimcc code helps migrate existing code over.</p>
<p>Interestingly, <a href="https://developer.mozilla.org/en/new_in_javascript_1.7">Javascript 1.7</a> introduces a <em>yield</em> operator, which <a href="http://parametricity.net/dropbox/yield.subc.pdf">has been shown</a> to have comparable expressive power to the <em>shift-reset</em> delimcc operators. Perhaps convergence isn't too far away after all...</p>
|js};
      };
      {
        updated = {js|2011-04-11 15:00|js};
        authors =
          [
            {
              name = {js|Anil Madhavapeddy|js};
              uri = Some {js|http://anil.recoil.org|js};
              email = Some {js|anil@recoil.org|js};
            };
          ];
        subject = {js|A Spring Wiki Cleaning|js};
        permalink = {js|spring-cleaning|js};
        body =
          {js|<p>We've been plugging away on Mirage for the last few months, and things are starting to take shape nicely. As the older blog entries were out-of-date, we have shifted the descriptive material to a new <a href="/wiki">wiki</a> section instead. What else has been happening?</p>
<ul>
<li>The Xen unikernel backend is fully event-driven (no interrupts) and very stable under stress testing now. The TCP stack is also complete enough to self-host this website, and you can try it out by navigating to <a href="http://xen.openmirage.org">xen.openmirage.org</a>. The stack doesnt actually do retransmissions yet, so your user experience may &quot;vary&quot;. Check out the <a href="/wiki/install">installation</a> and <a href="/wiki/hello-world">hello world</a> guides to try it out for yourself.
</li>
<li><a href="http://www.cs.nott.ac.uk/~rmm/">Richard Mortier</a> has put together a performance testing framework that lets us analyse the performance of Mirage applications on different backends (e.g. UNIX vs Xen), and against other conventional applications (e.g. BIND for DNS serving). Read more in the wiki <a href="/wiki/performance">here</a>.
</li>
<li><a href="http://gazagnaire.org">Thomas Gazagnaire</a> has rewritten the website to use the COW syntax extensions. He has also started a new job with <a href="http://www.ocamlpro.com/">OCamlPro</a> doing consultancy on OCaml, so congratulations are in order!
</li>
<li>Thomas has also started integrating experimental Node.js support to fill in our buzzword quota for the year (and more seriously, to explore alternative VM backends for Mirage applications).
</li>
<li>The build system (often a bugbear of such OS projects) now fully uses <a href="https://github.com/ocaml/ocamlbuild">ocamlbuild</a> for all OCaml and C dependencies, and so the whole OS can be rebuilt with different compilers (e.g. LLVM) or flags with a single invocation.
</li>
</ul>
<p>There are some exciting developments coming up later this year too!</p>
<ul>
<li><a href="https://github.com/raphael-proust">Raphael Proust</a> will be joining the Mirage team in Cambridge over the summer in an internship.
</li>
<li>Anil Madhavapeddy will be giving several <a href="/wiki/talks">tech talks</a> on Mirage: at the <a href="https://forge.ocamlcore.org/plugins/mediawiki/wiki/ocaml-meeting/index.php/OCamlMeeting2011">OCaml User's Group</a> in Paris this Friday, at <a href="http://acunu.com">Acunu</a> in London on May 31st, and at Citrix Cambridge on June 3rd. If you are interested, please do drop by and say hi.
</li>
<li>Verisign has supported the project with an <a href="http://www.marketwire.com/press-release/Verisign-Announces-Winners-of-Grants-Aimed-at-Strengthening-Internet-Infrastructure-NASDAQ-VRSN-1412893.htm">Internet Infrastructure Grant</a>.
</li>
<li><a href="http://dave.recoil.org">David Scott</a> (chief architect of the Xen Cloud Platform) and <a href="http://anil.recoil.org">Anil Madhavapeddy</a> will give a joint tutorial on constructing functional operating systems at the <a href="http://cufp.org">Commercial Users of Functional Programming</a> workshop in Tokyo, Japan in September.
</li>
</ul>
|js};
      };
      {
        updated = {js|2010-10-11 15:00|js};
        authors =
          [
            {
              name = {js|Anil Madhavapeddy|js};
              uri = Some {js|http://anil.recoil.org|js};
              email = Some {js|anil@recoil.org|js};
            };
          ];
        subject = {js|Self-hosting MirageOS website|js};
        permalink = {js|self-hosting-mirage-website|js};
        body =
          {js|<p>Welcome to the new self-hosting website for the Mirage project!  As we go about preparing a release for later in the year, this blog will contain technical musings and work-in-progress reports of various bits of the operating system as they mature. Since there's so much to talk about, we decided to start with a blog format, and eventually collect things into a proper document as they stabilise.</p>
<p>Feel free to subscribe to the <a href="/blog/atom.xml">Atom</a> feed to keep up-to-date with our progress, or just e-mail us or comment on individual posts with any queries.</p>
|js};
      };
    ]
end

module Wiki = struct
  type t = {
    updated : string;
    author : People.t;
    subject : string;
    permalink : string;
    body : string;
  }

  let all =
    [
      {
        updated = {js|2022-01-24 16:00|js};
        author =
          {
            name = {js|Thomas Gazagnaire|js};
            uri = Some {js|http://gazagnaire.org|js};
            email = Some {js|thomas@gazagnaire.org|js};
          };
        subject = {js|Mirage 4|js};
        permalink = {js|mirage-4|js};
        body =
          {js|<p>Welcome to the MirageOS 4 release page. No official announcement has been made,
but the current work is available as a bleeding-edge repository.</p>
<p>You can follow the advances in the release process through the
<a href="https://github.com/mirage/mirage/issues/1217">tracking issue</a>.</p>
<h3>What's new ?</h3>
<p>The main change is a deep modification on how unikernels are built. One of the
purposes of MirageOS is to orchestrate a build a system in order to produce the desired
unikernel binary. Until MirageOS 4, the build system was <code>ocamlbuild</code>. Now, we switched
to <code>dune</code>. Following a global shift to the <code>dune</code> build system, this enables us many
features that were slowing down the MirageOS development workflow.</p>
<ul>
<li>
<p><strong>Monorepos</strong>: unikernel sources are locally fetched to be compiled by <code>dune</code>. This
implies that one can locally edit theses sources to test changes, before sending them
to the upstream repository. It replaces the usual <code>opam pin ...</code> / edit sources /
<code>opam reinstall ...</code> workflow.</p>
<p>The monorepos are built using the <a href="https://github.com/ocamllabs/opam-monorepo">opam-monorepo</a>
tool, consisting in two steps. First a lockfile is generated, performing the
dependency resolution and locking packages to specific versions. Then the lockfile is
used to locally fetch the sources.</p>
</li>
<li>
<p><strong>Cross-compilation</strong>: one of the problems of MirageOS 3.x was the difficulty to create
new targets into the ecosystem, especially cross-archicture targets. Because opam
installs packages for the host architecture, one would have to create a parallel
repository in which packages are cross-compiled, such as
<a href="https://github.com/ocaml-cross/opam-cross-android">opam-cross-android</a> or
<a href="https://github.com/well-typed-lightbulbs/opam-cross-esp32">opam-cross-esp32</a>. That
<em>parallel world</em> idea has also been implemented using <code>esy</code>: see
<a href="https://github.com/EduardoRFS/reason-mobile">reason-mobile</a>.</p>
<p>The MirageOS 4 solution takes advantage of the dune <em>workspaces</em> feature, which
defines a global compilation environment (OCaml compiler, C compiler, flags and
environment variables) to be used to build all the sources that are locally available.
As a consequence, porting a new target to Mirage 4 will only rely on having a
<em>freestanding</em> (i.e. OS-free) OCaml compiler.</p>
</li>
<li>
<p><strong>Reproducible workflow</strong>: because lockfiles are used to fetch the unikernel sources,
we can ensure that the exact same sources will be used to build the unikernel as the as
the lockfile has not changed. Additional work might be required to ensure that the
rest of the tools (mirage, dune, ocaml-freestanding) are also locked to a specific
version.</p>
</li>
<li>
<p><strong>Merlin support</strong>: <code>dune</code> automatically enables the usage of <code>merlin</code> to improve the
developper experience. Its editor support can be enabled for example by using the ocaml
LSP server. Due to current limitations, <code>merlin</code> can be enabled either on the
<code>config.ml</code> file or the unikernel files, but not both at the same time.</p>
<p>Note that until the next release of <code>dune</code>, <code>merlin</code> support must be activated manually
in the <code>dune-workspace</code> file. <a href="https://dune.readthedocs.io/en/stable/dune-files.html#context">documentation</a></p>
</li>
</ul>
<h3>Ecosystem changes</h3>
<ul>
<li>
<p><strong>Port to dune</strong>: since the beginning of the work on MirageOS 4, many packages have
been ported to dune. This is a <em>requirement</em> to be able to use it in a unikernel.
The libraries using alternative build systems (such as <code>B0</code>) have been ported to <code>dune</code>,
but as upstreaming the work is not expected, the MirageOS team maintains a repository
of <em>build system forks</em>: <a href="https://github.com/mirage/opam-overlays">mirage/opam-overlays</a>.</p>
<p>The mission of porting and maintaining <em>dune-built</em> forks is assured by the
<a href="https://github.com/dune-universe">dune-universe</a> team.</p>
</li>
<li>
<p><strong>Solo5 and OCaml-freestanding</strong>: to support the new <em>cross-compilation</em> workflow,
<code>solo5</code> becomes a cross-compilation toolchain (<code>ARCH-solo5-none-static-cc</code>) and
<code>ocaml-freestanding</code> becomes an OCaml cross-compiler based on that solo5 toolchain.</p>
</li>
<li>
<p><strong>C stubs compilation</strong>: the rule for C stubs compilation has also changed. Until now,
package maintainers that uses C stubs had to add some code to build the C stubs using the
<code>solo5</code> flags, through the <code>ocaml-freestanding</code> <code>pkg-config</code> file.</p>
<p>Now, package maintainers should only care about writing portable code once, and built it
using <code>dune</code> rules.</p>
</li>
</ul>
<p>To sum it up, here are the <strong>portable compilation rules</strong> for a package to support Mirage 4.0:</p>
<ol>
<li>Don't depend on <code>unix</code>
</li>
<li>Build your project with <code>dune</code>, and have your transitive dependencies buildable using <code>dune</code>.
</li>
<li>If your project use C stubs, assume the <code>libc</code> is minimal. See <code>ocaml-freestanding</code>'s <code>nolibc</code>
for reference: <a href="https://github.com/mirage/ocaml-freestanding/tree/master/nolibc/include">github.com/mirage/ocaml-freestanding/tree/master/nolibc/include</a>
</li>
</ol>
<h3>Tool changes</h3>
<h5>API breakages</h5>
<p>The functoria devices has changed, switching from requesting objects to a function with optional parameters.
An additional <code>dune</code> field can be used to have additional rules related to the device.</p>
<p>See this <a href="https://github.com/mirage/mirage-skeleton/commit/4d3f7afdcfdff9136cd4e3973afdce9de4934178">commit</a> as
an example on how to adapt the objects to the new interface.</p>
<h5>Configure</h5>
<p>The <code>mirage</code> command-line interface hasn't fundamentally changed, but when a project is <em>configured</em>,
the following additional files are generated:</p>
<ul>
<li><strong>dune.build</strong>: the dune rules to build the unikernel.
</li>
<li><strong>dune.config</strong>: the dune rules to build the unikernel's configuration.
</li>
<li><strong>dune</strong>: switch between <code>dune.build</code> and <code>dune.config</code> depending on the context.
</li>
<li><strong>dune-workspace</strong>: the compilation workspace definition, asking dune to use the ocaml-freestanding
cross-compiler.
</li>
<li><strong>mirage/UNIKERNEL-monorepo.opam</strong>: the unikernel dependencies to lock and fetch using <code>opam-monorepo</code>.
</li>
<li><strong>mirage/UNIKERNEL-switch.opam</strong>: the tool dependencies to <code>opam install</code> (it includes <code>solo5</code> and <code>ocaml-freestanding</code>)
</li>
</ul>
<h5>Fetch</h5>
<p>To fetch and install the dependencies, <code>make depends</code> is still the command to go:</p>
<ul>
<li>it globally installs the build dependencies in the switch.
</li>
<li>it locally fetches using <code>opam-monorepo</code> the unikernel dependencies in the <code>duniverse/</code> folder.
</li>
</ul>
<h5>Build</h5>
<p>To build the unikernel, <code>mirage build</code> and <code>dune build</code> are equivalent.
The output is available in the <code>dist/</code> folder.</p>
<h3>How to test</h3>
<pre><code class="language-sh"># Add the MirageOS 4 development repository
$ opam repo add mirage https://github.com/mirage/mirage-dev.git#master

# Install MirageOS 4
$ opam install mirage

# Clone this website
$ git clone https://github.com/mirage/mirage-www -b next

# Go in the source folder
$ cd mirage-www/src

# Configure the unikernel
$ mirage configure -t hvt

# Fetch and install dependencies
$ make depend

# Build the unikernel
$ mirage build

# Launch it (a tap interface needs to be configured for the hvt target)
$ solo5-hvt --net:service=tap100 dist/www.hvt
</code></pre>
|js};
      };
      {
        updated = {js|2020-06-10 14:00|js};
        author =
          {
            name = {js|Hannes Mehnert|js};
            uri = Some {js|https://github.com/hannesm|js};
            email = Some {js|hm519@cam.ac.uk|js};
          };
        subject = {js|MirageOS unikernel gallery|js};
        permalink = {js|gallery|js};
        body =
          {js|<p>The MirageOS gallery features unikernels that are used in production.</p>
<ul>
<li><a href="https://github.com/mirage/qubes-mirage-firewall">QubesOS Firewall</a> <a href="http://roscidus.com/blog/blog/2016/01/01/a-unikernel-firewall-for-qubesos/">writeup</a>
</li>
<li><a href="https://github.com/Engil/Canopy">Canopy</a>, a git-blogging unikernel, content as markdown in a git remote <a href="http://canopy.mirage.io">online</a>
</li>
<li><a href="https://github.com/roburio/unipi">Unipi</a>, a webserver serving static websites from a git remote
</li>
<li><a href="https://github.com/mirage/mirage-skeleton/tree/master/applications/static_website_tls">Static website server</a>, a unikernel with statically compiled website content
</li>
<li><a href="https://github.com/dinosaure/pasteur">Pastebin</a>, a paste bin <a href="https://paste.x25519.net/">online</a>
</li>
<li><a href="https://github.com/roburio/tlstunnel">Tlstunnel</a>, a TLS reverse proxy
</li>
<li><a href="https://github.com/roburio/caldav/tree/master/mirage">CalDAV</a>, a CalDAV server <a href="https://calendar.robur.coop">online</a>
</li>
<li><a href="https://github.com/roburio/openvpn">OpenVPN</a>, an OpenVPN <a href="https://github.com/roburio/openvpn/tree/master/mirage-server">server</a>, <a href="https://github.com/roburio/openvpn/tree/master/mirage-router">router</a>, and <a href="https://github.com/roburio/openvpn/tree/master/mirage-nat">NAT router</a>
</li>
<li><a href="https://github.com/mirage/mirage-skeleton/tree/master/applications/dhcp">DHCP</a>, a DHCP server
</li>
<li><a href="https://github.com/roburio/dns-primary-git">Primary DNS</a>, an authoritative DNS server
</li>
<li><a href="https://github.com/roburio/dns-secondary">Secondary DNS</a>, a secondary DNS server
</li>
<li><a href="https://github.com/roburio/dns-letsencrypt-secondary">Let's encrypt provisioning</a>, a unikernel which provisions certificates via let's encrypt
</li>
</ul>
<p>Example live unikernels</p>
<ul>
<li><a href="https://github.com/mirleft/btc-pinata">BTC Piñata</a>, a self-serving security bounty <a href="http://ownme.ipredator.se">online</a>
</li>
<li><a href="https://github.com/mirleft/tls-demo-server">TLS handshake demonstration</a>, <a href="https://tls.nqsb.io">online</a>
</li>
<li><a href="https://github.com/mirleft/nqsb.io">NQSB website</a>, website with a single resource, dispatch via SNI <a href="https://nqsb.io">online</a>
</li>
<li><a href="https://github.com/mirage/mirage-www">MirageOS website</a>, <a href="https://mirageos.org">online</a>
</li>
</ul>
<p>Unikernel example repositories</p>
<ul>
<li><a href="https://github.com/mirage/mirage-skeleton">mirage-skeleton</a>
</li>
<li><a href="https://github.com/roburio/unikernels">robur unikernels</a>
</li>
</ul>
|js};
      };
      {
        updated = {js|2019-14-26 17:23|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Security|js};
        permalink = {js|security|js};
        body =
          {js|<p>It's important to consider the process of disclosing issues to us. Many bugs
can be reported as usual on our <a href="https://github.com/mirage/mirage/issues">issue tracker</a>, but public forums are
sometimes inappropriate for reporting security issues.</p>
<p>If you think you've discovered a <strong>security vulnerability</strong>, the best way to
inform us is to send us an email to <strong>security [at] mirage.io</strong>.  One of the
team will respond and we will take it from there.</p>
<p>A OpenPGP key is <a href="http://keys.mayfirst.org/pks/lookup?op=get&amp;fingerprint=on&amp;search=0x4A732D757C0EDA74">available from the keyservers</a>, its fingerprint is <code>23B2 822C 89A9 EC73 C7DF  0748 4A73 2D75 7C0E DA74</code>.</p>
<ul>
<li><a href="https://mirage.io/blog/MSA02">26th April 2019: MSA02 mirage-xen&lt;3.3.0</a>
</li>
<li><a href="https://mirage.io/blog/MSA01">21st March 2019: MSA01 netchannel=1.10.0</a>
</li>
<li><a href="https://mirage.io/blog/MSA00">3rd May 2016: MSA00 mirage-net-xen&lt;1.4.2</a>
</li>
</ul>
|js};
      };
      {
        updated = {js|2019-10-22 15:00|js};
        author =
          {
            name = {js|Anil Madhavapeddy|js};
            uri = Some {js|http://anil.recoil.org|js};
            email = Some {js|anil@recoil.org|js};
          };
        subject = {js|Installation|js};
        permalink = {js|install|js};
        body =
          {js|<p>MirageOS consists of a set of OCaml libraries that link with a runtime to form either a standalone <a href="https://en.wikipedia.org/wiki/Unikernel">unikernel</a> or a normal UNIX binary. These libraries are managed via the <a href="https://opam.ocaml.org">OPAM</a> tool. After describing MirageOS's system requirements, we will introduce the basics of OPAM and setting up for MirageOS.</p>
<h2>Requirements</h2>
<p>MirageOS has been tested on many modern Linux distributions, macOS 10.10+ and FreeBSD 11+.</p>
<p>You will need OPAM 2.0.0 or later and OCaml 4.08.0 or later.</p>
<p>Further requirements for the host/build system depend on the specific backend in use:</p>
<ul>
<li><strong>unix</strong> and <strong>macos</strong>: These backends build a MirageOS unikernel that runs as a normal UNIX binary, without any special isolation or sandboxing. They should build on any modern UNIX (or macOS) system with OCaml and OPAM installed.
</li>
<li><strong>xen</strong> and <strong>qubes</strong>: To compile the <code>xen</code> or <code>qubes</code> backend, you <em>must</em> have a 64-bit Linux or FreeBSD host. To run Xen unikernels, you must have a 64-bit host capable of Xen PVHv2, i.e. Xen version 4.10 or later, or Qubes OS 4.0.
</li>
<li><a href="https://github.com/Solo5/solo5">Solo5</a>-based backends:
<ul>
<li><strong>hvt</strong>: This backend builds a MirageOS unikernel using Solo5 and hardware virtualization for isolation. Compiling the <code>hvt</code> backend is supported on Linux (<code>x86_64</code>, <code>aarch64</code>), FreeBSD and OpenBSD (<code>x86_64</code>) hosts. Running <code>hvt</code> unikernels requires a host system with access to hardware virtualization.
</li>
<li><strong>spt</strong>: This backend builds a MirageOS unikernel using Solo5 and Linux seccomp for isolation. To compile the <code>spt</code> backend, or run an <code>spt</code> unikernel, you <em>must</em> have a Linux (<code>x86_64</code> or <code>aarch64</code>) host.
</li>
<li><strong>virtio</strong>: This backend builds a MirageOS unikernel using Solo5 and capable of running standalone on any <em>virtio</em>-compliant hypervisor on the <code>x86_64</code> architecture, such as Google Compute Engine. Building is supported on Linux, FreeBSD and OpenBSD.
</li>
<li>For more details and information on further Solo5-based backends, refer to <a href="https://github.com/Solo5/solo5/blob/v0.6.3/docs/building.md#supported-targets">&quot;Supported targets&quot;</a> in the Solo5 documentation.
</li>
</ul>
</li>
</ul>
<h3>macOS-specific notes</h3>
<ul>
<li><strong>10.10</strong>: No special requirements beyond Homebrew or MacPorts to get OCaml and OPAM.
</li>
<li><strong>10.9 or lower</strong>: You will also need the <a href="http://tuntaposx.sourceforge.net/">tuntap</a> kernel module if you want to use the MirageOS network stack from userspace.  Note that we do not test older versions of OSX beyond 10.10.
</li>
</ul>
<p>If you are using Homebrew, run</p>
<pre><code>brew install opam
opam init
opam install mirage
</code></pre>
<h3>Linux-specific notes</h3>
<h4>Ubuntu 16.04 (Xenial) or higher</h4>
<p>This has the latest packages required in the base distribution, so just run:</p>
<pre><code>sudo apt-get update
sudo apt-get install opam
opam init
opam install mirage
</code></pre>
<h4>Ubuntu 15.10 (Vivid) or lower</h4>
<p>The version of OPAM in older Ubuntus is not high enough to run Mirage (which requires OPAM 2.0.0 or higher), so you will need to add a custom PPA for the latest packages:</p>
<pre><code>sudo add-apt-repository ppa:avsm/ppa
sudo apt-get update
sudo apt-get install ocaml ocaml-native-compilers camlp4-extra opam
opam init
opam install mirage
</code></pre>
<h4>Debian Stable (Buster) or Unstable (Sid)</h4>
<p>This has the latest packages required in the base distribution, so just run:</p>
<pre><code>sudo apt-get update
sudo apt-get install opam
opam init
opam install mirage
</code></pre>
<h3>FreeBSD-specific notes</h3>
<p>You will need ports or <code>pkg</code> set up. To install OPAM use the <code>ocaml-opam</code> port/package. FreeBSD currently packages OCaml 4.05.0, so you will need to install a newer compiler using OPAM.</p>
<h3>ARM64-specific notes</h3>
<p>For notes specific to installing and running MirageOS on ARM64 (including embedded boards such as the Raspberry Pi 3), see this <a href="/wiki/arm64">page</a>.</p>
<h2>MirageOS Package Management with OPAM</h2>
<p>We use <a href="https://opam.ocaml.org">OPAM</a> to manage OCaml compiler and library installations. It tracks library versions across upgrades and will recompile dependencies automatically if they get out of date. Please refer to OPAM <a href="https://opam.ocaml.org">documentation</a> if you want to know more, but we will cover the basics to get you started here. There is a <a href="http://opam.ocaml.org/doc/Install.html">Quick Install Guide</a> if the above instructions don't cover your operating system.</p>
<p>Note that you require <strong>OPAM 2.0.0 or greater</strong> to use with MirageOS. Some distribution packages provide earlier versions and must be updated; check with</p>
<pre><code>$ opam --version ## response should be at least 2.0.0 viz.
2.0.1
</code></pre>
<p>All the OPAM state is held in the <code>.opam</code> directory in your home directory, including compiler installations. You should never need to switch to a root user to install packages. Package listings are obtained through <code>remote</code> sources, which defaults to the contents of <a href="https://github.com/ocaml/opam-repository">github.com/ocaml/opam-repository</a>.</p>
<p>After installation, <code>opam update -u</code> refreshes the package list and recompiles packages to the latest versions.  You should run this regularly to get the latest packages.</p>
<pre><code>$ opam init
# list of your remotes, which should include opam.ocaml.org
$ opam remote
</code></pre>
<p>Next, make sure you have at least <strong>OCaml 4.08.0 or higher</strong> as your active compiler. This is generally the case on macOS, though Debian only has it in the <em>testing</em> distribution at present. But don't worry: if your compiler is out of date, just run <code>opam switch</code> to have it locally install the right version for you.</p>
<pre><code>$ ocaml -version
# if it is not 4.08.0 or higher, then run this
$ opam switch 4.08.0
</code></pre>
<p>Once you've got the right version, set up your shell environment to point to the current compiler switch.</p>
<pre><code>$ eval `opam config env`
# add the above line to your startup shell profile
</code></pre>
<p>This updates the variables in your shell to match the current OPAM installation, mainly by altering your system <code>PATH</code>. You can see the shell fragment by running <code>opam config env</code> at any time. If you add the <code>eval</code> line to your login shell (usually <code>~/.bash_profile</code>), it will automatically import the correct PATH on every subsequent login.</p>
<p>Check that the base packages are installed correctly:</p>
<pre><code>$ opam list
Installed packages for system:
base-bigarray         base  Bigarray library distributed with the OCaml compiler
base-threads          base  Threads library distributed with the OCaml compiler
base-unix             base  Unix library distributed with the OCaml compiler
[ possibly other installed packages ]
</code></pre>
<p>Finally, install the MirageOS command-line tool.</p>
<pre><code>$ opam install mirage
$ mirage --help
</code></pre>
<p>That's it. You now have everything required to start developing MirageOS unikernels that will run either as POSIX processes or as standalone unikernels. Next, why not try <a href="/wiki/hello-world">building a MirageOS <em>hello world</em></a>?</p>
|js};
      };
      {
        updated = {js|2019-10-18 19:00|js};
        author = { name = {js|derpeter|js}; uri = None; email = None };
        subject = {js|MirageOS on ARM64|js};
        permalink = {js|arm64|js};
        body =
          {js|<p>MirageOS unikernels can run on 64-bit ARM Linux systems using the <a href="https://github.com/Solo5/solo5">Solo5</a>-based <code>hvt</code> and <code>spt</code> targets.</p>
<p>At least the following boards/SoCs have been tested:</p>
<ul>
<li>Raspberry Pi 3 or newer / Broadcom BCM2837
</li>
<li>A64-OLinuXino / Allwinner A64
</li>
<li>Odroid-C2 / Amlogic S905
</li>
</ul>
<p>In all cases you will need a Linux distribution using a recent <strong>64-bit kernel</strong>. For the Raspberry Pi 3 or newer, we recommend installing Debian Buster. You can download pre-built images from <a href="https://wiki.debian.org/RaspberryPiImages">here</a>.</p>
<p><em>(Updated 2019-10-18. The following information is of historical interest, or for those who might want to cross-build a custom Linux kernel for their ARM64 board, so keeping it for now.)</em></p>
<hr />
<p>Thanks to Solo5 and hvt MirageOS can run on ARM CPUs which support the ARM virtualization extensions.
As the layer for Mirage currently only supports the 64bit architecture a 64bit CPU is required.</p>
<p>So far this has been tested on the following SOCs.</p>
<ul>
<li>Broadcom BCM2837 on Raspberry Pi 3/3+</li>
<li>Allwinner A64 on A64-OLinuXino / Pine A64</li>
<li>Amlogic S905 on Odroid-C2</li>
</ul>
<p>It should be possible on all A53 based SOCs as long as a recent Kernel is available.</p>
<p>In the following the process to build yourself a debian based firmware image for the raspberry Pi 3/3+ is described.
For other targets the process is very similar and usually only differs in the bootloader related part.</p>
<p>If you are not into builing your own image, you can try to use Arch Linux as they seem to ship KVM enabled 64bit Kernel for the Raspberry Pi.</p>
<h3>Prerequirements</h3>
<p>You will need an arm64 / aarch64 cross compiler which supports -mgeneral-regs-only which was introduced in GCC-4.8. You can use e.g. the cross compiler shipped by Ubuntu or get the tool chain of your choice for your OS. We also need debootstrap to generate a root file system and qemu which helps us setting up our user land.</p>
<pre><code class="language-bash">$ apt-get install gcc-aarch64-linux-gnu qemu-user-static debootstrap
</code></pre>
<h3>SD Card</h3>
<p>The next step is to setup the SD card. We need to create two partitions like shown below</p>
<pre><code class="language-ocaml">Device Boot Start End Sectors Size Id Type
2018-03-13-raspbian-stretch-lite.img1 8192 93802 85611 41,8M c W95 FAT32 (LBA)
2018-03-13-raspbian-stretch-lite.img2 98304 3629055 3530752 1,7G 83 Linux
</code></pre>
<p>You can change the last sector of second partition to the last sector of your SD card.
You can use fdisk or any other partition tool you fancy to perform this operations.</p>
<p>Now we need file systems. The first one needs to be fat32. The second one can be anything a Linux kernel can open. We use ext4 here.</p>
<pre><code class="language-bash">$ sudo mkfs.vfat /dev/sdc1
$ sudo mkfs.ext4 /dev/sdc2
</code></pre>
<p>You can know give the partitions names for your convenience.</p>
<pre><code class="language-bash">$ sudo fatlabel /dev/sdc1 boot
$ sudo tune2fs -L root /dev/sdc2
</code></pre>
<h3>Boot partition</h3>
<p>As the raspberry Pi needs firmware for its GPU which is than loading the bootloader to the CPU we need these two blobs.
There are also so called overlay files which allow to alter e.g. the Pinout of the GPIO header.
Check out the firmware files you will need</p>
<pre><code class="language-bash">$ git clone --depth=1 https://github.com/raspberrypi/firmware
</code></pre>
<p>Copy the content of boot to your first partition. There will be some files you don't need like dtb's for older pis and some overlays but for the sake of easy updates in the future and personal laziness lets ignore that for now.</p>
<pre><code class="language-bash">$ cp -r boot/* /&lt;boot partition mount&gt;/
</code></pre>
<p>You will need a config.txt in your boot partition. <a href="https://elinux.org/RPiconfig">https://elinux.org/RPiconfig</a>
gives an good overview on the options.
You can start with a default config.ini</p>
<pre><code class="language-bash">$ wget https://github.com/RPi-Distro/pi-gen/raw/master/stage1/00-boot-files/files/config.txt
</code></pre>
<p>You may want to add</p>
<pre><code class="language-ocaml">enable_uart=1
arm_control=0x200
kernel=Image
</code></pre>
<p>to enable the serial console (This will disable you bluetooth for now.), set the CPU to 64bit mode and choose the name of your kernel image.</p>
<p>As we only have one gigabyte of memory on this board you may also want to limit the memory assigned to the GPU.</p>
<pre><code class="language-ocaml">gpu_mem=16
</code></pre>
<p>We also need a cmdline.txt to tell the kernel some options. We can get a default by</p>
<pre><code class="language-bash">$ wget https://github.com/RPi-Distro/pi-gen/raw/master/stage1/00-boot-files/files/cmdline.txt
</code></pre>
<p>here we want to set the rootfs to</p>
<pre><code class="language-ocaml">root=/dev/mmcblk0p2 
</code></pre>
<p>and you may also want to get rid of predictable device names by adding</p>
<pre><code class="language-ocaml">net.ifnames=0
</code></pre>
<p>We will come back to the boot partition later when we have to build our kernel image.</p>
<h3>Root partition</h3>
<p>Now we need a root file system. We use qemu-debootstrap for this as it will give us very plain Debian. For this mount the second partition somewhere.
<strong>Note</strong> We here assume you SD card is present in your host system as /dev/sdc, this path may differ on your system.
E.g. on many systems it is something like /dev/mmcblk0. Make sure you mount the right partitions as this can break your system.</p>
<pre><code class="language-bash">$ mount /dev/sdc2 /mnt
</code></pre>
<p>Now you can run the qemu debootstrap wrapper
You may want to read the debootstrap manpage at this point.</p>
<pre><code class="language-bash">$ sudo qemu-debootstrap --arch arm64 stretch /mnt
</code></pre>
<p>This will install a minimal Debian stretch root file system to your SD card.</p>
<h3>Kernel</h3>
<p>As the kernel that we got from the firmware repo is a rusty old 4.9 with 32bit and no virtualization we need to build our own.
First we need to check out the kernel source. You can probably also get away with using a vanilla mainline kernel, but as there is a well maintained raspberry pi kernel we will use that to not miss any pi related patches.</p>
<pre><code class="language-bash">$ git clone --depth=1 https://github.com/raspberrypi/linux.git -b rpi-4.16.y
</code></pre>
<p><strong>Note</strong> We check out the branch 4.16 which my be outdated at the time you read this. So you may want to use a newer one.</p>
<p>We use</p>
<pre><code class="language-bash">$ CROSS_COMPILE=aarch64-linux-gnu- ARCH=arm64 make bcmrpi3_defconfig
</code></pre>
<p>to start with an kernel config fitting to the raspi.</p>
<p>Now we need to enable virtualization.</p>
<pre><code class="language-bash">$ CROSS_COMPILE=aarch64-linux-gnu- ARCH=arm64 make menuconfig
-&gt; Virtualization -&gt; 
        -&gt; Kernel-based Virtual Machine (KVM) support *
        -&gt; Host kernel accelerator for virtio net M
</code></pre>
<p>and we are good to go to build our kernel.
<strong>Note</strong> You may want adjust the -j4 to the number of CPU cores you want to use for this.</p>
<pre><code class="language-bash">$ CROSS_COMPILE=aarch64-linux-gnu- ARCH=arm64 make -j4 Image dtbs modules
</code></pre>
<p>We now need to copy the kernel image and the dtbs file to the SD card.
<strong>Note</strong> We copy the dtb for an raspberrypi 3+, so if you use a different pi you may want to copy a different dtb file.</p>
<pre><code class="language-bash">$ cp arch/arm64/boot/Image /&lt;boot partition mount&gt;/
$ cp arch/arm64/boot/dts/broadcom/bcm2710-rpi-3-b-plus.dtb /&lt;boot partition mount&gt;/
</code></pre>
<p>Now we need to copy the modules to the root file system.</p>
<pre><code class="language-bash">$ sudo CROSS_COMPILE=aarch64-linux-gnu- ARCH=arm64 INSTALL_MOD_PATH=/mnt make modules_install
</code></pre>
<p>As debootstrap gives us an unconfigured Debian you may want to edit</p>
<p>/etc/network/interfaces</p>
<pre><code class="language-ocaml">auto eth0
iface eth0 inet dhcp
</code></pre>
<p>/etc/fstab</p>
<pre><code class="language-ocaml">UUID=31c566e0-0f1d-475d-9908-4740c8ca3653 / ext4 errors=remount-ro 0 1
</code></pre>
<p>You can get the uuid for your root partition by running</p>
<pre><code class="language-bash">$ blkid 
</code></pre>
<p>And you may also want to set a host name in /etc/hostname and /etc/hosts.
Finally you want to set a root password</p>
<pre><code class="language-bash">$ sudo chroot /mnt
$ passwd 
$ exit
</code></pre>
<p>You should now have an bootable image. You can either hook up a serial UART cable to the pi or connect it to an HDMI screen.
You can now e.g. follow the mirage <a href="https://mirage.io/wiki/hello-world">hello world</a> to setup your unikernel.</p>
|js};
      };
      {
        updated = {js|2019-10-18 15:00|js};
        author =
          {
            name = {js|Richard Mortier|js};
            uri = Some {js|http://mort.io/|js};
            email = Some {js|mort@cantab.net|js};
          };
        subject = {js|Hello MirageOS World|js};
        permalink = {js|hello-world|js};
        body =
          {js|<p>First, make sure you have followed the <a href="/wiki/install">installation instructions</a>
to get a working MirageOS installation. The examples below are in
the <a href="http://github.com/mirage/mirage-skeleton">mirage-skeleton</a> repository.
Begin by cloning and changing directory to it:</p>
<pre><code class="language-bash">$ git clone git://github.com/mirage/mirage-skeleton.git
$ cd mirage-skeleton
</code></pre>
<p>The <code>mirage-skeleton</code> repository classifies its examples into three groups.
This document refers to unikernels in the <code>tutorial</code> directory.</p>
<p><strong>Note</strong>: Before we begin, if you aren't familiar with the Lwt library (and the
<code>&gt;&gt;=</code> operator it provides), you may want to read at least the start of
the <a href="/wiki/tutorial-lwt">Lwt tutorial</a> first.</p>
<p><strong>Additional note</strong>: Throughout the tutorial, we'll use <code>mirage configure -t unix</code>
to demonstrate building MirageOS applications.  If you're using a macOS
machine, you should use <code>mirage configure -t macosx</code> instead.</p>
<h3>Step 0: Doing Nothing!</h3>
<p>Before we try and do anything complicated, let's build a unikernel that starts
and then exits, without doing anything else. The code for this is, as you might
hope, fairly short. First, the unikernel itself:</p>
<pre><code class="language-ocaml">$ cat tutorial/noop/unikernel.ml
let start =
  Lwt.return_unit
</code></pre>
<p>So this is a unikernel whose entry point (<code>start</code>) does nothing other than
return an <code>Lwt</code> thread that will evaluate to <code>unit</code>. Easy.</p>
<p>Before we can build even our <code>noop</code> unikernel, we must define its configuration.
That is, we need to tell Mirage what OCaml module contains the <code>start</code> entry
point. We do this by writing a <code>config.ml</code> file that sits next to our
<code>unikernel.ml</code> file:</p>
<pre><code class="language-ocaml">$ cat tutorial/noop/config.ml
open Mirage

let main =
  main &quot;Unikernel&quot; job

let () =
  register &quot;noop&quot; [main]
</code></pre>
<p>There's a little more going on here than in <code>unikernel.ml</code>. First we open the
<code>Mirage</code> module to save on typing. Next, we define a value <code>main</code>.  This name is
only a convention, and you should feel free to change it if you wish.
<code>main</code> calls the <code>Mirage.main</code> function, passing two parameters.
The first is a string declaring the module name that contains
our entry point — in this case, standard OCaml compilation behaviour means that
the <code>unikernel.ml</code> file produces a module named <code>Unikernel</code>. Again, there's
nothing special about this name, and if you want to use something else here,
simply rename <code>unikernel.ml</code> accordingly.</p>
<p>The second parameter, <code>job</code>, is a bit more interesting. This declares the type
of our unikernel in terms of the devices (that is, things such as network
interfaces, network stacks, filesystems and so on) it requires to operate. As
this is a unikernel that does nothing, it needs no devices and so is simply a
<code>job</code>.</p>
<p>Finally, we declare the entry point to OCaml in the usual way (<code>let () = ...</code>),
<code>register</code>ing our unikernel entry point (<code>main</code>) with a name (<code>&quot;noop&quot;</code> in this
case) to be used when we build our unikernel.</p>
<p>Building our unikernel is then simply a matter of:</p>
<ol>
<li>Evaluating its configuration:
</li>
</ol>
<pre><code class="language-bash">$ cd tutorial/noop
/Users/mort/research/projects/mirage/src/mirage-skeleton/tutorial/noop
$ mirage configure -t unix
</code></pre>
<ol start="2">
<li>Installating dependencies:
</li>
</ol>
<ul>
<li><code>opam install</code> for installing the build tools in the opam switch.
</li>
<li><code>opam-monorepo lock</code> resolves the unikernel dependencies a generates a
<em>lockfile</em>.
</li>
<li><code>lockfile depext</code> installs the external dependencies of the unikernel
dependencies (another set of potential build tools).
</li>
<li><code>opam-monorepo pull</code> locally fetch unikernel dependencies.
</li>
</ul>
<p>NOTE: while performing the <em>lock</em> step, an additional repository
(https://github.com/mirage/opam-overlays.git) is added in your opam switch.
This repository contains packages that have been changed to use the <em>dune</em> build
system. The <code>--extra-repo</code> argument in <code>mirage configure</code> changes the additional
repository to use. <code>--no-extra-repo</code> can be used to disable the extra repository,
but the <em>lock</em> step might fail because of dependencies that are not using the
<em>dune</em> build system.</p>
<pre><code class="language-json">$ make depend
 ↳ opam depexts
 ↳ opam install global dependencies
Nothing to do.
using overlay repository mirage-tmp: https://github.com/mirage/opam-overlays.git
[mirage-tmp] no changes from git+https://github.com/mirage/opam-overlays.git
[NOTE] Repository mirage-tmp has been added to the selections of switch
       mirage-4.12.0 only.
       Run `opam repository add mirage-tmp
       --all-switches|--set-default' to use it in all existing
       switches, or in newly created switches, respectively.

 ↳ opam-monorepo lock
==&gt; Using 1 locally scanned package as the root.
==&gt; Found 55 opam dependencies for the root package.
==&gt; Querying opam database for their metadata and Dune compatibility.
==&gt; Calculating exact pins for each of them.
==&gt; Wrote lockfile with 39 entries to mirage/noop-unix.opam.locked. You can now run opam monorepo pull to fetch their sources.
 ↳ lockfile depexts
removing overlay repository mirage-tmp
Repositories removed from the selections of switch mirage-4.12.0. Use '--all' to forget about them altogether.
 ↳ opam-monorepo pull
==&gt; Pulling lockfile mirage/noop-unix.opam.locked          
Successfully pulled 39/39 repositories
</code></pre>
<p>...and compiling:</p>
<pre><code class="language-bash">$ make
</code></pre>
<p>As we configured for Unix (the <code>-t unix</code> argument to the <code>mirage configure</code>
command), the result is a standard Unix ELF binary that can simply be executed:</p>
<pre><code class="language-bash">$ ls -l dist/noop
-rwxr-xr-x 1 lucas lucas 5280056 Sep 27 11:52 noop
$ dist/noop
$ echo $?
0
</code></pre>
<p>Congratulations! You've just built and run your very first unikernel!</p>
<h4>Aside: Doing Nothing with Functors!</h4>
<p>Functors are one of those OCaml things that can seem a bit intimidating at first
(traditionally, &quot;monads&quot; get the same sort of reaction). However, as they're
used fairly widely throughout Mirage, a very brief introduction to the commonest
way we use them is needed. For a better introduction as to how to actually make
use of them, what they are, and so on
see
<a href="https://realworldocaml.org/v1/en/html/functors.html">Real World OCaml, Ch.9</a>
(and also
<a href="https://realworldocaml.org/v1/en/html/first-class-modules.html">Ch.10, First-Class Modules</a>).</p>
<p>In short, in Mirage, they're used as a way to abstract over the target
environment for the unikernel. Functors are, roughly, functions from modules to
modules, and they allow us to pass modules into a unikernel so that the code
inside a unikernel can interact with its environment (read files, send packets,
etc) without needing to care whether it's been built to target Unix, Xen, KVM, or
something else entirely. The modules that are passed into the unikernel in this
way are required to conform to type signatures that are specified when the
unikernel <code>job</code> value is created in the <code>config.ml</code> file.</p>
<p>We'll see several examples of this below but, for now, we need to wrap up our
<code>noop</code> unikernel in a module inside the <code>Unikernel</code> module so that we can use it
as a functor. This is actually quite straightforward — we simply wrap the
<code>start</code> function in <code>unikernel.ml</code> inside some module. For example,</p>
<pre><code class="language-ocaml">$ cat tutorial/noop-functor/unikernel.ml
module Main = struct

  let start =
    Lwt.return_unit

end
</code></pre>
<p>The use of the name <code>Main</code> is purely convention, and you should feel free to
replace it with completely different if you wish!</p>
<p>The only other change is to the corresponding invocation in <code>config.ml</code>:</p>
<pre><code class="language-ocaml">$ cat tutorial/noop-functor/config.ml
open Mirage

let main =
  main &quot;Unikernel.Main&quot; job

let () =
  register &quot;noop&quot; [main]
</code></pre>
<p>Note that the string passed to <code>main</code> is now <code>&quot;Unikernel.Main&quot;</code> as we must
refer to the <code>Main</code> module inside the <code>Unikernel</code> module. Everything else stays
the same.  Go ahead and try that out by building the unikernel inside
<code>noop-functor</code>.</p>
<p>...and now, onwards to unikernels that actually <strong>do</strong> something!</p>
<h3>Step 1: Hello World!</h3>
<p>As a first step, let's build and run the MirageOS &quot;Hello World&quot; unikernel.
This will print a log message with the word <code>hello</code> 4 times before terminating:</p>
<pre><code>2017-02-08 09:54:44 -01:00: INF [application] hello
2017-02-08 09:54:45 -01:00: INF [application] hello
2017-02-08 09:54:46 -01:00: INF [application] hello
2017-02-08 09:54:47 -01:00: INF [application] hello
</code></pre>
<p>First, let's look at the code:</p>
<pre><code class="language-ocaml">$ cat hello/unikernel.ml
open Lwt.Infix

module Hello (Time : Mirage_time.S) = struct

  let start _time =

    let rec loop = function
      | 0 -&gt; Lwt.return_unit
      | n -&gt;
        Logs.info (fun f -&gt; f &quot;hello&quot;);
        Time.sleep_ns (Duration.of_sec 1) &gt;&gt;= fun () -&gt;
        loop (n-1)
    in
    loop 4

end
</code></pre>
<p>To veteran OCaml programmers among you, this might look a little odd: We have a
main <code>Hello</code> module parameterised by a module (<code>Time</code>, of type <code>Mirage_time.S</code>) that contains a method <code>start</code> taking an ignored parameter <code>_time</code> (an instance of a <code>time</code>).  This is the basic structure required to make this a MirageOS unikernel
rather than a standard OCaml POSIX application.</p>
<p>The module type for our <code>Time</code> module, <code>Mirage_time.S</code>, is defined in an
external package <a href="https://github.com/mirage/mirage-time">mirage-time</a>.  The name <code>S</code> for &quot;the module type of things like this&quot; is a common OCaml convention (comparable to naming the most-used type in a module <code>t</code>).  There are many packages defining module types for use in Mirage.</p>
<p>The concrete implementation of <code>Time</code> will be supplied at
compile time, depending on the target that you are compiling for. This
configuration is stored in <code>config.ml</code>, so let's take a look:</p>
<pre><code class="language-ocaml">$ cat tutorial/hello/config.ml

open Mirage

let main =
  main
    ~packages:[package &quot;duration&quot;]
    &quot;Unikernel.Hello&quot; (time @-&gt; job)

let () =
  register &quot;hello&quot; [main $ default_time]
</code></pre>
<p>The configuration file is a normal OCaml module that calls <code>register</code> to create
one or more jobs, each of which represent a process (with a start/stop
lifecycle). Each job most likely depends on some device drivers; all the
available device drivers are defined in the <code>Mirage</code> module
(see <a href="http://mirage.github.io/mirage/">the Mirage module documentation</a>).</p>
<p>In this case, the <code>main</code> variable declares that the entry point of the process
is the <code>Hello</code> module from the file <code>unikernel.ml</code>. The <code>@-&gt;</code> combinator is used
to add a device driver to the list of functor arguments in the job definition
(see <code>unikernel.ml</code>), and the final value of using this combinator should always
be a <code>job</code> if you intend to register it.</p>
<p>The <code>foreign</code> function also takes some additional arguments: <code>~keys</code>, the list of
configuration keys we want to allow the user to specify at configuration or build time, and
<code>packages</code>, a list of additional <code>opam</code> packages that should be included in the list of
build dependencies for the project.  We'll talk more about configuration keys in the next example.</p>
<p>Notice that we refer to the module name as a string (<code>&quot;Unikernel.Hello&quot;</code>) when
calling <code>main</code>, instead of directly as
an OCaml value. The <code>mirage</code> command-line tool evaluates this configuration file
at build time and outputs a <code>main.ml</code> that has the concrete values filled in for
you, with the exact modules varying by which backend you selected (e.g. Unix or
Xen).</p>
<p>MirageOS mirrors the unikernel model on Unix as far as possible: your application is
built as a unikernel which needs to be instantiated and run whether on Unix or
on a hypervisor backend like Xen or KVM. When your unikernel is run, it starts
much like a conventional OS does when run as a virtual machine, and so it must
be passed references to devices such as the console, network interfaces and
block devices on startup.</p>
<p>In this case, this simple <code>hello world</code> example requires some notion of time,
so we register a single <code>Job</code> consisting of the <code>Unikernel.Hello</code> module
(and, implicitly its <code>start</code> function) and pass it references to a
timer.</p>
<h4>Building a Unix binary</h4>
<p>We invoke all this by configuring, building and finally running the resulting
unikernel under Unix first.</p>
<pre><code class="language-bash">$ cd tutorial/hello
$ mirage configure -t unix
</code></pre>
<p><code>mirage configure</code> generates a <code>Makefile</code> with all the build rules included from
evaluating the configuration file, a <code>main.ml</code> that represents the entry point
of your unikernel, and an <code>opam</code> file with a list of the packages necessary to
build the unikernel.</p>
<pre><code class="language-bash">$ make depend
</code></pre>
<p>In order to automatically install the dependencies discovered by <code>mirage configure</code> in your current <code>opam</code> switch, execute <code>make depend</code>.</p>
<pre><code class="language-bash">$ make
</code></pre>
<p>This builds a Unix binary called <code>hello</code> that contains the simple console
application, it is available in the <code>dist</code> folder. Note that <code>make</code> simply calls
<code>mirage build</code> which itself turns into a simple <code>dune build</code> command. If you are
familiar with <code>dune</code> it is possible to inspect the build rules for the unikernel.</p>
<p>Finally to run your application, simply run it
directly — as it is a standard Unix binary — and observe the exciting log messages that our loop is generating:</p>
<pre><code class="language-bash">$ ./hello
</code></pre>
<h4>Building for Another Backend</h4>
<p><strong>Note</strong>: The following sections of this tutorial use the <a href="https://github.com/Solo5/solo5/tree/v0.7.0">Solo5</a>-based <code>hvt</code> backend as an example. This backend is supported on Linux, FreeBSD, and OpenBSD systems with hardware virtualization. Please see the Solo5 documentation for the support <a href="https://github.com/Solo5/solo5/blob/v0.7.0/docs/building.md#supported-targets">status</a> of further backends such as <code>spt</code> (for deployment on Linux using a strict seccomp sandbox), <code>virtio</code> (for deployment on e.g. Google Compute Engine) and <code>muen</code> (for deployment on the <a href="https://muen.sk">Muen Separation Kernel</a>).</p>
<p>To build a Solo5-based unikernel that will run on a host system with hardware virtualization, re-run <code>mirage configure</code> and ask for the <code>hvt</code> target instead of <code>unix</code>.</p>
<pre><code class="language-bash">$ mirage configure -t hvt
$ make depend
$ make
</code></pre>
<p><em>Everything</em> else remains the same! The set of dependencies required, the <code>main.ml</code>, and the <code>Makefile</code> differ significantly, but since the source code of your application was
parameterised over the <code>Time</code> type, it doesn't matter — you do not need to
make any changes for your code to run when linked against the Solo5 console driver
instead of Unix.</p>
<p>When you build the <code>hvt</code> version, you'll see a new artifact which is the
unikernel: a file called <code>hello.hvt</code>.  A <code>solo5-hvt</code> binary will be installed by OPAM on your <code>$PATH</code>. This binary is a <em>tender</em>, responsible for loading your unikernel, attaching to host system devices and running it. To try running <code>hello.hvt</code>, pass it as an argument to <code>solo5-hvt</code>:</p>
<pre><code class="language-bash">$ solo5-hvt dist/hello.hvt
            |      ___|
  __|  _ \\  |  _ \\ __ \\
\\__ \\ (   | | (   |  ) |
____/\\___/ _|\\___/____/
Solo5: Memory map: 512 MB addressable:
Solo5:     unused @ (0x0 - 0xfffff)
Solo5:       text @ (0x100000 - 0x1e8fff)
Solo5:     rodata @ (0x1e9000 - 0x220fff)
Solo5:       data @ (0x221000 - 0x2d0fff)
Solo5:       heap &gt;= 0x2d1000 &lt; stack &lt; 0x20000000
2018-06-21 12:16:28 -00:00: INF [application] hello
2018-06-21 12:16:29 -00:00: INF [application] hello
2018-06-21 12:16:30 -00:00: INF [application] hello
2018-06-21 12:16:31 -00:00: INF [application] hello
Solo5: solo5_exit(0) called
</code></pre>
<p>We get some additional output from the initialization of the unikernel and its successful boot, then we see our expected output, and Solo5's report of the application's successful completion.</p>
<h4>Configuration Keys</h4>
<p>It's very common to pass additional runtime information to a program via command-line options or arguments.  But a unikernel doesn't have access to a command line, so how can we pass it runtime information?</p>
<p>Mirage provides a nice abstraction for this in the form of configuration keys.  The <code>Mirage</code> module provides a module <code>Key</code>, which contains functions for creating and using configuration keys.  For an example, let's have a look at <code>hello-key</code>:</p>
<pre><code>$ cd tutorial/hello-key
$ cat config.ml
open Mirage

let hello =
  let doc = Key.Arg.info ~doc:&quot;How to say hello.&quot; [&quot;hello&quot;] in
  Key.(create &quot;hello&quot; Arg.(opt string &quot;Hello World!&quot; doc))

let main =
  main
    ~keys:[key hello]
    ~packages:[package &quot;duration&quot;]
    &quot;Unikernel.Hello&quot; (time @-&gt; job)

let () =
  register &quot;hello&quot; [main $ default_time]
</code></pre>
<p>We create a <code>key</code> with <code>Key.create</code> which is an optional bit of configuration.  It will default to &quot;Hello World!&quot; if unspecified.  This particular key happens to be of type <code>string</code>, so no conversion will be required, but it's possible to ask for more exotic types in the call to <code>Arg</code>.  See <a href="http://mirage.github.io/functoria/functoria/Functoria_key/Arg/index.html">the Functoria Key.Arg module documentation</a> for more details.</p>
<p>Once we've created our configuration key, we specify that we'd like it available in the unikernel by passing it to <code>main</code> in the <code>keys</code> parameter.</p>
<p>We can then read the value corresponding to configuration key using the generated function <code>Key_gen.hello</code> as shown below.</p>
<pre><code>$ cat unikernel.ml
open Lwt.Infix

module Hello (Time : Mirage_time_lwt.S) = struct

  let start _time =

    let hello = Key_gen.hello () in

    let rec loop = function
      | 0 -&gt; Lwt.return_unit
      | n -&gt;
        Logs.info (fun f -&gt; f &quot;%s&quot; hello);
        Time.sleep_ns (Duration.of_sec 1) &gt;&gt;= fun () -&gt;
        loop (n-1)
    in
    loop 4

end
</code></pre>
<p>Let's configure the example for Unix and build it:</p>
<pre><code class="language-bash">$ mirage configure -t unix
$ make depend
$ make
</code></pre>
<p>When the target is Unix, Mirage will use an implementation for configuration keys that looks at the contents of <code>OS.Env.argv</code>. In other words, it looks directly at the command line that was used to invoke the program.  If we call <code>hello</code> with no arguments, the default value is used:</p>
<pre><code>$ dist/hello
2017-02-08 18:18:23 -03:00: INF [application] Hello World!
2017-02-08 18:18:24 -03:00: INF [application] Hello World!
2017-02-08 18:18:25 -03:00: INF [application] Hello World!
2017-02-08 18:18:26 -03:00: INF [application] Hello World!
</code></pre>
<p>but we can ask for something else:</p>
<pre><code>$ dist/hello --hello=&quot;Bonjour!&quot;
2017-02-08 18:20:46 +09:00: INF [application] Bonjour!
2017-02-08 18:20:47 +09:00: INF [application] Bonjour!
2017-02-08 18:20:48 +09:00: INF [application] Bonjour!
2017-02-08 18:20:49 +09:00: INF [application] Bonjour!
</code></pre>
<p>When the target is Unix, it's also possible to get useful hints by calling the generated program with <code>--help</code>.</p>
<p>Many configuration keys can be specified either at configuration time or at run time.  <code>mirage configure</code> will allow us to change the default value for <code>hello</code>, while retaining the ability to override it at runtime:</p>
<pre><code>$ mirage configure -t unix --hello=&quot;Hola!&quot;
$ make depend
$ make
$ dist/hello
2017-02-08 18:30:30 +06:00: INF [application] Hola!
2017-02-08 18:30:31 +06:00: INF [application] Hola!
2017-02-08 18:30:32 +06:00: INF [application] Hola!
2017-02-08 18:30:33 +06:00: INF [application] Hola!
$ dist/hello --hello=&quot;Hi!&quot;
2017-02-08 18:30:54 +06:00: INF [application] Hi!
2017-02-08 18:30:55 +06:00: INF [application] Hi!
2017-02-08 18:30:56 +06:00: INF [application] Hi!
2017-02-08 18:30:57 +06:00: INF [application] Hi!
</code></pre>
<p>When configured for non-Unix backends, other mechanisms are used to pass the runtime information to the unikernel.  <code>solo5-hvt</code>, which we used to run <code>hello.hvt</code> in the non-keyed example, will pass keys specified on the command line to the unikernel when invoked:</p>
<pre><code>$ cd tutorial/hello-key
$ mirage configure -t hvt
$ make depend
$ make
$ solo5-hvt -- dist/hello.hvt --hello=&quot;Hola!&quot;
            |      ___|
  __|  _ \\  |  _ \\ __ \\
\\__ \\ (   | | (   |  ) |
____/\\___/ _|\\___/____/
Solo5: Memory map: 512 MB addressable:
Solo5:     unused @ (0x0 - 0xfffff)
Solo5:       text @ (0x100000 - 0x1e8fff)
Solo5:     rodata @ (0x1e9000 - 0x220fff)
Solo5:       data @ (0x221000 - 0x2d1fff)
Solo5:       heap &gt;= 0x2d2000 &lt; stack &lt; 0x20000000
2018-06-21 12:18:03 -00:00: INF [application] Hola!
2018-06-21 12:18:04 -00:00: INF [application] Hola!
2018-06-21 12:18:05 -00:00: INF [application] Hola!
2018-06-21 12:18:06 -00:00: INF [application] Hola!
Solo5: solo5_exit(0) called
</code></pre>
<h3>Step 2: Getting a block device</h3>
<p>Most useful unikernels will need to obtain data from the outside world, so we'll
explain this subsystem next.</p>
<h4>Sector-addressible block devices</h4>
<p>The <a href="https://github.com/mirage/mirage-skeleton/tree/master/device-usage/block">device-usage/block/</a>
directory in <code>mirage-skeleton</code> contains an example of attaching a raw block
device to your unikernel.
The <a href="https://mirage.github.io/mirage-block">Mirage_block</a>
interface signature contains the operations that are possible on a block device:
primarily reading and writing aligned buffers to a 64-bit offset within the
device.</p>
<p>On Unix, the development workflow to handle block devices is by mapping them
onto local files. The <code>config.ml</code> for the block example contains some logic for automatically creating a disk image file (and removing it when <code>mirage clean</code> is called), in addition to a more familiar-looking set of calls to <code>foreign</code> and <code>register</code>:</p>
<pre><code class="language-ocaml">open Mirage

type shellconfig = ShellConfig
let shellconfig = typ ShellConfig

let config_shell = impl
  ~dune:(fun _i -&gt; [Dune.stanza {|
(rule (targets disk.img)
 (action (run dd if=/dev/zero of=disk.img count=100000))
)|}])
  ~install:(fun _ -&gt; Functoria.Install.v ~etc:[Fpath.v &quot;disk.img&quot;] ())
  &quot;shell_config&quot;
  shellconfig

let main =
  let packages = [ package &quot;io-page&quot;; package &quot;duration&quot;; package ~build:true &quot;bos&quot;; package ~build:true &quot;fpath&quot; ] in
  main
    ~packages
    ~deps:[dep config_shell] &quot;Unikernel.Main&quot; (time @-&gt; block @-&gt; job)

let img = Key.(if_impl is_solo5 (block_of_file &quot;storage&quot;) (block_of_file &quot;disk.img&quot;))

let () =
  register &quot;block_test&quot; [main $ default_time $ img]
</code></pre>
<p>The <code>main</code> binding looks much like the earlier <code>hello</code> example, except for the
addition of a <code>block</code> device in the list. When we register the job, we supply a
block device from a local file via <a href="https://docs.mirage.io/mirage/Mirage/#val-block_of_file"><code>block_of_file</code></a>.</p>
<p>Using <code>deps</code> we also supply a <em>custom dependency</em> <code>config_shell</code> in charge of
building the <code>disk.img</code> image. This is done using <em>dune</em> rules.</p>
<br />
<div class="panel callout">
  <i class="fa fa-info fa-3x pull-left"> </i>
  <p>
    As an aside, if you have your editor configured with OCaml mode, you should
    be able to see the inferred types for some of the variables in the
    configuration file. The <code>@-></code> and <code>$</code> combinators are
    designed such that any mismatches in the declared device driver types and
    the concrete registered implementations will result in a type error at
    configuration time.
  </p>
</div>
<p>Build this on Unix in the same way as the previous examples:</p>
<pre><code class="language-bash">$ cd device-usage/block
$ mirage configure -t unix
$ make depend
$ make
$ ./dist/block_test
</code></pre>
<p><code>block_test</code> will write a series
of patterns to the block device and read them back to check that they are the
same (the logic for this is in <code>unikernel.ml</code> within the <code>Block_test</code> module).</p>
<p>We can build this example for another backend too:</p>
<pre><code class="language-bash">$ mirage configure -t hvt
$ make depend
$ make
</code></pre>
<p>Now we just need to boot the unikernel with <code>solo5-hvt</code> as before. We should see
the same output after the VM boot preamble, but now MirageOS is linked against the
Solo5 <a href="https://github.com/mirage/mirage-block-solo5">block device driver</a> and is
mapping the unikernel's block requests directly through to it, rather than
relying on the host OS (the Linux or FreeBSD kernel).</p>
<p>If we tell <code>solo5-hvt</code> where the disk image is, it will provide that disk image to the unikernel:</p>
<pre><code class="language-bash">$ solo5-hvt --block:storage=disk.img dist/block_test.hvt
            |      ___|
  __|  _ \\  |  _ \\ __ \\
\\__ \\ (   | | (   |  ) |
____/\\___/ _|\\___/____/
Solo5: Memory map: 512 MB addressable:
Solo5:     unused @ (0x0 - 0xfffff)
Solo5:       text @ (0x100000 - 0x1eefff)
Solo5:     rodata @ (0x1ef000 - 0x228fff)
Solo5:       data @ (0x229000 - 0x2dffff)
Solo5:       heap &gt;= 0x2e0000 &lt; stack &lt; 0x20000000
2018-06-21 12:21:11 -00:00: INF [block] sectors = 100000
read_write=true
sector_size=512

2018-06-21 12:21:11 -00:00: ERR [block] Expecting error output from the following operation...
2018-06-21 12:21:11 -00:00: ERR [block] Expecting error output from the following operation...
2018-06-21 12:21:11 -00:00: ERR [block] Expecting error output from the following operation...
2018-06-21 12:21:11 -00:00: ERR [block] Expecting error output from the following operation...
2018-06-21 12:21:11 -00:00: INF [block] Test sequence finished

2018-06-21 12:21:11 -00:00: INF [block] Total tests started: 10

2018-06-21 12:21:11 -00:00: INF [block] Total tests passed:  10

2018-06-21 12:21:11 -00:00: INF [block] Total tests failed:  0

Solo5: solo5_exit(0) called
</code></pre>
<h3>Step 3: Key/value stores</h3>
<p>The earlier block device example shows how very low-level access can work. Now
let's move up to a more familiar abstraction: a key/value store that can
retrieve buffers from string keys. This is essential for many common uses such
as retrieving configuration data or website HTML and images.</p>
<p>The
<a href="https://github.com/mirage/mirage-skeleton/tree/master/device-usage/kv_ro">device-usage/kv_ro</a> directory
in <code>mirage-skeleton</code> contains a simple key/value store example. The
subdirectory <code>t/</code> contains a few files, one of which the unikernel
will compare against a known constant.</p>
<p>The <code>config.ml</code> might look familiar after the earlier block and console
examples:</p>
<pre><code class="language-ocaml">open Mirage

let disk = generic_kv_ro &quot;t&quot;

let main =
  main
    &quot;Unikernel.Main&quot; (kv_ro @-&gt; job)

let () =
  register &quot;kv_ro&quot; [main $ disk]
</code></pre>
<p>We construct the <code>kv_ro</code> device <code>disk</code> by using the <code>generic_kv_ro</code>
function. This takes a single directory as its argument, and will do its best
to provide the content of that directory to the unikernel by whatever means
make sense given the target provided at configuration time. The best choice might be an
implementation that calls functions from OCaml's <code>Unix</code> module (referred to as
<code>direct</code> by the <code>mirage</code> tool), or perhaps a function
that transforms an entire directory into a static ML file that can expose
the file contents directly from memory (called <code>crunch</code>). <code>crunch</code> removes the need to have
an external block device entirely and is very convenient indeed for small files.</p>
<p>Using <code>generic_kv_ro</code> in your <code>config.ml</code> causes Mirage to automatically create a
configuration key, <code>kv_ro</code>, which you can use to request a specific implementation
of the key-value store's implementation.  To see documentation, try:</p>
<pre><code class="language-bash">$ cd device-usage/kv_ro
$ mirage help configure
</code></pre>
<p>Under the &quot;UNIKERNEL PARAMETERS&quot; section, you should see:</p>
<pre><code class="language-bash">       --kv_ro=KV_RO (absent=crunch)
           Use a fat, archive, crunch or direct pass-through implementation
           for the unikernel.
</code></pre>
<p>More documentation is available at <a href="http://mirage.github.io/mirage/mirage/Mirage/index.html#val-generic_kv_ro">the <code>Mirage</code> module documentation for generic_kv_ro</a>.</p>
<p>Let's try a few different kinds of key-value implementations.  First, we'll build a Unix version.  If we don't specify which kind of <code>kv_ro</code> we want, we'll get a <code>crunch</code> implementation, the contents of which we can see at <code>_build/default/static_t.ml</code>, the file being generated by <code>dune</code> rules described in <code>dune.build</code>:</p>
<pre><code>$ cd device-usage/kv_ro
$ mirage configure -t unix
$ make depend
$ make
$ less _build/default/static_t.ml # the generated filesystem
$ dist/kv_ro
</code></pre>
<p>We can use the <code>direct</code> implementation with the Unix target as well:</p>
<pre><code>$ cd device-usage/kv_ro
$ mirage configure -t unix --kv_ro=direct
$ make depend
$ make
$ dist/kv_ro
</code></pre>
<p>You may have noticed that, unlike with our <code>hello_key</code> example, the <code>kv_ro</code> key
can't be specified at runtime — it's only understood as an argument to <code>mirage configure</code>.  This is because the <code>kv_ro</code> implementation we choose influences the set of dependencies that are assembled and baked into the final product.  If we choose <code>direct</code>, we'll get a different set of software than if we choose <code>crunch</code>.  In either case, no code that isn't required will be included in the final product.</p>
<p>You should now be seeing the power of the MirageOS configuration tool: We have
built several applications that use fairly complex concepts such as filesystems
and block devices that are independent of the implementations (by virtue of our
application logic being a functor), and then are able to assemble several
combinations of unikernels via relatively simple configuration files and options
passed at compile time and runtime.</p>
<h3>Step 4: Networking</h3>
<p>There are several ways that we might want to configure our network for a Mirage
application:</p>
<ul>
<li>On Unix, it's convenient to use the standard kernel socket API for developing
higher level protocols (such
as <a href="http://github.com/mirage/ocaml-cohttp">HTTP</a>). These run over TCP or UDP
and so sockets work just fine.
</li>
<li>When we want finer control over the network stack, or simply to test the fully-OCaml
network implementation , we can use a userspace device facility such as the
common Unix <a href="http://en.wikipedia.org/wiki/TUN/TAP">tuntap</a> to parse Ethernet
frames from userspace. This requires additional configuration to assign IP
addresses, and possibly configure a network bridge to let the unikernel talk
to the outside world.
</li>
<li>Once the unikernel works under Unix with the
direct <a href="https://github.com/mirage/mirage-tcpip">OCaml TCP/IP stack</a>,
recompiling it for a unikernel target like <code>xen</code>, <code>hvt</code>, or <code>virtio</code> shouldn't
result in a change in behavior.
</li>
</ul>
<p>All of this can be manipulated via command-line arguments or environment variables,
just as we configured the key-value store in the previous example.  The example in
the <code>device-usage/network</code> directory of <code>mirage-skeleton</code> is illustrative:</p>
<pre><code class="language-ocaml">open Mirage

let port =
  let doc = Key.Arg.info ~doc:&quot;The TCP port on which to listen for incoming connections.&quot; [&quot;port&quot;] in
  Key.(create &quot;port&quot; Arg.(opt int 8080 doc))

let main = main ~keys:[Key.abstract port] &quot;Unikernel.Main&quot; (stackv4 @-&gt; job)

let stack = generic_stackv4 default_network

let () =
  register &quot;network&quot; [
    main $ stack
  ]
</code></pre>
<p>We have a custom configuration key defining which TCP port to listen for connections on.
The network device is derived from <code>default_network</code>, a function provided by Mirage which will choose a reasonable default based on the target the user chooses to pass to <code>mirage configure</code> - just like the reasonable default provided by <code>generic_kv_ro</code> in the previous example.</p>
<p><code>generic_stackv4</code> attempts to build a sensible network stack on top of the physical interface given by <code>default_network</code>.  There are quite a few configuration keys exposed when <code>generic_stackv4</code> is given related to networking configuration. For a full list, try <code>mirage help configure</code> in the <code>device-usage/network</code> directory.</p>
<h4>Unix / Socket networking</h4>
<p>Let's get the network stack compiling using the standard Unix sockets APIs
first.</p>
<pre><code class="language-bash">$ cd device-usage/network
$ mirage configure -t unix --net socket
$ make depend
$ make
$ dist/network
</code></pre>
<p>This Unix application is now listening on TCP port 8080,
and will print to the console information about data received.
Let's try talking to it using
the commonly available <em>netcat</em> <code>nc(1)</code> utility. From a different console
execute:</p>
<pre><code>$ echo -n hello tcp world | nc -nw1 127.0.0.1 8080
</code></pre>
<p>You should see log messages documenting your connection from 127.0.0.1
in the console running <code>dist/network</code>.  You may have noticed that some
information that you may have expected to see after looking at <code>unikernel.ml</code>
isn't being output.  That's because we haven't specified the log level for
<code>dist/network</code>, and it defaults to <code>info</code>.  Some of the output for this application
is sent with the log level set to <code>debug</code>, so to see it, we need to run <code>dist/network</code>
with a higher log level for all logs:</p>
<pre><code>$ dist/network -l &quot;*:debug&quot;
</code></pre>
<p>The program will then output the debug-level logs, which include the content of any messages it reads.  Here's an example of what you might see:</p>
<pre><code>$ dist/network -l &quot;*:debug&quot;
2017-02-10 17:23:24 +02:00: INF [tcpip-stack-socket] Manager: connect
2017-02-10 17:23:24 +02:00: INF [tcpip-stack-socket] Manager: configuring
2017-02-10 17:23:27 +02:00: INF [application] new tcp connection from IP 127.0.0.1 on port 36358
2017-02-10 17:23:27 +02:00: DBG [application] read: 15 bytes:
hello tcp world
</code></pre>
<h4>Unix / MirageOS Stack with DHCP</h4>
<p>Next, let's try using the direct MirageOS network stack.  It will be necessary to run these programs with <code>sudo</code> or as the root user, as they need direct access to a network device.  We won't be able to contact them via the loopback interface on <code>127.0.0.1</code> either — the stack will need to either obtain IP address information via DHCP, or it can be configured directly via the <code>--ipv4</code> configuration key.</p>
<p>To configure via DHCP:</p>
<pre><code class="language-bash">$ cd device-usage/network
$ mirage configure -t unix --dhcp true --net direct
$ make depend
$ make
$ sudo dist/network -l &quot;*:debug&quot;
</code></pre>
<p>Hopefully, the application will successfully receive its network configuration.
Once the program has completed the lease transaction, it will log the configuration
information, and you'll be able to contact it as before via its own IP.</p>
<h4>Unix / MirageOS Stack with static IP addresses</h4>
<p>By default, if we do not use DHCP with a <code>direct</code> network stack, Mirage will
configure the stack to use an address of <code>10.0.0.2</code>.  You can specify a different address
with the <code>--ipv4</code> configuration key.  Depending on whether you've
configured with <code>-t macosx</code> or <code>-t unix</code>, the logic for contacting the application
from another terminal will be different.</p>
<p>For unix:
Verify that you have an existing <code>tap0</code> interface by reviewing <code>$ sudo ip link show</code>; if you do not, load the tuntap kernel module (<code>$ sudo modprobe tun</code>) and
create a <code>tap0</code> interface owned by you (<code>$ sudo tunctl -u $USER -t tap0</code>). Bring
<code>tap0</code> up using <code>$ sudo ifconfig tap0 10.0.0.1 up</code>, then:</p>
<pre><code class="language-bash">$ cd device-usage/network
$ mirage configure -t unix --dhcp false --net direct
$ make depend
$ make
$ sudo dist/network -l &quot;*:debug&quot;
</code></pre>
<p>For macosx:</p>
<pre><code>(* TODO! *)
</code></pre>
<p>Now you should be able to ping the unikernel's interface:</p>
<pre><code class="language-bash">$ ping 10.0.0.2
PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.
64 bytes from 10.0.0.2: icmp_seq=1 ttl=38 time=0.527 ms
64 bytes from 10.0.0.2: icmp_seq=2 ttl=38 time=0.367 ms
64 bytes from 10.0.0.2: icmp_seq=3 ttl=38 time=0.291 ms
^C
--- 10.0.0.2 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2005ms
rtt min/avg/max/mdev = 0.291/0.395/0.527/0.098 ms
</code></pre>
<p>Finally, you can then execute the same <code>nc(1)</code> commands as before (modulo the
target IP address of course!) to interact with the running unikernel:</p>
<pre><code>$ echo -n hello tcp world | nc -nw1 10.0.0.2 8080
</code></pre>
<p>And you will see the same output in the unikernel's terminal:</p>
<pre><code>read: 15 &quot;hello tcp world&quot;
</code></pre>
<h4>Hvt</h4>
<p>Let's make a network-enabled unikernel with <code>hvt</code>!  The IP configuration should be similar to what you've set up in the previous examples, but instead of <code>-t unix</code> or <code>-t macosx</code>, build with a <code>hvt</code> target.  If you need to specify a static IP address, remember that it should go at the end of the command in which you invoke <code>solo5-hvt</code>, just like the argument to <code>hello</code> in the <code>hello-key</code> example.</p>
<pre><code>$ cd device-usage/network
$ mirage configure -t hvt --dhcp true # for environments where DHCP works
$ make depend
$ make
$ solo5-hvt --net:service=tap100 -- dist/network.hvt --ipv4=10.0.0.10/24
            |      ___|
  __|  _ \\  |  _ \\ __ \\
\\__ \\ (   | | (   |  ) |
____/\\___/ _|\\___/____/
Solo5: Memory map: 512 MB addressable:
Solo5:     unused @ (0x0 - 0xfffff)
Solo5:       text @ (0x100000 - 0x213fff)
Solo5:     rodata @ (0x214000 - 0x255fff)
Solo5:       data @ (0x256000 - 0x331fff)
Solo5:       heap &gt;= 0x332000 &lt; stack &lt; 0x20000000
2018-06-21 12:24:46 -00:00: INF [netif] Plugging into 0 with mac 3a:40:76:41:5d:b0
2018-06-21 12:24:46 -00:00: INF [ethif] Connected Ethernet interface 3a:40:76:41:5d:b0
2018-06-21 12:24:46 -00:00: INF [arpv4] Connected arpv4 device on 3a:40:76:41:5d:b0
2018-06-21 12:24:46 -00:00: INF [udp] UDP interface connected on 10.0.0.10
2018-06-21 12:24:46 -00:00: INF [tcpip-stack-direct] stack assembled: mac=3a:40:76:41:5d:b0,ip=10.0.0.10
</code></pre>
<p>See the Solo5 documentation on <a href="https://github.com/Solo5/solo5/blob/v0.6.3/docs/building.md#running-solo5-based-unikernels">running Solo5-based unikernels</a> for details on how to set up the <code>tap100</code> interface used above for hvt networking.</p>
<h3>What's Next?</h3>
<p>There are a number of other examples in <code>device-usage/</code> which show some simple invocations
of various devices like consoles and clocks.  You may also be
interested in the <code>applications/</code> directory of the <code>mirage-skeleton</code>
repository, which contains examples that use multiple devices to build nontrivial
applications, like DNS, DHCP, and HTTPS servers.</p>
<p>The real MirageOS website (which is itself a unikernel) may also be of
interest to you!  Documentation is available at <a href="/wiki/mirage-www">mirage-www</a>,
and the source code is published <a href="https://github.com/mirage/mirage-www">in a public GitHub repository</a>.</p>
|js};
      };
      {
        updated = {js|2017-12-3 12:00|js};
        author =
          {
            name = {js|Martin Keegan|js};
            uri = Some {js|http://mk.ucant.org/|js};
            email = None;
          };
        subject = {js|Learning about Mirage|js};
        permalink = {js|learning|js};
        body =
          {js|<h1>How to learn about Mirage</h1>
<p>The Mirage <a href="/community">community</a> is very welcoming of newcomers; your
optimal learning route is try out the software on your own development
machine, then familiarise yourself with the various backends and the
main modules and techniques used in building and running real unikernels.</p>
<p>If you know some OCaml but don't know about Mirage, your first steps should
be to try either our <a href="/wiki/hello-world">Hello Mirage World</a> tutorial, or go
directly to building some of the example apps in <a href="https://github.com/mirage/mirage-skeleton">Mirage Skeleton</a>.</p>
<p>Mirage abstracts away various OS-level functionality (e.g., networking
and storage), which must be provided by backends. Commonly used
backends are <code>unix</code>, <code>hvt</code> and <code>xen</code>; the <code>unix</code> backend works within
a normal laptop-based development environment. The others tend to
involve various degrees of configuration effort, but are more
realistic for production use. You can write your code, test it on <code>unix</code> first,
and later adapt your environment to run one of the other backends.</p>
<h2>How to get help</h2>
<p>A brief survey of the Mirage development community revealed that the
preferred method of getting help is the email mailing list: the core
developers all read it. Mailing lists aren't for everyone, so here are
the alternatives, roughly in descending order of preference:</p>
<ul>
<li><a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">the mailing list</a>
</li>
<li>filing Issue tickets on relevant <a href="https://github.com/mirage">Github repositories</a>
</li>
<li><a href="https://discuss.ocaml.org/">The OCaml message board</a>
</li>
<li><code>#mirage</code> on the freenode IRC network
</li>
</ul>
<h2>Typical development workflow</h2>
<p>When checking out an example project, a typical workflow would look something
like this:</p>
<pre><code class="language-bash">    $ mirage configure -t unix
    $ make depends
    $ make
    $ dist/main
</code></pre>
<p>Be aware that the behaviour of <code>mirage configure</code> depends intimately on the
contents of the <code>config.ml</code> file in your current directory. This is true
even of its command-line options. It follows that the syntax you observe
in one tutorial or project may not always carry across to another.</p>
<p>The <code>mirage configure</code> phase does the heavy lifting to resolve what
code must be available for the backend you specify. The backend is
specified with the <code>-t</code> option.</p>
<h2>What are backends?</h2>
<p>Backends include:</p>
<ul>
<li><code>unix</code> (runs as a normal UNIX process)
</li>
<li><code>hvt</code> (<a href="https://github.com/Solo5/solo5/blob/v0.6.3/docs/building.md">runs</a> on Linux, FreeBSD, and OpenBSD, requires hardware virtualization)
</li>
<li><code>virtio</code> (<a href="https://github.com/Solo5/solo5/blob/v0.6.3/docs/building.md">runs</a> on various virtio-based hypervisors and clouds)
</li>
<li><code>xen</code> and <code>qubes</code> (run as a PV domain on the <a href="https://www.xenproject.org/">Xen</a> hypervisor)
</li>
<li><code>muen</code> (runs as a subject on the <a href="https://muen.sk/">Muen Separation Kernel</a>)
</li>
</ul>
<p>The backends above are listed in ascending order of invasiveness. <code>unix</code> runs
as a normal process on your unmodified Linux kernel, albeit it may
require root privileges. <code>hvt</code> uses
<a href="https://github.com/Solo5/solo5/tree/v0.6.3">Solo5</a> and hardware virtualization on Linux and FreeBSD, which entails some setup
work, e.g., of IP routing. <code>xen</code> requires that Xen be run underneath your
operating system(s), and that Mirage will be run directly on top of Xen.
Installing Xen is not hard (about 20 minutes), and it may conveniently
co-exist as a dual-booted environment if you don't want to dedicate your
host machine exclusively to it.</p>
<h2>Configuration</h2>
<p>For now, see the <a href="/blog/introducing-functoria">relevant blog post</a>.</p>
<p>Mirage effectively treats functionality such as persistent storage, networking,
protocols, etc, as libraries. The configuration phase for Mirage determines
which implementations of these libraries will be compiled into your unikernel.</p>
|js};
      };
      {
        updated = {js|2017-05-22 18:00|js};
        author =
          {
            name = {js|Dave Scott|js};
            uri = Some {js|http://dave.recoil.org/|js};
            email = Some {js|dave@recoil.org|js};
          };
        subject = {js|Building and packaging with dune and dune-release|js};
        permalink = {js|packaging|js};
        body =
          {js|<h2>Packaging with dune and dune-release</h2>
<p>This post describes the current state-of-the-art in building and releasing
MirageOS packages with
<a href="https://github.com/ocaml/dune">dune</a> (to build)
and
<a href="https://github.com/samoht/dune-release">dune-release</a> (to release).</p>
<p>Please note that some packages are still using <code>ocamlbuild</code> and <code>topkg</code>, install
<code>topkg-care</code> and replace <code>dune-release</code> with <code>topkg</code> below.</p>
<h3>Goals</h3>
<p>We wish to</p>
<ul>
<li>make development and releasing of individual components as quick and as easy
as possible
</li>
<li>use a similar structure across the MirageOS suite of components to make it
easier for new people (and automated tools) to work across more than one
component at a time
</li>
</ul>
<h3>The tools</h3>
<p>We make heavy use of the following tools:</p>
<ul>
<li><a href="https://github.com/ocaml/opam">opam</a>: defines a notion of a package, with versioned dependencies on other
packages inside a package repository.
We use this to ensure that we have a compatible set of component versions installed
for our current project.
</li>
<li><a href="https://github.com/ocaml/dune">dune</a>: a build tool (like <code>make</code>) which knows how to build OCaml code
incrementally and really quickly.
</li>
<li><a href="https://github.com/samoht/dune-release">dune-release</a>: a release tool which assists with tagging and uploading artefacts
to github.
</li>
</ul>
<h3>Conventions</h3>
<p>We adopt the following conventions:</p>
<ul>
<li>we prefix releases with <code>v</code> to easily distinguish concreate releases (<code>v1.2.3</code>) from release branches (<code>1.2</code>)
</li>
<li>we don't use opam's <code>depopts</code> to specify sub-libraries. Instead we create
multiple <code>opam</code> packages via multiple <code>&lt;name&gt;.opam</code> files in the same repo.
See <a href="http://rgrinberg.com/posts/optional-dependencies-considered-harmful/">rgrinberg</a>'s
post for a rationale
</li>
<li>we prefer to use the same name for both the <code>ocamlfind</code> package and the <code>opam</code> package. This is to avoid misunderstandings over whether you need to type <code>mirage-types.lwt</code> or <code>mirage-types-lwt</code> in the current context.
</li>
<li>we write <code>CHANGES.md</code> entries in the same style, to ensure they are parseable
by <code>dune-release</code>
</li>
<li>we do not enable warnings as errors in the repo; instead we turn these on for
local developer builds only. This is to prevent released versions from breaking
when a future compiler version is released.
</li>
</ul>
<h3>Package structure</h3>
<p>A MirageOS library should have</p>
<ul>
<li><code>CHANGES.md</code>: containing a log of user-visible changes in each release.
For example consider <a href="https://github.com/mirage/mirage-tcpip/blob/v3.7.1/CHANGES.md">mirage-tcpip CHANGES.md</a>:
it has a markdown <code>###</code> prefix before each release version and the date in
<code>(YYYY-MM-DD)</code> form.
</li>
<li><code>LICENSE.md</code>: describing the conditions under which the code can be used
(the MirageOS standard license is ISC).
For example <a href="https://github.com/mirage/mirage-tcpip/blob/v3.7.1/LICENSE.md">mirage-tcpip LICENSE.md</a>.
</li>
<li><code>README.md</code>: describing what the code is for and linking to examples, docs,
continuous integration (CI) status. For example <a href="https://github.com/mirage/mirage-tcpip/blob/v3.7.1/README.md">mirage-tcpip.3.7.1</a>.
</li>
<li>one <code>&lt;name&gt;.opam</code> file per opam package defined in the repo.
For example <a href="https://github.com/mirage/mirage-block/blob/1.2.0/mirage-block.opam">mirage-block.1.2.0</a>
and <a href="https://github.com/mirage/mirage-block/blob/1.2.0/mirage-block-lwt.opam">mirage-block-lwt.1.2.0</a>.
These should have a github pages <code>doc:</code> link in order that <code>dune-release</code> can detect
the upstream repo.
</li>
<li><code>Makefile</code>: contains <code>dune</code> invocations.
For example <a href="https://github.com/mirage/mirage-block/blob/1.2.0/Makefile">mirage-block.1.2.0</a>
</li>
<li>one or more <code>dune</code> files: these describe how to build the libraries, executables
and tests of your project.
For example <a href="https://github.com/mirage/mirage-block-unix/blob/v2.11.0/lib/dune">mirage-block-unix.2.11.0/lib/dune</a>
links the main library against OCaml and C,
while <a href="https://github.com/mirage/mirage-block-unix/blob/v2.11.0/lib_test/dune">mirage-block-unix.2.11.0/lib_test/dune</a>
defines 2 executables and associates one with an alias <code>runtest</code>, triggered by
<code>make test</code> in the root.
</li>
</ul>
<h3>Developing changes</h3>
<p>It should be sufficient to</p>
<ul>
<li><code>git clone</code> the repo
</li>
<li><code>opam install --deps-only &lt;name&gt;</code>: to install any required dependencies
</li>
</ul>
<p>and then</p>
<ul>
<li><code>make</code>: to perform an incremental build
</li>
<li><code>make test</code>: to compile and execute tests
</li>
<li><code>dune utop</code>: to launch an interactive top-level
</li>
</ul>
<h3>Releasing changes</h3>
<p>MirageOS releases are published via github. First log into your account and create
a GitHub API token if you haven't already. Store it in a file (e.g. <code>~/.config/dune/github.token</code>).
If on a multi-user machine, ensure the privileges are set to prevent other users
from reading it.</p>
<p>Before releasing anything it's a good idea to review the outstanding issues.
Perhaps some can be closed already? Maybe a <code>CHANGES.md</code> entry is missing?</p>
<p>When ready to go, create a branch from <code>master</code> and edit the <code>CHANGES.md</code> file
to list the interesting changes made since the last release. Make a pull request (PR) for this
update. The CI will run which is a useful final check that the code still builds
and the tests still pass.
(It's
ok to skip this if the CI was working fine a few moments ago when you merged
another PR). If you include <code>[ci skip]</code> in your commit message, the CI will not be run.</p>
<p>When the <code>CHANGES.md</code> PR is merged, pull it into your local <code>master</code> branch.</p>
<p>Read <code>dune-release help release</code> to have an overview of the full release workflow.
You need to have <code>odoc</code> installed to generate the documentation.</p>
<p>Type:</p>
<pre><code>dune-release tag
</code></pre>
<p>-- dune-release will extract the latest version from the <code>CHANGES.md</code> file, perform
version substitutions and create a local tag.</p>
<p>Type:</p>
<pre><code>dune-release distrib
</code></pre>
<p>-- dune-release will create a release tarball.</p>
<p>Install <code>odoc</code> and type:</p>
<pre><code>dune-release publish --dry-run
</code></pre>
<p>-- dune-release will build the documentation (fix all the warnings).</p>
<p>Type:</p>
<pre><code>dune-release publish
</code></pre>
<p>-- dune-release will push the tag, create a release and upload the release tarball.
It will also build the docs and push them online.</p>
<p>Type</p>
<pre><code>dune-release opam pkg
dune-release opam submit
</code></pre>
<p>-- this will add new files in your opam-repository clone. <code>git commit</code> and push them to your fork on GitHub
and open a new pull-request.</p>
<p>You can simply write:</p>
<pre><code>dune-release tag &amp;&amp; dune-release
</code></pre>
<p>-- this will do the above steps (distrib, publish, opam pkg, opam submit).</p>
|js};
      };
      {
        updated = {js|2017-02-23 16:00|js};
        author =
          {
            name = {js|Thomas Gazagnaire|js};
            uri = Some {js|http://gazagnaire.org|js};
            email = Some {js|thomas@gazagnaire.org|js};
          };
        subject = {js|Error Handling in Mirage3|js};
        permalink = {js|mirage-3.0-errors|js};
        body =
          {js|<h2>Error Handling in Mirage3</h2>
<p>After more than two years
<a href="https://lists.xenproject.org/archives/html/mirageos-devel/2014-07/msg00069.html">of</a>
<a href="https://github.com/mirage/mirage-www/pull/274">discussion</a>, we
finally agreed and decided which consistent error scheme will be used
for Mirage3. This blog post describes how library developers are
supposed to expose errors and how users could handle them.</p>
<h3>Goals</h3>
<p>POSIX and C generally make for very poor error handling: the
information reported to the user is just a small number stored in
<code>errno</code> and errors are easily ignored accidentally.</p>
<p>With Mirage, we have the opportunity to provide something much better.
OCaml's structured types and exceptions can provide rich diagnostic
information that is readable to humans and to machines, and its
exhaustiveness checks mean we can force callers to consider errors
where necessary.</p>
<p>There are three main aspects to consider:</p>
<ul>
<li>Providing diagnostic information to humans.
</li>
<li>Allowing programs to detect and handle certain errors specially.
</li>
<li>Indicating failure in order to abort or roll back the current operation.
</li>
</ul>
<p>Note that the last two points are very different. Exceptions can be
thrown at any point in an OCaml program and robust code must be
prepared to handle this. In particular, this (fictional) code is
<em>wrong</em>:</p>
<pre><code class="language-ocaml">  let gntref = Gntshr.get () in
  match_lwt f gntref with
  | `Ok () -&gt; Gntshr.put gntref; return (`Ok ())
  | `Error _ as e -&gt; Gntshr.put gntref; return e
</code></pre>
<p>If <code>f</code> throws an exception, the grant ref will be leaked.
The correct pattern is:</p>
<pre><code class="language-ocaml">  Gntshr.with_ref f
</code></pre>
<p>This will release the resource whether <code>f</code> returns success, returns an
error code or raises an exception.</p>
<h3>Errors vs. Exceptions</h3>
<p>Real World OCaml's <a href="https://realworldocaml.org/v1/en/html/error-handling.html">Chapter 7. Error Handling</a>
provides an excellent overview of the options for handling errors in OCaml. It
finishes with this good advice:</p>
<blockquote>
<p>To be clear, it doesn't make sense to avoid exceptions entirely. The
maxim of &quot;use exceptions for exceptional conditions&quot; applies. If an
error occurs sufficiently rarely, then throwing an exception is often
the right behavior.</p>
<p>Also, for errors that are omnipresent, error-aware return types may
be overkill. A good example is out-of-memory errors, which can occur
anywhere, and so you'd need to use error-aware return types
everywhere to capture those.  <strong>Having every operation marked as one
that might fail is no more explicit than having none of them
marked.</strong></p>
<p>In short, for errors that are a foreseeable and ordinary part of the
execution of your production code and that are not omnipresent,
error-aware return types are typically the right solution.</p>
</blockquote>
<p>In the case of Mirage, it is typically the case that every operation
may fail and that, since the interfaces are abstract, we cannot know
all the ways they may fail. This seems like a good argument for using
exceptions.</p>
<p>However, we still want to use explicit variants for expected
(non-exceptional) cases that callers will probably want to handle.
For example,
<a href="https://mirage.github.io/mirage-kv/Mirage_kv.html#TYPEerror">KV_RO</a>'s
<code>Unknown_key</code> case is something code will often want to use, e.g. to
provide a default value. This shouldn't even be considered an error.</p>
<h3>Errors and Results</h3>
<p>Since 4.03, the OCaml standard library has introduced the
<a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#TYPEresult">result
type</a>:</p>
<pre><code class="language-ocaml">type ('a, 'b) result = Ok of 'a | Error of 'b
</code></pre>
<p>A few useful libraries have also been released with useful
combinators on result values, including Daniel Bünzli's
<a href="http://erratique.ch/software/rresult/doc">Rresult</a> and
Simon Cruanes's <a href="https://github.com/ocsigen/lwt/blob/master/src/core/lwt_result.mli">Lwt_result</a>.</p>
<p>In Mirage3, all the base components define an abstract <code>error</code> type, a
<code>pp_error</code> function to print these errors, and all the functions which
can fail return a result value. For instance, <code>Mirage_block_lwt</code>
defines a read operation as follows:</p>
<pre><code class="language-ocaml">module type S = sig
  type error
  val pp_error: error Fmt.t
  val read: t -&gt; int64 -&gt; Cstruct.t list -&gt; (unit, error) result Lwt.t
end
</code></pre>
<p>To combine multiple <code>read</code>s, while propagating read errors to the
caller, one can do:</p>
<pre><code class="language-ocaml">open Lwt_result.Infix (* Note here that we do not open [Lwt.Infix] *)

module F (B: Mirage_block_lwt.S) = struct
  let read_twice t n bufs =
    B.read t n bufs &gt;&gt;= fun () -&gt;
    B.read t n bufs
end
</code></pre>
<p>The base components can, when needed, also define more types
as long and their pretty-printer if also provided: <code>Mirage_block_lwt</code>
also defines a <code>write_error</code> type and a <code>pp_write_error</code> function.</p>
<h3>Errors and Abstraction</h3>
<p>So far, we did not mention how abstract the errors should be. Most of
the time, it will not really matter, as the most common handling of
errors is to print them (using the provided <code>pp_error</code> function), or
to check whether the operation was successful (e.g. that the result is
<code>Ok</code>). In these cases, having an abstract error is perfectly fine.</p>
<p>However, there are some cases where it is important to know what
the error was in order to take the proper action. In this case we want
something but want something not fully abstract: welcome to <a href="https://caml.inria.fr/pub/docs/manual-ocaml/extn.html#sec222">private
row
types</a>.
The manual says:</p>
<blockquote>
<p>Private row types are type abbreviations where part of the structure
of the type is left abstract.</p>
</blockquote>
<p>For instance, the block <code>Mirage_block_lwt</code> actually defines the error
type as a subset of the error cases which could happen when creating a
new block device:</p>
<pre><code class="language-ocaml">module type S = sig
  type error = private [&gt; `Unimplemented | `Disconnected]
end
</code></pre>
<p>The <code>private</code> and <code>&gt;</code> signs mean that an implementation of the Mirage3
block device is allowed to define an <code>error</code> type with more
values. But when this implementation is used in the context of a
Mirage3 block device, all these other cases become abstract and it is
not possible to pattern-match on these errors anymore.</p>
<p>For instance, the error type for <a href="https://github.com/mirage/mirage-fs-unix">Unix
filesystem</a> devices is
defined as follows:</p>
<pre><code class="language-ocaml">type fs_error = [
  | `Unix_error of Unix.error
  | `Unix_errorno of int
  | `Negative_bytes
]
type error = [ Mirage_fs.error | fs_error ]

include Mirage_fs_lwt.S with type error := error
</code></pre>
<p>The last line says that <code>Mirage_fs_unix</code> satisfies the
<code>Mirage_fs_lwt.S</code> signature but also exposes a concrete <code>error</code>
type. Users of <code>Mirage_fs_unix</code> can then pattern-match on the exact
concrete error (for instance, to do something useful when a
<code>Unix_error</code> is raised) -- used in the context of MirageOS, only the
cases defined in <code>Mirage_fs.error</code> will be visible to the user. We
strongly advocate using the same approach in your libraries, as it
brings the flexibility of using concrete types vs. proper abstraction
through composition.</p>
<h3>Conclusion</h3>
<p>Mirage3 uses the <code>result</code> type pervasively, requires libraries to
provide pretty-printer for their error types and recommends using
private row types when abstract error types are not enough.</p>
|js};
      };
      {
        updated = {js|2017-02-23 16:00|js};
        author =
          {
            name = {js|Mindy Preston|js};
            uri = Some {js|https://github.com/yomimono|js};
            email = Some {js|mindy.preston@cl.cam.ac.uk|js};
          };
        subject = {js|Porting Mirage 2.x Projects to Mirage 3.x|js};
        permalink = {js|mirage2-to-mirage3|js};
        body =
          {js|<h1>Incompatibilities</h1>
<p>For a short summary of breaking changes, see <a href="https://github.com/mirage/mirage/releases/tag/v3.0.0">the Mirage 3.0.0 release notes</a>.  This document is a guide to porting your existing unikernel from the Mirage 2.x interface to Mirage 3.x.  If your unikernel was based on one of the examples in <a href="https://github.com/mirage/mirage-skeleton">the mirage-skeleton repository</a>, you may find <a href="http://www.cl.cam.ac.uk/~hm519/mirage-2.9.1-3.0.0-diffs/">hannesm's collection of diffs from v2.9.1 to v3.0.0</a> for popular unikernels to be a useful reference.</p>
<h2>config.ml and generic/default functions</h2>
<p>A number of refinements to the configuration language for Mirage were made in the Mirage 2.7.0 release, which incorporated the <a href="https://github.com/mirage/functoria">functoria</a> DSL.  It was still possible to use the previous calls, however, until Mirage 3.0.0 where support for them was dropped.  Many users whose unikernels predate Mirage 2.7.0 will first notice the functoria improvements in the 3.0.0 release, as they'll finally be forced to use them.</p>
<p>The idiom for deciding which <code>impl</code> to use based on the backend is the most noticeable change.  Numerous older <code>config.ml</code> files include code like the following, from <a href="https://github.com/mirage/mirage-skeleton/tree/21adfc85b124e886d871079f28bd0a868ba3c5fb/kv_ro">mirage-skeleton's <code>kv_ro</code> example in commit <code>21adfc85b124e886d871079f28bd0a868ba3c5fb</code></a>, which attempts to detect which <code>kv_ro</code> device to use based on the target chosen with <code>mirage configure -t</code> and environment variables:</p>
<pre><code>let mode =
  let x = try Unix.getenv &quot;FS&quot; with Not_found -&gt; &quot;crunch&quot; in
  match x with
  | &quot;fat&quot; -&gt; `Fat
  | &quot;crunch&quot; -&gt; `Crunch
  | x -&gt; failwith (&quot;Unknown FS mode: &quot; ^ x )

let fat_ro dir =
  kv_ro_of_fs (fat_of_files ~dir ())

let disk =
  match mode, get_mode () with
  | `Fat   , _     -&gt; fat_ro &quot;t&quot;
  | `Crunch, `Xen  -&gt; crunch &quot;t&quot;
  | `Crunch, (`Unix | `MacOSX) -&gt; direct_kv_ro &quot;t&quot;
</code></pre>
<p>Functoria improved the situation considerably by including convenience functions which not only have logic for autodetecting which implementations are suitable based on the backend selected, but also other arguments given to <code>mirage configure</code>.  The code above can be replaced with:</p>
<pre><code>let disk = generic_kv_ro &quot;t&quot;
</code></pre>
<p><code>generic_kv_ro</code> knows about not only the Xen, Unix, and MacOSX targets handled by the previous config.ml code, but also will do the right thing for new targets Ukvm, Virtio, and Qubes.  The command-line argument <code>--kv_ro</code> will be understood when <code>mirage configure</code> is run from a directory with a <code>config.ml</code> including <code>generic_kv_ro</code>.</p>
<p>Several useful <code>default_</code> and <code>generic_</code> functions are provided by <a href="http://docs.mirage.io/mirage/Mirage">the Mirage module</a> for use in <code>config.ml</code>:</p>
<pre><code>~/mirage$ grep -E 'val (generic_|default_)'  lib/mirage.mli
val default_qubesdb: qubesdb impl
val default_time: time impl
val default_posix_clock: pclock impl
val default_monotonic_clock: mclock impl
val default_reporter:
val default_random: random impl
val default_console: console impl
val default_io_page: io_page impl
val generic_kv_ro:
val default_network: network impl
val generic_stackv4:
val default_argv: Functoria_app.argv impl
</code></pre>
<p>Many existing unikernels will find it useful to replace their existing network stack detecting code with <code>generic_stackv4</code> in particular -- let's see an example.</p>
<h2>Porting the stackv4 example to Mirage 3</h2>
<p>A good example of replacing old configurator code can be seen between <a href="https://github.com/mirage/mirage-skeleton/tree/21adfc85b124e886d871079f28bd0a868ba3c5fb/stackv4">the pre-functoria <code>network</code> example</a>, and <a href="https://github.com/mirage/mirage-skeleton/tree/e9360fa1ce02d26a8931238a16000fa12df40ebf/device-usage/network">the <code>device-usage/network</code> example from the Mirage-3.0.0-compatible branch of <code>mirage-skeleton</code></a>.  We can replace this old code from <code>config.ml</code>:</p>
<pre><code>let net =
  try match Sys.getenv &quot;NET&quot; with
    | &quot;direct&quot; -&gt; `Direct
    | &quot;socket&quot; -&gt; `Socket
    | _        -&gt; `Direct
  with Not_found -&gt; `Direct

let dhcp =
  try match Sys.getenv &quot;ADDR&quot; with
    | &quot;dhcp&quot;   -&gt; `Dhcp
    | &quot;static&quot; -&gt; `Static
  with Not_found -&gt; `Dhcp

let stack console =
  match net, dhcp with
  | `Direct, `Dhcp   -&gt; direct_stackv4_with_dhcp console tap0
  | `Direct, `Static -&gt; direct_stackv4_with_default_ipv4 console tap0
  | `Socket, _       -&gt; socket_stackv4 console [Ipaddr.V4.any]

</code></pre>
<p>with this:</p>
<pre><code>let stack = generic_stackv4 default_network
</code></pre>
<p>You may notice that <code>generic_stackv4</code> doesn't take a <code>console</code> argument, where the previous <code>direct_stackv4*</code> and <code>socket_stackv4</code> functions did.  This leads us to another big change that predates MirageOS 3, but is more widely used and better supported in this release: logging.</p>
<p>The <code>mirage_logs</code> library and its incorporation into the configuration language dates back to version 2.9.0, but a number of libraries still required a <code>console impl</code> argument and expected to log to the console.  In Mirage 3.0.0, we've tried to replace the calls to <code>Console.log</code> with calls to <code>Logs.debug</code>, <code>Logs.info</code>, or <code>Logs.warn</code> as appropriate.  Consequently, many of the functions which previously needed to be passed a console no longer require it.  For example, we can take <a href="https://github.com/mirage/mirage-skeleton/tree/f36d2958f616fb882df37f08d3440797471ca0cc/stackv4">the <code>stackv4</code> example from <code>mirage-skeleton</code> commit f36d2958f616fb882df37f08d3440797471ca0cc</a>, which fails with Mirage 3:</p>
<pre><code>mirage-skeleton/stackv4$ cat config.ml
open Mirage

let handler = foreign &quot;Unikernel.Main&quot; (console @-&gt; stackv4 @-&gt; job)

let stack = generic_stackv4 default_console tap0

let () =
  register &quot;stackv4&quot; [handler $ default_console $ stack]
mirage-skeleton/stackv4$ 
mirage-skeleton/stackv4$ mirage configure -t unix
mirage: unknown option `-t'.
Usage: mirage configure [OPTION]... 
Try `mirage configure --help' or `mirage --help' for more information.
error while executing ocamlbuild -use-ocamlfind -classic-display -tags
                        bin_annot -quiet -X _build-ukvm -pkg mirage
                        config.cmxs
+ ocamlfind ocamlc -c -bin-annot -package mirage -o config.cmo config.ml
File &quot;config.ml&quot;, line 5, characters 44-48:
Error: The function applied to this argument has type
         ?group:string -&gt;
         ?config:Mirage.ipv4_config -&gt;
         ?dhcp_key:bool Mirage.value -&gt;
         ?net_key:[ `Direct | `Socket ] Mirage.value -&gt;
         Mirage.stackv4 Functoria.impl
This argument cannot be applied without label
Command exited with code 2.
Hint: Recursive traversal of subdirectories was not enabled for this build,
  as the working directory does not look like an ocamlbuild project (no
  '_tags' or 'myocamlbuild.ml' file). If you have modules in subdirectories,
  you should add the option &quot;-r&quot; or create an empty '_tags' file.
  
  To enable recursive traversal for some subdirectories only, you can use the
  following '_tags' file:
  
      true: -traverse
      &lt;dir1&gt; or &lt;dir2&gt;: traverse
</code></pre>
<p>Note that in the output above, we get an initial error message suggesting that <code>-t unix</code> is not understood by <code>mirage configure</code>.  The failure to understand any option, including <code>-t</code>, is a side effect of <code>config.ml</code> itself not being understood by <code>mirage</code>  The error message from <code>ocamlbuild</code> that follows the <code>mirage</code> output about <code>-t unix</code> is the right place to start fixing this problem.</p>
<p>Let's remove the <code>default_console</code> argument to <code>stackv4</code>, to give the following <code>config.ml</code>:</p>
<pre><code class="language-ocaml">open Mirage

let handler = foreign &quot;Unikernel.Main&quot; (console @-&gt; stackv4 @-&gt; job)

let stack = generic_stackv4 tap0

let () =
  register &quot;stackv4&quot; [handler $ default_console $ stack]
mirage-skeleton/stackv4$ mirage configure -t unix
mirage: unknown option `-t'.
Usage: mirage configure [OPTION]... 
Try `mirage configure --help' or `mirage --help' for more information.
error while executing ocamlbuild -use-ocamlfind -classic-display -tags
                        bin_annot -quiet -X _build-ukvm -pkg mirage
                        config.cmxs
+ ocamlfind ocamlc -c -bin-annot -package mirage -o config.cmo config.ml
File &quot;config.ml&quot;, line 5, characters 28-32:
Error: Unbound value tap0
Command exited with code 2.
</code></pre>
<p>We can see from the last bit of output that <code>tap0</code> is no longer known to Mirage.  The <code>tap0</code> function has been renamed to the more idiomatic <code>default_network</code> in MirageOS 3, so let's change that to get the following <code>config.ml</code>:</p>
<pre><code class="language-ocaml">open Mirage

let handler = foreign &quot;Unikernel.Main&quot; (console @-&gt; stackv4 @-&gt; job)

let stack = generic_stackv4 default_network

let () =
  register &quot;stackv4&quot; [handler $ default_console $ stack]
</code></pre>
<p>and then try <code>mirage configure</code> to see some success:</p>
<pre><code>mirage-skeleton/stackv4$ mirage configure -t unix
</code></pre>
<h3>A new step: make depend</h3>
<p>In Mirage 2.x, <code>mirage configure</code> would automatically invoke <code>opam</code> to install the latest version of any packages it detected were needed.  The automatic alteration of the build environment was surprising to a lot of people, and additionally the invocation of <code>opam install</code> was slow enough that many heavy Mirage users usually called <code>mirage configure</code> with the <code>--no-opam</code> option to disable it.  In Mirage 3, <code>mirage configure</code> no longer automatically installs packages, but a convenient shorthand for installing everything necessary is still available with <code>make depend</code>.  <code>make depend</code> relies on information discovered during <code>mirage configure</code>, and is only available after that step.  You should run it when you change <code>config.ml</code> or you invoke <code>mirage configure</code> with different arguments.  We've just done the former, so we'll need to <code>make depend</code> before <code>make</code>ing:</p>
<pre><code>mirage-skeleton/stackv4$ make depend &amp;&amp; make

pam pin add --no-action --yes mirage-unikernel-stackv4-unix .
Package mirage-unikernel-stackv4-unix does not exist, create as a NEW package ? [Y/n] y
mirage-unikernel-stackv4-unix is now path-pinned to /home/user/mirage-skeleton/stackv4

[mirage-unikernel-stackv4-unix] /home/user/mirage-skeleton/stackv4/ synchronized
[mirage-unikernel-stackv4-unix] Installing new package description from
/home/user/mirage-skeleton/stackv4

opam depext --yes mirage-unikernel-stackv4-unix
# Detecting depexts using flags: x86_64 linux debian
# The following system packages are needed:
#  - debianutils
#  - m4
#  - ncurses-dev
#  - pkg-config
#  - time
# All required OS packages found.
opam install --yes --deps-only mirage-unikernel-stackv4-unix

=-=- Synchronising pinned packages =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
[mirage-unikernel-stackv4-unix] /home/user/mirage-skeleton/stackv4/ already up-to-date
The following actions will be performed:
  ∗  install mirage-console-unix dev~mirage

=-=- Gathering sources =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
[mirage-console-unix] https://github.com/mirage/mirage-console.git updated

=-=- Processing actions -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
∗  installed mirage-console-unix.dev~mirage
Done.
opam pin remove --no-action mirage-unikernel-stackv4-unix
mirage-unikernel-stackv4-unix is now unpinned from path /home/user/mirage-skeleton/stackv4
mirage build
ocamlfind ocamldep -package tcpip.udp -package tcpip.tcp -package tcpip.stack-direct -package tcpip.ipv4 -package tcpip.icmpv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-random -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -modules main.ml &gt; main.ml.depends
ocamlfind ocamldep -package tcpip.udp -package tcpip.tcp -package tcpip.stack-direct -package tcpip.ipv4 -package tcpip.icmpv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-random -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -modules key_gen.ml &gt; key_gen.ml.depends
ocamlfind ocamldep -package tcpip.udp -package tcpip.tcp -package tcpip.stack-direct -package tcpip.ipv4 -package tcpip.icmpv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-random -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -modules unikernel.ml &gt; unikernel.ml.depends
ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.udp -package tcpip.tcp -package tcpip.stack-direct -package tcpip.ipv4 -package tcpip.icmpv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-random -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o key_gen.cmo key_gen.ml
ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.udp -package tcpip.tcp -package tcpip.stack-direct -package tcpip.ipv4 -package tcpip.icmpv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-random -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o unikernel.cmo unikernel.ml
+ ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.udp -package tcpip.tcp -package tcpip.stack-direct -package tcpip.ipv4 -package tcpip.icmpv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-random -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o unikernel.cmo unikernel.ml
File &quot;unikernel.ml&quot;, line 2, characters 5-11:
Error: Unbound module V1_LWT
Command exited with code 2.
run ['ocamlbuild' '-use-ocamlfind' '-classic-display' '-tags'
     'predicate(mirage_unix),warn(A-4-41-42-44),color(always),debug,bin_annot,strict_sequence,principal,safe_string'
     '-pkgs'
     'functoria-runtime,lwt,mirage-clock-unix,mirage-console-unix,mirage-logs,mirage-net-unix,mirage-random,mirage-runtime,mirage-types,mirage-types-lwt,mirage-unix,tcpip,tcpip.arpv4,tcpip.ethif,tcpip.icmpv4,tcpip.ipv4,tcpip.stack-direct,tcpip.tcp,tcpip.udp'
     '-cflags' '-g' '-lflags' '-g' '-tag-line' '&lt;static*.*&gt;: warn(-32-34)'
     '-X' '_build-ukvm' 'main.native']: exited with 10
Makefile:18: recipe for target 'build' failed
make: *** [build] Error 1
</code></pre>
<h3>Where to find module type definitions</h3>
<p>We got a bit further that time, but we're still not quite there.  The module previously known as <code>V1_LWT</code>, which contained definitions for all of the module types (e.g. <code>CONSOLE</code>, <code>BLOCK</code>, <code>STACKV4</code>) used to define bits of operating system functionality has renamed.  <code>V1</code> is now <code>Mirage_types</code>, and <code>V1_LWT</code> is now <code>Mirage_types_lwt</code>.  Both <code>Mirage_types</code> and <code>Mirage_types_lwt</code> just refer to definitions in respective packages now, rather than containing the module types directly, and it would be better to directly reference the ones we need rather than opening up all of <code>Mirage_types_lwt</code>.  (You may find <a href="https://github.com/mirage/mirage/blob/master/types/mirage_types.mli">the map of module type names from Mirage_types to their true names</a> useful to keep handy.) Let's edit <code>unikernel.ml</code> to refer to <code>Mirage_console_lwt.S</code> and <code>Mirage_stack_lwt.V4</code> accordingly:</p>
<pre><code class="language-ocaml">open Lwt.Infix
open Printf

let red fmt    = sprintf (&quot;\\027[31m&quot;^^fmt^^&quot;\\027[m&quot;)
let green fmt  = sprintf (&quot;\\027[32m&quot;^^fmt^^&quot;\\027[m&quot;)
let yellow fmt = sprintf (&quot;\\027[33m&quot;^^fmt^^&quot;\\027[m&quot;)
let blue fmt   = sprintf (&quot;\\027[36m&quot;^^fmt^^&quot;\\027[m&quot;)

module Main (C:Mirage_console_lwt.S) (S:Mirage_stack_lwt.V4) = struct

  module T  = S.TCPV4

  let start console s =

    let ips = List.map Ipaddr.V4.to_string (S.IPV4.get_ip (S.ipv4 s)) in
    C.log_s console (sprintf &quot;IP address: %s\\n&quot; (String.concat &quot;, &quot; ips))

    &gt;&gt;= fun () -&gt;
    let local_port = 53 in
    S.listen_udpv4 s ~port:local_port (
      fun ~src ~dst ~src_port buf -&gt;
        C.log_s console
          (red &quot;UDP %s:%d &gt; %s:%d: \\&quot;%s\\&quot;&quot;
             (Ipaddr.V4.to_string src) src_port
             (Ipaddr.V4.to_string dst) local_port
             (Cstruct.to_string buf))
    );

    let local_port = 8080 in
    S.listen_tcpv4 s ~port:local_port (
      fun flow -&gt;
        let remote, remote_port = T.get_dest flow in
        C.log_s console
          (green &quot;TCP %s:%d &gt; _:%d&quot;
             (Ipaddr.V4.to_string remote) remote_port local_port)

        &gt;&gt;= fun () -&gt;
        T.read flow

        &gt;&gt;= function
        | `Ok b -&gt;
          C.log_s console
            (yellow &quot;read: %d \\&quot;%s\\&quot;&quot; (Cstruct.len b) (Cstruct.to_string b))

          &gt;&gt;= fun () -&gt;
          T.close flow

        | `Eof -&gt; C.log_s console (red &quot;read: eof&quot;)
        | `Error _e -&gt; C.log_s console (red &quot;read: error&quot;)
    );

    S.listen s
end
</code></pre>
<p>We get a bit closer, but we're still not to successful compilation yet:</p>
<pre><code>~/mirage-skeleton/stackv4$ make
mirage build
ocamlfind ocamldep -package tcpip.udp -package tcpip.tcp -package tcpip.stack-direct -package tcpip.ipv4 -package tcpip.icmpv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-random -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -modules unikernel.ml &gt; unikernel.ml.depends
ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.udp -package tcpip.tcp -package tcpip.stack-direct -package tcpip.ipv4 -package tcpip.icmpv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-random -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o unikernel.cmo unikernel.ml
+ ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.udp -package tcpip.tcp -package tcpip.stack-direct -package tcpip.ipv4 -package tcpip.icmpv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-random -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o unikernel.cmo unikernel.ml
File &quot;unikernel.ml&quot;, line 17, characters 4-11:
Error: Unbound value C.log_s
Hint: Did you mean log?
Command exited with code 2.
run ['ocamlbuild' '-use-ocamlfind' '-classic-display' '-tags'
     'predicate(mirage_unix),warn(A-4-41-42-44),color(always),debug,bin_annot,strict_sequence,principal,safe_string'
     '-pkgs'
     'functoria-runtime,lwt,mirage-clock-unix,mirage-console-unix,mirage-logs,mirage-net-unix,mirage-random,mirage-runtime,mirage-types,mirage-types-lwt,mirage-unix,tcpip,tcpip.arpv4,tcpip.ethif,tcpip.icmpv4,tcpip.ipv4,tcpip.stack-direct,tcpip.tcp,tcpip.udp'
     '-cflags' '-g' '-lflags' '-g' '-tag-line' '&lt;static*.*&gt;: warn(-32-34)'
     '-X' '_build-ukvm' 'main.native']: exited with 10
Makefile:18: recipe for target 'build' failed
make: *** [build] Error 1
</code></pre>
<h3>Name changes: C.log_s -&gt; C.log, T.get_dest -&gt; T.dst</h3>
<p><code>C</code> is a module of type <code>Mirage_console_lwt.S</code>.  This module type was refactored in Mirage 3 to remove <code>log</code>, and rename the more commonly used <code>log_s</code> to <code>log</code>.  If we really want to be sure that our messages go to the <em>console</em>, rather than to another available logging destination, we can change <code>unikernel.ml</code> to use <code>C.log</code> instead of <code>C.log_s</code>:</p>
<pre><code>
open Lwt.Infix
open Printf

let red fmt    = sprintf (&quot;\\027[31m&quot;^^fmt^^&quot;\\027[m&quot;)
let green fmt  = sprintf (&quot;\\027[32m&quot;^^fmt^^&quot;\\027[m&quot;)
let yellow fmt = sprintf (&quot;\\027[33m&quot;^^fmt^^&quot;\\027[m&quot;)
let blue fmt   = sprintf (&quot;\\027[36m&quot;^^fmt^^&quot;\\027[m&quot;)

module Main (C:Mirage_console_lwt.S) (S:Mirage_stack_lwt.V4) = struct

  module T  = S.TCPV4

  let start console s =

    let ips = List.map Ipaddr.V4.to_string (S.IPV4.get_ip (S.ipv4 s)) in
    C.log console (sprintf &quot;IP address: %s\\n&quot; (String.concat &quot;, &quot; ips))

    &gt;&gt;= fun () -&gt;
    let local_port = 53 in
    S.listen_udpv4 s ~port:local_port (
      fun ~src ~dst ~src_port buf -&gt;
        C.log console
          (red &quot;UDP %s:%d &gt; %s:%d: \\&quot;%s\\&quot;&quot;
             (Ipaddr.V4.to_string src) src_port
             (Ipaddr.V4.to_string dst) local_port
             (Cstruct.to_string buf))
    );

    let local_port = 8080 in
    S.listen_tcpv4 s ~port:local_port (
      fun flow -&gt;
        let remote, remote_port = T.get_dest flow in
        C.log console
          (green &quot;TCP %s:%d &gt; _:%d&quot;
             (Ipaddr.V4.to_string remote) remote_port local_port)

        &gt;&gt;= fun () -&gt;
        T.read flow

        &gt;&gt;= function
        | `Ok b -&gt;
          C.log console
            (yellow &quot;read: %d \\&quot;%s\\&quot;&quot; (Cstruct.len b) (Cstruct.to_string b))

          &gt;&gt;= fun () -&gt;
          T.close flow

        | `Eof -&gt; C.log console (red &quot;read: eof&quot;)
        | `Error _e -&gt; C.log console (red &quot;read: error&quot;)
    );

    S.listen s
end
</code></pre>
<p>This lets us find our next problem:</p>
<pre><code>~/mirage-skeleton/stackv4$ make
mirage build
ocamlfind ocamldep -package tcpip.udp -package tcpip.tcp -package tcpip.stack-direct -package tcpip.ipv4 -package tcpip.icmpv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-random -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -modules unikernel.ml &gt; unikernel.ml.depends
ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.udp -package tcpip.tcp -package tcpip.stack-direct -package tcpip.ipv4 -package tcpip.icmpv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-random -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o unikernel.cmo unikernel.ml
+ ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.udp -package tcpip.tcp -package tcpip.stack-direct -package tcpip.ipv4 -package tcpip.icmpv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-random -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o unikernel.cmo unikernel.ml
File &quot;unikernel.ml&quot;, line 33, characters 34-44:
Error: Unbound value T.get_dest
Command exited with code 2.
run ['ocamlbuild' '-use-ocamlfind' '-classic-display' '-tags'
     'predicate(mirage_unix),warn(A-4-41-42-44),color(always),debug,bin_annot,strict_sequence,principal,safe_string'
     '-pkgs'
     'functoria-runtime,lwt,mirage-clock-unix,mirage-console-unix,mirage-logs,mirage-net-unix,mirage-random,mirage-runtime,mirage-types,mirage-types-lwt,mirage-unix,tcpip,tcpip.arpv4,tcpip.ethif,tcpip.icmpv4,tcpip.ipv4,tcpip.stack-direct,tcpip.tcp,tcpip.udp'
     '-cflags' '-g' '-lflags' '-g' '-tag-line' '&lt;static*.*&gt;: warn(-32-34)'
     '-X' '_build-ukvm' 'main.native']: exited with 10
Makefile:18: recipe for target 'build' failed
make: *** [build] Error 1
~/mirage-skeleton/stackv4$ make
mirage build
ocamlfind ocamldep -package tcpip.udp -package tcpip.tcp -package tcpip.stack-direct -package tcpip.ipv4 -package tcpip.icmpv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-random -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -modules unikernel.ml &gt; unikernel.ml.depends
ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.udp -package tcpip.tcp -package tcpip.stack-direct -package tcpip.ipv4 -package tcpip.icmpv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-random -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o unikernel.cmo unikernel.ml
+ ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.udp -package tcpip.tcp -package tcpip.stack-direct -package tcpip.ipv4 -package tcpip.icmpv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-random -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o unikernel.cmo unikernel.ml
File &quot;unikernel.ml&quot;, line 33, characters 34-44:
Error: Unbound value T.get_dest
Command exited with code 2.
run ['ocamlbuild' '-use-ocamlfind' '-classic-display' '-tags'
     'predicate(mirage_unix),warn(A-4-41-42-44),color(always),debug,bin_annot,strict_sequence,principal,safe_string'
     '-pkgs'
     'functoria-runtime,lwt,mirage-clock-unix,mirage-console-unix,mirage-logs,mirage-net-unix,mirage-random,mirage-runtime,mirage-types,mirage-types-lwt,mirage-unix,tcpip,tcpip.arpv4,tcpip.ethif,tcpip.icmpv4,tcpip.ipv4,tcpip.stack-direct,tcpip.tcp,tcpip.udp'
     '-cflags' '-g' '-lflags' '-g' '-tag-line' '&lt;static*.*&gt;: warn(-32-34)'
     '-X' '_build-ukvm' 'main.native']: exited with 10
Makefile:18: recipe for target 'build' failed
make: *** [build] Error 1
</code></pre>
<p>The module <code>T</code> is the TCP module from the stack passed by <code>Mirage_stack_lwt.V4</code>.  The module type definition for <code>TCP</code> lives in <a href="http://docs.mirage.io/mirage-protocols/Mirage_protocols/module-type-TCP/index.html">mirage-protocols</a>, where we can find a <a href="http://docs.mirage.io/mirage-protocols/Mirage_protocols/module-type-TCP/index.html#val-dst">function named <code>dst</code></a> with which to replace the call to <code>get_dst</code>.  (This change is also noted in the <a href="https://github.com/mirage/mirage-tcpip/releases/tag/v3.0.0">mirage-tcpip version 3.0.0 release notes</a>.)  Replacing <code>get_dest</code> with <code>dst</code> gives us the following <code>unikernel.ml</code>:</p>
<pre><code>open Lwt.Infix
open Printf

let red fmt    = sprintf (&quot;\\027[31m&quot;^^fmt^^&quot;\\027[m&quot;)
let green fmt  = sprintf (&quot;\\027[32m&quot;^^fmt^^&quot;\\027[m&quot;)
let yellow fmt = sprintf (&quot;\\027[33m&quot;^^fmt^^&quot;\\027[m&quot;)
let blue fmt   = sprintf (&quot;\\027[36m&quot;^^fmt^^&quot;\\027[m&quot;)

module Main (C:Mirage_console_lwt.S) (S:Mirage_stack_lwt.V4) = struct

  module T  = S.TCPV4

  let start console s =

    let ips = List.map Ipaddr.V4.to_string (S.IPV4.get_ip (S.ipv4 s)) in
    C.log console (sprintf &quot;IP address: %s\\n&quot; (String.concat &quot;, &quot; ips))

    &gt;&gt;= fun () -&gt;
    let local_port = 53 in
    S.listen_udpv4 s ~port:local_port (
      fun ~src ~dst ~src_port buf -&gt;
        C.log console
          (red &quot;UDP %s:%d &gt; %s:%d: \\&quot;%s\\&quot;&quot;
             (Ipaddr.V4.to_string src) src_port
             (Ipaddr.V4.to_string dst) local_port
             (Cstruct.to_string buf))
    );

    let local_port = 8080 in
    S.listen_tcpv4 s ~port:local_port (
      fun flow -&gt;
        let remote, remote_port = T.dst flow in
        C.log console
          (green &quot;TCP %s:%d &gt; _:%d&quot;
             (Ipaddr.V4.to_string remote) remote_port local_port)

        &gt;&gt;= fun () -&gt;
        T.read flow

        &gt;&gt;= function
        | `Ok b -&gt;
          C.log console
            (yellow &quot;read: %d \\&quot;%s\\&quot;&quot; (Cstruct.len b) (Cstruct.to_string b))

          &gt;&gt;= fun () -&gt;
          T.close flow

        | `Eof -&gt; C.log console (red &quot;read: eof&quot;)
        | `Error _e -&gt; C.log console (red &quot;read: error&quot;)
    );

    S.listen s
end
</code></pre>
<p>which generates a new error:</p>
<pre><code>$ make
mirage build
ocamlfind ocamldep -package tcpip.udp -package tcpip.tcp -package tcpip.stack-direct -package tcpip.ipv4 -package tcpip.icmpv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-random -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -modules unikernel.ml &gt; unikernel.ml.depends
ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.udp -package tcpip.tcp -package tcpip.stack-direct -package tcpip.ipv4 -package tcpip.icmpv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-random -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o unikernel.cmo unikernel.ml
+ ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.udp -package tcpip.tcp -package tcpip.stack-direct -package tcpip.ipv4 -package tcpip.icmpv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-random -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o unikernel.cmo unikernel.ml
File &quot;unikernel.ml&quot;, line 41, characters 10-15:
Error: This pattern matches values of type
         [&lt; `Eof | `Error of 'a | `Ok of 'b ]
       but a pattern was expected which matches values of type
         (T.buffer Mirage_flow.or_eof, T.error) Result.result =
           (T.buffer Mirage_flow.or_eof, T.error) result
Command exited with code 2.
run ['ocamlbuild' '-use-ocamlfind' '-classic-display' '-tags'
     'predicate(mirage_unix),warn(A-4-41-42-44),color(always),debug,bin_annot,strict_sequence,principal,safe_string'
     '-pkgs'
     'functoria-runtime,lwt,mirage-clock-unix,mirage-console-unix,mirage-logs,mirage-net-unix,mirage-random,mirage-runtime,mirage-types,mirage-types-lwt,mirage-unix,tcpip,tcpip.arpv4,tcpip.ethif,tcpip.icmpv4,tcpip.ipv4,tcpip.stack-direct,tcpip.tcp,tcpip.udp'
     '-cflags' '-g' '-lflags' '-g' '-tag-line' '&lt;static*.*&gt;: warn(-32-34)'
     '-X' '_build-ukvm' 'main.native']: exited with 10
Makefile:18: recipe for target 'build' failed
make: *** [build] Error 1
</code></pre>
<h3>Mirage3 errors</h3>
<p>We get this build failure because the code expects <code>T.read</code> to return a value of type</p>
<pre><code>[&lt; `Eof | `Error of 'a | `Ok of 'b ]
</code></pre>
<p>but errors have been <a href="https://mirage.io/blog/mirage-3.0-errors">reworked in Mirage 3</a>.  <code>T.read</code>, and other functions like it, now return a value of type</p>
<pre><code>(T.buffer Mirage_flow.or_eof, T.error) result
</code></pre>
<p>We know that <code>T.buffer</code> is <code>Cstruct.t</code> from <a href="http://docs.mirage.io/mirage-protocols-lwt/Mirage_protocols_lwt/index.html#module-type-TCP"><code>Mirage_protocols_lwt.TCP</code></a>.  <a href="http://docs.mirage.io/mirage-flow/Mirage_flow/index.html#type-or_eof"><code>Mirage_flow.or_eof</code></a> is parameterized over that type, and <a href="http://docs.mirage.io/mirage-protocols/Mirage_protocols/module-type-TCP/index.html#type-error">T.error</a> is some superset of <a href="http://docs.mirage.io/mirage-protocols/Mirage_protocols/module-type-TCP/index.html#type-error">Tcp.error</a> so we can expect the type of <code>T.read</code>'s returned value to be</p>
<pre><code>Ok of (`Data of Cstruct.t)
Ok of `Eof
Error of `Timeout
Error of `Refused
Error of ???
</code></pre>
<p>where ??? is something that can be printed by <code>T.pp_error</code>, but the details of which we don't know.  We can change the <code>function</code> which is on the right of the <code>&gt;&gt;=</code> produced by <code>T.read</code> to comply with this error scheme:</p>
<pre><code>open Lwt.Infix
open Printf

let red fmt    = sprintf (&quot;\\027[31m&quot;^^fmt^^&quot;\\027[m&quot;)
let green fmt  = sprintf (&quot;\\027[32m&quot;^^fmt^^&quot;\\027[m&quot;)
let yellow fmt = sprintf (&quot;\\027[33m&quot;^^fmt^^&quot;\\027[m&quot;)
let blue fmt   = sprintf (&quot;\\027[36m&quot;^^fmt^^&quot;\\027[m&quot;)

module Main (C:Mirage_console_lwt.S) (S:Mirage_stack_lwt.V4) = struct

  module T  = S.TCPV4

  let start console s =

    let ips = List.map Ipaddr.V4.to_string (S.IPV4.get_ip (S.ipv4 s)) in
    C.log console (sprintf &quot;IP address: %s\\n&quot; (String.concat &quot;, &quot; ips))

    &gt;&gt;= fun () -&gt;
    let local_port = 53 in
    S.listen_udpv4 s ~port:local_port (
      fun ~src ~dst ~src_port buf -&gt;
        C.log console
          (red &quot;UDP %s:%d &gt; %s:%d: \\&quot;%s\\&quot;&quot;
             (Ipaddr.V4.to_string src) src_port
             (Ipaddr.V4.to_string dst) local_port
             (Cstruct.to_string buf))
    );

    let local_port = 8080 in
    S.listen_tcpv4 s ~port:local_port (
      fun flow -&gt;
        let remote, remote_port = T.dst flow in
        C.log console
          (green &quot;TCP %s:%d &gt; _:%d&quot;
             (Ipaddr.V4.to_string remote) remote_port local_port)

        &gt;&gt;= fun () -&gt;
        T.read flow

        &gt;&gt;= function
        | Ok (`Data b) -&gt;
          C.log console
            (yellow &quot;read: %d \\&quot;%s\\&quot;&quot; (Cstruct.len b) (Cstruct.to_string b))

          &gt;&gt;= fun () -&gt;
          T.close flow

        | Ok `Eof -&gt; C.log console (red &quot;read: eof&quot;)
        | Error _ -&gt; (* XXX: see next section for proper fix *)
    	  C.log console (red &quot;read: error&quot;)
    );

    S.listen s
end
</code></pre>
<p>and now, finally, <code>make</code> should produce a runnable binary.</p>
<h3>Using Logs and pp_error</h3>
<p>The error handling above is very unsatisfying, though, and so is the output -- for a toy application it's okay to output to the console, but for a unikernel which might be deployed to an arbitrary cloud service, console access isn't always a given.  Let's refactor this code to remove the <code>console</code> argument to the unikernel, and replace the calls to <code>C.log</code> with <code>Logs</code> calls of the appropriate level.</p>
<p>Our <code>config.ml</code> will look like this:</p>
<pre><code>open Mirage

let handler = foreign &quot;Unikernel.Main&quot; (stackv4 @-&gt; job)

let stack = generic_stackv4 default_network

let () =
  register &quot;stackv4&quot; [handler $ stack]
</code></pre>
<p>and then we'll need to change our <code>unikernel.ml</code> like so:</p>
<pre><code>open Lwt.Infix

module Main (S:Mirage_stack_lwt.V4) = struct

  module T  = S.TCPV4

  let start s =

    let ips = List.map Ipaddr.V4.to_string (S.IPV4.get_ip (S.ipv4 s)) in
    Logs.debug (fun f -&gt; f &quot;IP address: %s\\n&quot; (String.concat &quot;, &quot; ips));
    let local_port = 53 in
    S.listen_udpv4 s ~port:local_port (
      fun ~src ~dst ~src_port buf -&gt;
        Logs.info (fun f -&gt; f &quot;UDP traffic: %s:%d &gt; %s:%d&quot;
             (Ipaddr.V4.to_string src) src_port
             (Ipaddr.V4.to_string dst) local_port);
        Logs.debug (fun f -&gt; f
          &quot;UDP content: %S&quot;
             (Cstruct.to_string buf));
        Lwt.return_unit
    );

    let local_port = 8080 in
    S.listen_tcpv4 s ~port:local_port (
      fun flow -&gt;
        let remote, remote_port = T.dst flow in
        Logs.info (fun f -&gt; f &quot;new TCP connection: %s:%d &gt; _:%d&quot;
             (Ipaddr.V4.to_string remote) remote_port local_port);
        T.read flow

        &gt;&gt;= function
        | Ok (`Data b) -&gt;
          Logs.debug (fun f -&gt; f &quot;TCP content: %S&quot; (Cstruct.to_string b));
          Logs.info (fun f -&gt; f &quot;Closing connection to %s:%d&quot;
             (Ipaddr.V4.to_string remote) remote_port);
          T.close flow
        | Ok `Eof -&gt;
          Logs.info (fun f -&gt; f &quot;Remote side closed the connection to %s:%d.&quot;
             (Ipaddr.V4.to_string remote) remote_port);
          Lwt.return_unit
        | Error e -&gt; Logs.warn (fun f -&gt; f
            &quot;Error reading TCP connection with %s:%d: %a&quot;
            (Ipaddr.V4.to_string remote) remote_port
            T.pp_error e);
          Lwt.return_unit
    );

    S.listen s
end
</code></pre>
<p>We can remove the <code>open Printf</code> since we're no longer constructing any strings with <code>sprintf</code>, and now we can set the log level for this application at configure time or run time -- if we only want to see errors, we can choose to do so by asking for <code>-l *:warning</code>, and we can see a lot of debug output (from all layers, including the TCP/IP stack&quot;) by asking for <code>-l *:debug</code>.  We've also replaced the catchall error message with a call to <code>T.pp_error</code>, which will invoke the TCP module's error-printing function to give a string explaining any problems -- much nicer than the <code>read: error</code> output we would have gotten previously.</p>
<h2>Porting the ping example to Mirage 3</h2>
<p>To illustrate how to solve some more common problems, let's look at the <code>ping</code> example, which has the following <code>config.ml</code>:</p>
<pre><code class="language-ocaml">open Mirage

let main =
  let packages = [ &quot;tcpip&quot; ] in
  let libraries = [ &quot;tcpip.arpv4&quot;; &quot;tcpip.ethif&quot;; &quot;tcpip.ipv4&quot; ] in
  foreign
    ~libraries ~packages
    &quot;Unikernel.Main&quot; (console @-&gt; network @-&gt; clock @-&gt; time @-&gt; job)

let () =
  register &quot;ping&quot; [ main $ default_console $ tap0 $ default_clock $ default_time ]
</code></pre>
<p>Trying to <code>mirage configure</code> this fails:</p>
<pre><code>mirage-skeleton/ping$ mirage configure -t unix
mirage: unknown option `-t'.
Usage: mirage configure [OPTION]... 
Try `mirage configure --help' or `mirage --help' for more information.
error while executing ocamlbuild -use-ocamlfind -classic-display -tags
                        bin_annot -quiet -X _build-ukvm -pkg mirage
                        config.cmxs
+ ocamlfind ocamlc -c -bin-annot -package mirage -o config.cmo config.ml
File &quot;config.ml&quot;, line 7, characters 5-14:
Error: The function applied to this argument has type
         ?keys:Mirage.key list -&gt;
         ?deps:Mirage.abstract_impl list -&gt; 'a Functoria.impl
This argument cannot be applied with label ~libraries
Command exited with code 2.
Hint: Recursive traversal of subdirectories was not enabled for this build,
  as the working directory does not look like an ocamlbuild project (no
  '_tags' or 'myocamlbuild.ml' file). If you have modules in subdirectories,
  you should add the option &quot;-r&quot; or create an empty '_tags' file.
  
  To enable recursive traversal for some subdirectories only, you can use the
  following '_tags' file:
  
      true: -traverse
      &lt;dir1&gt; or &lt;dir2&gt;: traverse
</code></pre>
<p>because the function <code>foreign</code> no longer takes a <code>libraries</code> argument.</p>
<h3>Libraries and packages</h3>
<p><code>libraries</code> and <code>packages</code> were two optional string list arguments in Mirageversions &gt;= 2.7.x but &lt; 3.x.  <code>libraries</code> was for <code>ocamlfind</code> libraries, and <code>packages</code> for OPAM packages; both string lists were simply fed <code>ocamlfind</code> and <code>opam</code> commands respectively.</p>
<p>The <a href="http://docs.mirage.io/mirage/Mirage/index.html#val-foreign">documentation for <code>foreign</code></a> will be a useful reference for us.  In Mirage 3, <code>packages</code> is now a variable of type <code>package list</code>.  One can get a <code>package</code> by calling <a href="http://docs.mirage.io/functoria/Functoria/index.html#pkg">Mirage.package</a>, which has the following signature:</p>
<pre><code>val package : ?build:bool -&gt; ?sublibs:string list -&gt; ?ocamlfind:string list -&gt; ?min:string -&gt; ?max:string -&gt; string -&gt; package
</code></pre>
<p><code>ping</code> needs <code>tcpip</code> and the sublibraries <code>arpv4</code>, <code>ethif</code>, and <code>ipv4</code>, so we'll try the following <code>config.ml</code>:</p>
<pre><code class="language-ocaml">open Mirage

let main =
  let packages = [package ~sublibs:[&quot;arpv4&quot;;&quot;ethif&quot;;&quot;ipv4&quot;] &quot;tcpip&quot; ] in
  foreign
    ~packages
    &quot;Unikernel.Main&quot; (console @-&gt; network @-&gt; clock @-&gt; time @-&gt; job)

let () =
  register &quot;ping&quot; [ main $ default_console $ tap0 $ default_clock $ default_time ]
</code></pre>
<p>and with that, we can get to our next problem:</p>
<pre><code>mirage-skeleton/ping$ mirage configure -t unix
mirage: unknown option `-t'.
Usage: mirage configure [OPTION]... 
Try `mirage configure --help' or `mirage --help' for more information.
error while executing ocamlbuild -use-ocamlfind -classic-display -tags
                        bin_annot -quiet -X _build-ukvm -pkg mirage
                        config.cmxs
+ ocamlfind ocamlc -c -bin-annot -package mirage -o config.cmo config.ml
File &quot;config.ml&quot;, line 7, characters 46-51:
Error: Unbound value clock
Hint: Did you mean pclock, mclock or block?
Command exited with code 2.
Hint: Recursive traversal of subdirectories was not enabled for this build,
  as the working directory does not look like an ocamlbuild project (no
  '_tags' or 'myocamlbuild.ml' file). If you have modules in subdirectories,
  you should add the option &quot;-r&quot; or create an empty '_tags' file.
  
  To enable recursive traversal for some subdirectories only, you can use the
  following '_tags' file:
  
      true: -traverse
      &lt;dir1&gt; or &lt;dir2&gt;: traverse
</code></pre>
<h3>CLOCKs, PCLOCKs, and MCLOCKs</h3>
<p>In Mirage3, the catchall <code>CLOCK</code> module type was replaced with two distinct types of clock modules: <code>PCLOCK</code>, a POSIX-compatible wall clock, and <code>MCLOCK</code>, a monotonically increasing counter.  In our experience porting MirageOS libraries, nearly all users of <code>CLOCK</code> wanted something like <code>MCLOCK</code> rather than something like <code>PCLOCK</code>.</p>
<p>In the case of <code>ping</code>, we only want to pass the module to <code>Arpv4.Make</code>.  The <a href="http://docs.mirage.io/tcpip/Arpv4/Make/index.html">signature for Arpv4.Make</a> in version 3.0 asks for an <code>MCLOCK</code>, so we'll include an <code>mclock</code> in the arguments to <code>foreign</code>.  In <code>register</code>, we'll use <a href="http://docs.mirage.io/mirage/Mirage/index.html#val-default_monotonic_clock"><code>default_monotonic_clock</code></a>.  Our <code>config.ml</code> will look like:</p>
<pre><code class="language-ocaml">$ cat config.ml
open Mirage

let main =
  let packages = [package ~sublibs:[&quot;arpv4&quot;;&quot;ethif&quot;;&quot;ipv4&quot;] &quot;tcpip&quot; ] in
  foreign
    ~packages
    &quot;Unikernel.Main&quot; (console @-&gt; network @-&gt; clock @-&gt; time @-&gt; job)

let () =
  register &quot;ping&quot; [ main $ default_console $ tap0 $ default_clock $ default_time ]
</code></pre>
<p>Trying to <code>mirage configure</code> this gives us an error message because we're still trying to call <code>tap0</code>, which we learned in the last example has been replaced with <code>default_network</code>.  Let's fix that up, to get the following <code>config.ml</code>:</p>
<pre><code class="language-ocaml">open Mirage

let main =
  let packages = [package ~sublibs:[&quot;arpv4&quot;;&quot;ethif&quot;;&quot;ipv4&quot;] &quot;tcpip&quot; ] in
  foreign
    ~packages
    &quot;Unikernel.Main&quot; (console @-&gt; network @-&gt; mclock @-&gt; time @-&gt; job)

let () =
  register &quot;ping&quot; [ main $ default_console $ default_network $ default_monotonic_clock $ default_time ]
</code></pre>
<p>and now we can run <code>mirage configure</code> successfully.  In order to build the unikernel, we'll need to make a few additional changes, as noticed by <code>make depend &amp;&amp; make</code>:</p>
<pre><code>mirage-skeleton/ping$ make depend &amp;&amp; make
opam pin add --no-action --yes mirage-unikernel-ping-unix .
Package mirage-unikernel-ping-unix does not exist, create as a NEW package ? [Y/n] y
mirage-unikernel-ping-unix is now path-pinned to /home/user/mirage-skeleton/ping

[mirage-unikernel-ping-unix] /home/user/mirage-skeleton/ping/ synchronized
[mirage-unikernel-ping-unix] Installing new package description from
/home/user/mirage-skeleton/ping

opam depext --yes mirage-unikernel-ping-unix
# Detecting depexts using flags: x86_64 linux debian
# The following system packages are needed:
#  - debianutils
#  - m4
#  - ncurses-dev
#  - pkg-config
#  - time
# All required OS packages found.
opam install --yes --deps-only mirage-unikernel-ping-unix

=-=- Synchronising pinned packages =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
[mirage-unikernel-ping-unix] /home/user/mirage-skeleton/ping/ already up-to-date
4opam pin remove --no-action mirage-unikernel-ping-unix
mirage-unikernel-ping-unix is now unpinned from path /home/user/mirage-skeleton/ping
mirage build
ocamlfind ocamldep -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -modules main.ml &gt; main.ml.depends
ocamlfind ocamldep -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -modules key_gen.ml &gt; key_gen.ml.depends
ocamlfind ocamldep -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -modules unikernel.ml &gt; unikernel.ml.depends
ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o key_gen.cmo key_gen.ml
ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o unikernel.cmo unikernel.ml
+ ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o unikernel.cmo unikernel.ml
File &quot;unikernel.ml&quot;, line 12, characters 15-22:
Error: Unbound module type CONSOLE
Command exited with code 2.
run ['ocamlbuild' '-use-ocamlfind' '-classic-display' '-tags'
     'predicate(mirage_unix),warn(A-4-41-42-44),color(always),debug,bin_annot,strict_sequence,principal,safe_string'
     '-pkgs'
     'functoria-runtime,lwt,mirage-clock-unix,mirage-console-unix,mirage-logs,mirage-net-unix,mirage-runtime,mirage-types,mirage-types-lwt,mirage-unix,tcpip,tcpip.arpv4,tcpip.ethif,tcpip.ipv4'
     '-cflags' '-g' '-lflags' '-g' '-tag-line' '&lt;static*.*&gt;: warn(-32-34)'
     '-X' '_build-ukvm' 'main.native']: exited with 10
Makefile:18: recipe for target 'build' failed
make: *** [build] Error 1
</code></pre>
<p>We need to make many of the changes mentioned in the example above, so let's get started:</p>
<h3>V1_LWT -&gt; relevant disaggregated modules</h3>
<p>We'll use <code>Mirage_console_lwt.S</code> instead of <code>V1_LWT.CONSOLE</code>, replace <code>V1_LWT.NETWORK</code> with <code>Mirage_net_lwt.S</code>, choose <code>Mirage_clock_lwt.MCLOCK</code> as the module type we want to replace <code>V1_LWT.CLOCK</code>, and use <code>Mirage_time_lwt.S</code> in place of <code>V1_LWT.TIME</code> to get the following <code>unikernel.ml</code>:</p>
<pre><code>open Lwt.Infix

let red fmt    = Printf.sprintf (&quot;\\027[31m&quot;^^fmt^^&quot;\\027[m&quot;)
let green fmt  = Printf.sprintf (&quot;\\027[32m&quot;^^fmt^^&quot;\\027[m&quot;)
let yellow fmt = Printf.sprintf (&quot;\\027[33m&quot;^^fmt^^&quot;\\027[m&quot;)
let blue fmt   = Printf.sprintf (&quot;\\027[36m&quot;^^fmt^^&quot;\\027[m&quot;)

let ipaddr   = &quot;10.0.0.2&quot;
let netmask  = &quot;255.255.255.0&quot;
let gateways = [&quot;10.0.0.1&quot;]

module Main (C:Mirage_console_lwt.S)
            (N:Mirage_net_lwt.S)
            (Clock: Mirage_clock_lwt.MCLOCK)
            (Time: Mirage_time_lwt.S) = struct

  module E = Ethif.Make(N)
  module A = Arpv4.Make(E)(Clock)(Time)
  module I = Ipv4.Make(E)(A)

  let or_error _c name fn t =
    fn t
    &gt;&gt;= function
    | `Error _e -&gt; Lwt.fail (Failure (&quot;Error starting &quot; ^ name))
    | `Ok t     -&gt; Lwt.return t

  let start c n _clock _time =
    C.log c (green &quot;starting...&quot;);
    or_error c &quot;Ethif&quot; E.connect n &gt;&gt;= fun e -&gt;
    or_error c &quot;Arpv4&quot; A.connect e &gt;&gt;= fun a -&gt;
    or_error c &quot;Ipv4&quot; (I.connect e) a &gt;&gt;= fun i -&gt;

    I.set_ip i (Ipaddr.V4.of_string_exn ipaddr) &gt;&gt;= fun () -&gt;
    I.set_ip_netmask i (Ipaddr.V4.of_string_exn netmask) &gt;&gt;= fun () -&gt;
    I.set_ip_gateways i (List.map Ipaddr.V4.of_string_exn gateways)
    &gt;&gt;= fun () -&gt;

    let handler s = fun ~src ~dst _data -&gt;
      C.log_s c (yellow &quot;%s &gt; %s %s&quot;
                   (Ipaddr.V4.to_string src) (Ipaddr.V4.to_string dst) s);
      Lwt.return_unit
    in
    N.listen n
      (E.input
         ~arpv4:(A.input a)
         ~ipv4:(I.input
                  ~tcp:(handler &quot;TCP&quot;)
                  ~udp:(handler &quot;UDP&quot;)
                  ~default:(fun ~proto ~src:_ ~dst:_ _data -&gt;
                      C.log_s c (red &quot;%d DEFAULT&quot; proto))
                  i
               )
         ~ipv6:(fun _buf -&gt; Lwt.return (C.log c (red &quot;IP6&quot;)))
         e)
    &gt;&gt;= fun () -&gt;
    C.log c (green &quot;done!&quot;);
    Lwt.return ()

end
</code></pre>
<p>to get our next problem:</p>
<pre><code>mirage-skeleton/ping$ make
mirage build
ocamlfind ocamldep -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -modules main.ml &gt; main.ml.depends
ocamlfind ocamldep -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -modules key_gen.ml &gt; key_gen.ml.depends
ocamlfind ocamldep -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -modules unikernel.ml &gt; unikernel.ml.depends
ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o key_gen.cmo key_gen.ml
ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o unikernel.cmo unikernel.ml
+ ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-console-unix -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o unikernel.cmo unikernel.ml
File &quot;unikernel.ml&quot;, line 19, characters 13-22:
Error: Unbound module Ipv4
</code></pre>
<h4>Ipv4 -&gt; Static_ipv4</h4>
<p><code>mirage-tcpip</code> renamed the <code>Ipv4</code> module to <code>Static_ipv4</code>, as part of a larger reorganization of how IP configuration works.  (You can read more in the <a href="https://github.com/mirage/mirage-tcpip/releases/tag/v3.0.0">release notes for mirage-tcpip version 3.0.0</a>.)  Since our unikernel isn't using the <code>generic_stackv4</code> function but rather calling the functors that make a stack directly, it has to know about this name change.  We'll tell it, to make the following <code>unikernel.ml</code>:</p>
<pre><code class="language-ocaml">
pen Lwt.Infix

let red fmt    = Printf.sprintf (&quot;\\027[31m&quot;^^fmt^^&quot;\\027[m&quot;)
let green fmt  = Printf.sprintf (&quot;\\027[32m&quot;^^fmt^^&quot;\\027[m&quot;)
let yellow fmt = Printf.sprintf (&quot;\\027[33m&quot;^^fmt^^&quot;\\027[m&quot;)
let blue fmt   = Printf.sprintf (&quot;\\027[36m&quot;^^fmt^^&quot;\\027[m&quot;)

let ipaddr   = &quot;10.0.0.2&quot;
let netmask  = &quot;255.255.255.0&quot;
let gateways = [&quot;10.0.0.1&quot;]

module Main (C:Mirage_console_lwt.S)
            (N:Mirage_net_lwt.S)
            (Clock: Mirage_clock_lwt.MCLOCK)
            (Time: Mirage_time_lwt.S) = struct

  module E = Ethif.Make(N)
  module A = Arpv4.Make(E)(Clock)(Time)
  module I = Static_ipv4.Make(E)(A)

  let or_error _c name fn t =
    fn t
    &gt;&gt;= function
    | `Error _e -&gt; Lwt.fail (Failure (&quot;Error starting &quot; ^ name))
    | `Ok t     -&gt; Lwt.return t

  let start c n _clock _time =
    C.log c (green &quot;starting...&quot;);
    or_error c &quot;Ethif&quot; E.connect n &gt;&gt;= fun e -&gt;
    or_error c &quot;Arpv4&quot; A.connect e &gt;&gt;= fun a -&gt;
    or_error c &quot;Ipv4&quot; (I.connect e) a &gt;&gt;= fun i -&gt;

    I.set_ip i (Ipaddr.V4.of_string_exn ipaddr) &gt;&gt;= fun () -&gt;
    I.set_ip_netmask i (Ipaddr.V4.of_string_exn netmask) &gt;&gt;= fun () -&gt;
    I.set_ip_gateways i (List.map Ipaddr.V4.of_string_exn gateways)
    &gt;&gt;= fun () -&gt;

    let handler s = fun ~src ~dst _data -&gt;
      C.log_s c (yellow &quot;%s &gt; %s %s&quot;
                   (Ipaddr.V4.to_string src) (Ipaddr.V4.to_string dst) s);
      Lwt.return_unit
    in
    N.listen n
      (E.input
         ~arpv4:(A.input a)
         ~ipv4:(I.input
                  ~tcp:(handler &quot;TCP&quot;)
                  ~udp:(handler &quot;UDP&quot;)
                  ~default:(fun ~proto ~src:_ ~dst:_ _data -&gt;
                      C.log_s c (red &quot;%d DEFAULT&quot; proto))
                  i
               )
         ~ipv6:(fun _buf -&gt; Lwt.return (C.log c (red &quot;IP6&quot;)))
         e)
    &gt;&gt;= fun () -&gt;
    C.log c (green &quot;done!&quot;);
    Lwt.return ()

end
</code></pre>
<h3>Old ground: CONSOLE -&gt; logs</h3>
<p>When we try to <code>make</code> this unikernel, we get a familiar error message about <code>C.log_s</code>.  Let's replace the calls to <code>C.log_s</code> with calls to the appropriate <code>Logs</code> functions, like we did in the previous example, to get the following <code>config.ml</code> that no longer passes a console:</p>
<pre><code class="language-ocaml">open Mirage

let main =
  let packages = [package ~sublibs:[&quot;arpv4&quot;;&quot;ethif&quot;;&quot;ipv4&quot;] &quot;tcpip&quot; ] in
  foreign
    ~packages
    &quot;Unikernel.Main&quot; (network @-&gt; mclock @-&gt; time @-&gt; job)

let () =
  register &quot;ping&quot; [ main $ default_network $ default_monotonic_clock $ default_time ]
</code></pre>
<p>And a matching <code>unikernel.ml</code>, from which we've removed the color functions <code>red</code>, <code>green</code>, <code>yellow</code>, and <code>blue</code>, removed the unused <code>_c</code> argument from <code>or_error</code>, replaced <code>C.log</code> and <code>C.log_s</code> with <code>Logs</code> calls, removed the <code>C:Mirage_console_lwt.S</code> module argument to <code>Main</code>, and removed the <code>c</code> argument from <code>start</code>:</p>
<pre><code class="language-ocaml">open Lwt.Infix

let ipaddr   = &quot;10.0.0.2&quot;
let netmask  = &quot;255.255.255.0&quot;
let gateways = [&quot;10.0.0.1&quot;]

module Main (N:Mirage_net_lwt.S)
            (Clock: Mirage_clock_lwt.MCLOCK)
            (Time: Mirage_time_lwt.S) = struct

  module E = Ethif.Make(N)
  module A = Arpv4.Make(E)(Clock)(Time)
  module I = Static_ipv4.Make(E)(A)

  let or_error name fn t =
    fn t
    &gt;&gt;= function
    | `Error _e -&gt; Lwt.fail (Failure (&quot;Error starting &quot; ^ name))
    | `Ok t     -&gt; Lwt.return t

  let start n _clock _time =
    Logs.debug (fun f -&gt; f &quot;starting...&quot;);
    or_error &quot;Ethif&quot; E.connect n &gt;&gt;= fun e -&gt;
    or_error &quot;Arpv4&quot; A.connect e &gt;&gt;= fun a -&gt;
    or_error &quot;Ipv4&quot; (I.connect e) a &gt;&gt;= fun i -&gt;

    I.set_ip i (Ipaddr.V4.of_string_exn ipaddr) &gt;&gt;= fun () -&gt;
    I.set_ip_netmask i (Ipaddr.V4.of_string_exn netmask) &gt;&gt;= fun () -&gt;
    I.set_ip_gateways i (List.map Ipaddr.V4.of_string_exn gateways)
    &gt;&gt;= fun () -&gt;

    let handler s = fun ~src ~dst _data -&gt;
      Logs.info (fun f -&gt; f &quot;%s &gt; %s %s&quot;
                   (Ipaddr.V4.to_string src) (Ipaddr.V4.to_string dst) s);
      Lwt.return_unit
    in
    N.listen n
      (E.input
         ~arpv4:(A.input a)
         ~ipv4:(I.input
                  ~tcp:(handler &quot;TCP&quot;)
                  ~udp:(handler &quot;UDP&quot;)
                  ~default:(fun ~proto ~src:_ ~dst:_ _data -&gt;
                      Lwt.return (Logs.warn (fun f -&gt; f &quot;%d DEFAULT&quot; proto)))
                  i
               )
         ~ipv6:(fun _buf -&gt; Lwt.return (Logs.warn (fun f -&gt; f &quot;%s&quot; &quot;IP6&quot;)))
         e)
    &gt;&gt;= fun () -&gt;
    Logs.info (fun f -&gt; f &quot;done!&quot;);
    Lwt.return ()

end
</code></pre>
<p>Let's see what happens next:</p>
<pre><code>mirage-skeleton/ping$ make depend &amp;&amp; make
opam pin add --no-action --yes mirage-unikernel-ping-unix .
Package mirage-unikernel-ping-unix does not exist, create as a NEW
package ? [Y/n] y
mirage-unikernel-ping-unix is now path-pinned to /home/user/mirage-skeleton/ping

[mirage-unikernel-ping-unix] /home/user/mirage-skeleton/ping/ synchronized
[mirage-unikernel-ping-unix] Installing new package description from
/home/user/mirage-skeleton/ping

opam depext --yes mirage-unikernel-ping-unix
# Detecting depexts using flags: x86_64 linux debian
# The following system packages are needed:
#  - debianutils
#  - m4
#  - ncurses-dev
#  - pkg-config
#  - time
# All required OS packages found.
opam install --yes --deps-only mirage-unikernel-ping-unix

=-=- Synchronising pinned packages =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
[mirage-unikernel-ping-unix] /home/user/mirage-skeleton/ping/ already up-to-date
opam pin remove --no-action mirage-unikernel-ping-unix
mirage-unikernel-ping-unix is now unpinned from path /home/user/mirage-skeleton/ping
mirage build
ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o unikernel.cmo unikernel.ml
+ ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o unikernel.cmo unikernel.ml
File &quot;unikernel.ml&quot;, line 23, characters 21-30:
Error: This expression has type E.netif -&gt; E.t Lwt.t
       but an expression was expected of type
         E.netif -&gt; ([&lt; `Error of 'b | `Ok of 'c ] as 'a) Lwt.t
       Type E.t = Ethif.Make(N).t is not compatible with type
         [&lt; `Error of 'b | `Ok of 'c ] as 'a 
Command exited with code 2.
run ['ocamlbuild' '-use-ocamlfind' '-classic-display' '-tags'
     'predicate(mirage_unix),warn(A-4-41-42-44),color(always),debug,bin_annot,strict_sequence,principal,safe_string'
     '-pkgs'
     'functoria-runtime,lwt,mirage-clock-unix,mirage-logs,mirage-net-unix,mirage-runtime,mirage-types,mirage-types-lwt,mirage-unix,tcpip,tcpip.arpv4,tcpip.ethif,tcpip.ipv4'
     '-cflags' '-g' '-lflags' '-g' '-tag-line' '&lt;static*.*&gt;: warn(-32-34)'
     '-X' '_build-ukvm' 'main.native']: exited with 10
Makefile:18: recipe for target 'build' failed
make: *** [build] Error 1
</code></pre>
<h3><code>connect</code> connects directly</h3>
<p>The <code>connect</code> functions that we're directly invoking no longer return a polymorphic variant, but rather will raise an exception if a problem occurred.  Therefore, we no longer need to wrap them in <code>or_error</code>, so we can remove that function from <code>unikernel.ml</code>:</p>
<pre><code>open Lwt.Infix

let ipaddr   = &quot;10.0.0.2&quot;
let netmask  = &quot;255.255.255.0&quot;
let gateways = [&quot;10.0.0.1&quot;]

module Main (N:Mirage_net_lwt.S)
            (Clock: Mirage_clock_lwt.MCLOCK)
            (Time: Mirage_time_lwt.S) = struct

  module E = Ethif.Make(N)
  module A = Arpv4.Make(E)(Clock)(Time)
  module I = Static_ipv4.Make(E)(A)

  let start n _clock _time =
    Logs.debug (fun f -&gt; f &quot;starting...&quot;);
    E.connect n &gt;&gt;= fun e -&gt;
    A.connect e &gt;&gt;= fun a -&gt;
    I.connect e a &gt;&gt;= fun i -&gt;

    I.set_ip i (Ipaddr.V4.of_string_exn ipaddr) &gt;&gt;= fun () -&gt;
    I.set_ip_netmask i (Ipaddr.V4.of_string_exn netmask) &gt;&gt;= fun () -&gt;
    I.set_ip_gateways i (List.map Ipaddr.V4.of_string_exn gateways)
    &gt;&gt;= fun () -&gt;

    let handler s = fun ~src ~dst _data -&gt;
      Logs.info (fun f -&gt; f &quot;%s &gt; %s %s&quot;
                   (Ipaddr.V4.to_string src) (Ipaddr.V4.to_string dst) s);
      Lwt.return_unit
    in
    N.listen n
      (E.input
         ~arpv4:(A.input a)
         ~ipv4:(I.input
                  ~tcp:(handler &quot;TCP&quot;)
                  ~udp:(handler &quot;UDP&quot;)
                  ~default:(fun ~proto ~src:_ ~dst:_ _data -&gt;
                      Lwt.return (Logs.warn (fun f -&gt; f &quot;%d DEFAULT&quot; proto)))
                  i
               )
         ~ipv6:(fun _buf -&gt; Lwt.return (Logs.warn (fun f -&gt; f &quot;%s&quot; &quot;IP6&quot;)))
         e)
    &gt;&gt;= fun () -&gt;
    Logs.info (fun f -&gt; f &quot;done!&quot;);
    Lwt.return ()

end
</code></pre>
<p>For our next trick, we'll solve a new problem:</p>
<pre><code>mirage-skeleton/ping$ make
mirage build
ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o unikernel.cmo unikernel.ml
+ ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o unikernel.cmo unikernel.ml
File &quot;unikernel.ml&quot;, line 18, characters 4-15:
Error: This expression has type Clock.t -&gt; A.t Lwt.t
       but an expression was expected of type 'a Lwt.t
Command exited with code 2.
run ['ocamlbuild' '-use-ocamlfind' '-classic-display' '-tags'
     'predicate(mirage_unix),warn(A-4-41-42-44),color(always),debug,bin_annot,strict_sequence,principal,safe_string'
     '-pkgs'
     'functoria-runtime,lwt,mirage-clock-unix,mirage-logs,mirage-net-unix,mirage-runtime,mirage-types,mirage-types-lwt,mirage-unix,tcpip,tcpip.arpv4,tcpip.ethif,tcpip.ipv4'
     '-cflags' '-g' '-lflags' '-g' '-tag-line' '&lt;static*.*&gt;: warn(-32-34)'
     '-X' '_build-ukvm' 'main.native']: exited with 10
Makefile:18: recipe for target 'build' failed
make: *** [build] Error 1
</code></pre>
<h3>Another tcpip function change</h3>
<p>Line 18 is the call to <code>A.connect</code>.  The documentation for <a href="http://docs.mirage.io/tcpip/Arpv4/Make/index.html">the Arpv4 module in mirage-tcpip</a>, which we're invoking directly, has a <a href="http://docs.mirage.io/tcpip/Arpv4/Make/index.html#val-connect">connect function</a> that expects a <code>Clock.t</code>, where <code>Clock</code> is the second module which was passed to <code>Arpv4.Make</code>.  The unikernel receives such a <code>Clock.t</code> as an argument to <code>start</code>, but it's currently ignoring it.  Let's edit <code>unikernel.ml</code> to stop ignoring <code>_clock</code>, and pass it as an argument to <code>A.connect</code>:</p>
<pre><code class="language-ocaml">open Lwt.Infix

let ipaddr   = &quot;10.0.0.2&quot;
let netmask  = &quot;255.255.255.0&quot;
let gateways = [&quot;10.0.0.1&quot;]

module Main (N:Mirage_net_lwt.S)
            (Clock: Mirage_clock_lwt.MCLOCK)
            (Time: Mirage_time_lwt.S) = struct

  module E = Ethif.Make(N)
  module A = Arpv4.Make(E)(Clock)(Time)
  module I = Static_ipv4.Make(E)(A)

  let start n clock _time =
    Logs.debug (fun f -&gt; f &quot;starting...&quot;);
    E.connect n &gt;&gt;= fun e -&gt;
    A.connect e clock &gt;&gt;= fun a -&gt;
    I.connect e a &gt;&gt;= fun i -&gt;

    I.set_ip i (Ipaddr.V4.of_string_exn ipaddr) &gt;&gt;= fun () -&gt;
    I.set_ip_netmask i (Ipaddr.V4.of_string_exn netmask) &gt;&gt;= fun () -&gt;
    I.set_ip_gateways i (List.map Ipaddr.V4.of_string_exn gateways)
    &gt;&gt;= fun () -&gt;

    let handler s = fun ~src ~dst _data -&gt;
      Logs.info (fun f -&gt; f &quot;%s &gt; %s %s&quot;
                   (Ipaddr.V4.to_string src) (Ipaddr.V4.to_string dst) s);
      Lwt.return_unit
    in
    N.listen n
      (E.input
         ~arpv4:(A.input a)
         ~ipv4:(I.input
                  ~tcp:(handler &quot;TCP&quot;)
                  ~udp:(handler &quot;UDP&quot;)
                  ~default:(fun ~proto ~src:_ ~dst:_ _data -&gt;
                      Lwt.return (Logs.warn (fun f -&gt; f &quot;%d DEFAULT&quot; proto)))
                  i
               )
         ~ipv6:(fun _buf -&gt; Lwt.return (Logs.warn (fun f -&gt; f &quot;%s&quot; &quot;IP6&quot;)))
         e)
    &gt;&gt;= fun () -&gt;
    Logs.info (fun f -&gt; f &quot;done!&quot;);
    Lwt.return ()

end
</code></pre>
<p>Next, we'll find some difficulties with the functions we're trying to call from <code>I</code>:</p>
<pre><code>~/mirage-skeleton/ping$ make
mirage build
ocamlfind ocamldep -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -modules unikernel.ml &gt; unikernel.ml.depends
ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o unikernel.cmo unikernel.ml
+ ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o unikernel.cmo unikernel.ml
File &quot;unikernel.ml&quot;, line 22, characters 4-20:
Error: Unbound value I.set_ip_netmask
Command exited with code 2.
run ['ocamlbuild' '-use-ocamlfind' '-classic-display' '-tags'
     'predicate(mirage_unix),warn(A-4-41-42-44),color(always),debug,bin_annot,strict_sequence,principal,safe_string'
     '-pkgs'
     'functoria-runtime,lwt,mirage-clock-unix,mirage-logs,mirage-net-unix,mirage-runtime,mirage-types,mirage-types-lwt,mirage-unix,tcpip,tcpip.arpv4,tcpip.ethif,tcpip.ipv4'
     '-cflags' '-g' '-lflags' '-g' '-tag-line' '&lt;static*.*&gt;: warn(-32-34)'
     '-X' '_build-ukvm' 'main.native']: exited with 10
Makefile:18: recipe for target 'build' failed
make: *** [build] Error 1
</code></pre>
<h3>Ipv4 configuration</h3>
<p>The <code>IP</code> module type no longer allows for mutable IP configuration settings.  <a href="http://docs.mirage.io/tcpip/Static_ipv4/Make/index.html#val-connect">The type signature for <code>I.connect</code></a> shows that, with some help from <a href="http://docs.mirage.io/ipaddr/Ipaddr/V4/index.html">Ipaddr.V4</a> and a bit of adjustment <code>gateway</code> being <code>Ipaddr.V4.t option</code> rather than <code>Ipaddr.V4.t list</code> as <code>I.set_ip_gateways</code> previously expected, we can set the values directly when invoking <code>I.connect</code> from <code>unikernel.ml</code>:</p>
<pre><code>
pen Lwt.Infix

let ipaddr   = &quot;10.0.0.2/24&quot;
let gateway  = &quot;10.0.0.1&quot;

module Main (N:Mirage_net_lwt.S)
            (Clock: Mirage_clock_lwt.MCLOCK)
            (Time: Mirage_time_lwt.S) = struct

  module E = Ethif.Make(N)
  module A = Arpv4.Make(E)(Clock)(Time)
  module I = Static_ipv4.Make(E)(A)

  let start n clock _time =
    Logs.debug (fun f -&gt; f &quot;starting...&quot;);
    E.connect n &gt;&gt;= fun e -&gt;
    A.connect e clock &gt;&gt;= fun a -&gt;
    I.connect ~ip:(snd @@ Ipaddr.V4.Prefix.of_address_string_exn ipaddr)
              ~network:(fst @@ Ipaddr.V4.Prefix.of_address_string_exn ipaddr)
              ~gateway:(Some (Ipaddr.V4.of_string_exn gateway))
    e a &gt;&gt;= fun i -&gt;

    let handler s = fun ~src ~dst _data -&gt;
      Logs.info (fun f -&gt; f &quot;%s &gt; %s %s&quot;
                   (Ipaddr.V4.to_string src) (Ipaddr.V4.to_string dst) s);
      Lwt.return_unit
    in
    N.listen n
      (E.input
         ~arpv4:(A.input a)
         ~ipv4:(I.input
                  ~tcp:(handler &quot;TCP&quot;)
                  ~udp:(handler &quot;UDP&quot;)
                  ~default:(fun ~proto ~src:_ ~dst:_ _data -&gt;
                      Lwt.return (Logs.warn (fun f -&gt; f &quot;%d DEFAULT&quot; proto)))
                  i
               )
         ~ipv6:(fun _buf -&gt; Lwt.return (Logs.warn (fun f -&gt; f &quot;%s&quot; &quot;IP6&quot;)))
         e)
    &gt;&gt;= fun () -&gt;
    Logs.info (fun f -&gt; f &quot;done!&quot;);
    Lwt.return ()

end
</code></pre>
<p>Let's see how we do:</p>
<pre><code>mirage-skeleton/ping$ make
mirage build
ocamlfind ocamldep -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -modules unikernel.ml &gt; unikernel.ml.depends
ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o unikernel.cmo unikernel.ml
+ ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o unikernel.cmo unikernel.ml
File &quot;unikernel.ml&quot;, line 40, characters 12-14:
Error: This pattern matches values of type unit
       but a pattern was expected which matches values of type
         (unit, N.error) Result.result = (unit, N.error) result
Command exited with code 2.
run ['ocamlbuild' '-use-ocamlfind' '-classic-display' '-tags'
     'predicate(mirage_unix),warn(A-4-41-42-44),color(always),debug,bin_annot,strict_sequence,principal,safe_string'
     '-pkgs'
     'functoria-runtime,lwt,mirage-clock-unix,mirage-logs,mirage-net-unix,mirage-runtime,mirage-types,mirage-types-lwt,mirage-unix,tcpip,tcpip.arpv4,tcpip.ethif,tcpip.ipv4'
     '-cflags' '-g' '-lflags' '-g' '-tag-line' '&lt;static*.*&gt;: warn(-32-34)'
     '-X' '_build-ukvm' 'main.native']: exited with 10
Makefile:18: recipe for target 'build' failed
make: *** [build] Error 1
</code></pre>
<h3>N.listen is error-aware</h3>
<p>Our error message tells us that <code>N.listen</code> can now return an error, so our function that expects it to return <code>unit</code> is no longer valid.  We can fix this problem by changing the function on the right-hand side of the <code>&gt;&gt;=</code> following the call to <code>listen</code> to be a function that matches on the possible values, as we did for <code>T.read</code> in the previous example:</p>
<pre><code>open Lwt.Infix

let ipaddr   = &quot;10.0.0.2/24&quot;
let gateway  = &quot;10.0.0.1&quot;

module Main (N:Mirage_net_lwt.S)
            (Clock: Mirage_clock_lwt.MCLOCK)
            (Time: Mirage_time_lwt.S) = struct

  module E = Ethif.Make(N)
  module A = Arpv4.Make(E)(Clock)(Time)
  module I = Static_ipv4.Make(E)(A)

  let start n clock _time =
    Logs.debug (fun f -&gt; f &quot;starting...&quot;);
    E.connect n &gt;&gt;= fun e -&gt;
    A.connect e clock &gt;&gt;= fun a -&gt;
    I.connect ~ip:(snd @@ Ipaddr.V4.Prefix.of_address_string_exn ipaddr)
              ~network:(fst @@ Ipaddr.V4.Prefix.of_address_string_exn ipaddr)
              ~gateway:(Some (Ipaddr.V4.of_string_exn gateway))
    e a &gt;&gt;= fun i -&gt;

    let handler s = fun ~src ~dst _data -&gt;
      Logs.info (fun f -&gt; f &quot;%s &gt; %s %s&quot;
                   (Ipaddr.V4.to_string src) (Ipaddr.V4.to_string dst) s);
      Lwt.return_unit
    in
    N.listen n
      (E.input
         ~arpv4:(A.input a)
         ~ipv4:(I.input
                  ~tcp:(handler &quot;TCP&quot;)
                  ~udp:(handler &quot;UDP&quot;)
                  ~default:(fun ~proto ~src:_ ~dst:_ _data -&gt;
                      Lwt.return (Logs.warn (fun f -&gt; f &quot;%d DEFAULT&quot; proto)))
                  i
               )
         ~ipv6:(fun _buf -&gt; Lwt.return (Logs.warn (fun f -&gt; f &quot;%s&quot; &quot;IP6&quot;)))
         e)
    &gt;&gt;= function
    | Ok () -&gt;
      Logs.info (fun f -&gt; f &quot;done!&quot;);
      Lwt.return ()
    | Error e -&gt;
      Logs.warn (fun f -&gt; f
        &quot;failure to listen from network interface: %a&quot;
        N.pp_error e);
      Lwt.return_unit

end
</code></pre>
<p>and now we get a buildable unikernel:</p>
<pre><code>mirage-skeleton/ping$ make
mirage build
ocamlfind ocamldep -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -modules unikernel.ml &gt; unikernel.ml.depends
ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o unikernel.cmo unikernel.ml
ocamlfind ocamlc -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o main.cmo main.ml
ocamlfind ocamlopt -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o key_gen.cmx key_gen.ml
ocamlfind ocamlopt -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o unikernel.cmx unikernel.ml
ocamlfind ocamlopt -c -g -g -bin-annot -safe-string -principal -strict-sequence -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix -w A-4-41-42-44 -color always -o main.cmx main.ml
ocamlfind ocamlopt -g -linkpkg -g -package tcpip.ipv4 -package tcpip.ethif -package tcpip.arpv4 -package tcpip -package mirage-unix -package mirage-types-lwt -package mirage-types -package mirage-runtime -package mirage-net-unix -package mirage-logs -package mirage-clock-unix -package lwt -package functoria-runtime -predicates mirage_unix key_gen.cmx unikernel.cmx main.cmx -o main.native
</code></pre>
<p>Hooray, we've ported another unikernel!</p>
<h2>My problem wasn't fixed here</h2>
<p>If you're encountering problems that weren't discussed here, you may find useful information in the <a href="https://github.com/mirage/mirage/releases/tag/v3.0.0">release notes for Mirage version 3</a>.  The updated examples in <a href="https://github.com/mirage/mirage-skeleton">the mirage-skeleton</a> may also be of use to you -- look in the <code>device-usage</code> directory for examples of unikernels that may be trying to use the same libraries as you are, or the <code>applications</code> category for richer examples on which you may have based a running unikernel from Mirage 2.</p>
<p>If neither of those is helpful to you and you're stuck, please feel free to ask in the #mirage IRC channel on <a href="https://freenode.net">FreeNode</a>, via e-mail at <a href="https://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">our mailing list, mirageos-devel</a>, or by raising an issue on <a href="https://github.com/mirage/mirage/issues/new">the mirage front-end tool repository at GitHub</a>.  We welcome problem reports and contributions (including suggestions for improving this document).  Thank you for helping us improve Mirage!</p>
|js};
      };
      {
        updated = {js|2016-03-13 10:30|js};
        author = { name = {js|Thomas Gazagnaire|js}; uri = None; email = None };
        subject = {js|DNS Performance Tests|js};
        permalink = {js|performance|js};
        body =
          {js|<p>This page describes some of the measurements we have doneduringdevelopment of MirageOS, and descriptions of some of the problems we encountered and how they were fixed. We use DNS serving performance as the first measure of I/O performance, for several reasons:</p>
<ul>
<li>
<p>UDP is more straightforward to implement than TCP and is stateless. This lets us test the performance of the event loop, Xen rings and the Ethernet/IPv4 stack without getting mixed up in the intricacies of TCP at the same time.</p>
</li>
<li>
<p>The small size of most DNS packets is a pessimal test of Xen PV IO (grant tables require that a 4K page must be allocated per packet, most of which is unused), and any OCaml-related slowdowns in the data path will become rapidly obvious. The intuition is that if DNS performs well, then &quot;big data&quot; manipulation should be good too.</p>
</li>
<li>
<p>The size of the record set being looked up lets us smoothly move from being I/O bound (with a small number of records) to CPU-bound (with a large number of records to look up per request). We have spotted performance cliffs here related to garbage collection, and experimented with memoization techniques to smooth things out.</p>
</li>
<li>
<p>The <a href="http://www.nominum.com/wp-content/uploads/2010/08/caching-performance.pdf"><code>queryperf</code></a> test suite provides realistic test data that we can also run against other servers.</p>
</li>
<li>
<p>BIND and NSD are widely used and critical servers that we can use as a benchmark, and aim to beat! BIND is an easy target, but NSD is supremely well tuned for high performance.</p>
</li>
</ul>
<h2>Experimental Setup</h2>
<p>All of the DNS tests are in <a href="http://github.com/avsm/mirage-perf">mirage-perf.git/dns</a> repository, and can be run on a Debian or Ubuntu Xen box. We have used Xen 3.4, 4.0 and 4.1. It should work with <code>xm</code> but we mostly use the new <code>xl</code> command line tool.</p>
<p>The tests currently perform the following tasks:</p>
<ul>
<li>
<p><a href="http://github.com/avsm/mirage-perf/tree/master/dns/bin/">bin/setup.sh</a> uses debootstrap to set up domU images of Linux. (and install NSD/BIND?)</p>
</li>
<li>
<p><a href="http://github.com/avsm/mirage-perf/tree/master/dns/bin/">bin/generate.sh</a> runs <code>queryperf</code> to create the test zone files, and compiles the MirageOS UNIX and kernel binaries for different result sizes</p>
</li>
<li>
<p><a href="http://github.com/avsm/mirage-perf/tree/master/dns/bin/">bin/run.sh</a> reads some parameters (ranges of record sizes to test, which servers to run), and launches a series of client and server domains that run queryperf and responses respectively. The packets go across a dom0 bridge with all hardware checksumming disabled. Queries per second and response time variances are logged into <code>dns/data/</code></p>
</li>
</ul>
<p>If you do ever decide to run these tests and try to reproduce our results, please do archive up your <code>dns/data/</code> directory and send them to us too, along with a description of the hardware and Xen/Linux versions you used.</p>
<h2>Results</h2>
<p>Stay tuned, still working on publishing these...</p>
|js};
      };
      {
        updated = {js|2015-06-26 14:00|js};
        author =
          {
            name = {js|Hannes Mehnert|js};
            uri = Some {js|https://github.com/hannesm|js};
            email = Some {js|hm519@cam.ac.uk|js};
          };
        subject = {js|Unix TLS Tools|js};
        permalink = {js|tls-unix|js};
        body =
          {js|<h1>Deploying OCaml-TLS</h1>
<p>We developed various Unix applications which use the OCaml-TLS stack.
In this article, we will describe them in detail and getting you ready
to deploy.</p>
<h2><a href="https://github.com/hannesm/tlstunnel">tlstunnel</a></h2>
<pre><code>opam install tlstunnel
</code></pre>
<p>Tlstunnel is a <a href="https://github.com/bumptech/stud">stud</a> like TLS
proxy.  It listens on a given port and address, answers TLS
connections, and forwards the data to another service.  It is
developed as a UNIX application.  The configuration options of
<code>tlstunnel</code> are simplistic: <code>--frontend host:port</code> and <code>--backend host:port</code> specify the front and backend.  Optionally logs can be
directed to a file (<code>--log FILE</code>).  Required options are the
certificate chain and private key, PEM-encoded in a file.  They can be
merged into a single file, or given as two distinct files (<code>--cert FILE</code> and optionally <code>--key FILE</code> if a distinct file is used).</p>
<h2><a href="https://github.com/hannesm/jackline">jackline</a></h2>
<pre><code>opam repo add xmpp-dev https://github.com/hannesm/xmpp-opam.git
opam install jackline
</code></pre>
<p>Jackline is a terminal-based XMPP (jabber) client supporting basic
features (ping, message receipts, OTR encryption).  After installation
it starts with an interactive configuration.</p>
<h2><a href="https://github.com/hannesm/tlsclient">tlsclient</a></h2>
<pre><code>opam pin add tlsclient https://github.com/hannesm/tlsclient.git
</code></pre>
<p>Tlsclient is a TLS client, in the spirit of <code>openssl s_client</code>.  Given
a hostname and port it will connect there and do a TLS handshake, and
report back the certificate chain and security parameters.  A
directory with trust anchors can be provided, which will be used to
verify the certificate chain.</p>
|js};
      };
      {
        updated = {js|2015-06-18 11:00|js};
        author =
          {
            name = {js|Thomas Leonard|js};
            uri = Some {js|http://roscidus.com/blog/|js};
            email = Some {js|talex5@gmail.com|js};
          };
        subject = {js|Breaking changes|js};
        permalink = {js|breaking-changes|js};
        body =
          {js|<p>This page records API changes that require existing code to be updated.</p>
<h3>2021-XX-XX: MirageOS 4</h3>
<h4>Functoria</h4>
<p>In Mirage 3.x, <code>functoria</code> devices were described by extending the <code>base_configurable</code> object.
Custom devices are now described using the following API:</p>
<pre><code class="language-ocaml">val impl :
  (* Device's package dependencies *)
  ?packages:package list -&gt;
  ?packages_v:package list value -&gt;
  (* Device's output artifacts to promote in the dist/ folder *)
  ?install:(info -&gt; Install.t) -&gt; 
  ?install_v:(info -&gt; Install.t value) -&gt;
  (* Functoria keys *)
  ?keys:abstract_key list -&gt; 
  (* Device dependencies *)
  ?extra_deps:abstract_impl list -&gt; 
  (* [connect info modname deps] is the code to instanciate device's value given its dependencies' values and the module name *)
  ?connect:(info -&gt; string -&gt; string list -&gt; string) -&gt; 
  (* Additional dune rules to generate code or artifacts *)
  ?dune:(info -&gt; Dune.stanza list) -&gt;
  (* Configure-time operations *)
  ?configure:(info -&gt; unit Action.t) -&gt; 
  (* Extra files generated by configure-time operations *)
  ?files:(info -&gt; Fpath.t list) -&gt; 
  (* Functor name *)
  string -&gt; 
  (* Functor type *)
  'a typ -&gt; 
  (* Device implementation *)
  'a impl
</code></pre>
<h4>Dune</h4>
<p>For each unikernel, MirageOS 4 assembles a monorepo of dependencies to locally cross-compile them
using the chosen target settings. To achieve that, the tool uses <code>dune</code>'s build context feature.
The consequence of that choice is that unikernel libraries also need to be built using <code>dune</code>.</p>
<p>For most packages, porting to <code>dune</code> is fairly straightforward, and has the benefit of integrating
with existing platform tools like <code>merlin</code>. The <a href="https://github.com/dune-universe/opam-overlays">dune-universe/opam-overlays</a>
repository contains a set of packages that have been ported to <code>dune</code> but where the changes haven't
been upstreamed.</p>
<h3>2016-02-17: Functoria edition</h3>
<h4>Command line</h4>
<p>The config file must be passed with the <code>-f</code> option (instead of being just
an argument).</p>
<h4>Deprecation: Misc functions</h4>
<p><code>get_mode</code> is deprecated. You should use keys instead. And in particular <code>Key.target</code> and <code>Key.is_xen</code>.</p>
<p><code>add_to_ocamlfind_libraries</code> and <code>add_to_opam_packages</code> are deprecated. Both the <code>foreign</code> and the <code>register</code> functions now possess the <code>~libraries</code> and <code>~packages</code> arguments to specify libraries dependencies.</p>
<h4>Entropy</h4>
<p>If you were using <code>tls</code> without the conduit combinator, you will be
greeted during configuration by a message like this:</p>
<pre><code>The &quot;nocrypto&quot; library is loaded but entropy is not enabled!
Please enable the entropy by adding a dependency to the nocrypto device.
You can do so by adding ~deps:[abstract nocrypto] to the arguments of Mirage.foreign.
</code></pre>
<p>Data dependencies (such as entropy initialization) are now explicit.
In order to fix this, you need to declare the dependency like so:</p>
<pre><code>open Mirage

let my_functor =
  let deps = [abstract nocrypto] in
  foreign ~deps &quot;My_Functor&quot; (foo @-&gt; bar)
</code></pre>
<p><code>My_functor.start</code> will now take an extra argument for each
dependencies. In the case of nocrypto, this is <code>()</code>.</p>
<h3>2015-06-18: HTTP servers with Mirage &gt; 2.5</h3>
<p>Before, you would specify your server's address in the <code>config.ml</code>:</p>
<pre><code>let server =
  http_server (`TCP (`Port 8080)) (conduit_direct (stack default_console))
</code></pre>
<p>and then use it in your <code>unikernel.ml</code> as:</p>
<pre><code>let start http =
  ...
  http (H.make ~callback ~conn_closed ())
</code></pre>
<p>With mirage &gt; 2.5, the address argument is no longer present and you will get this error:</p>
<pre><code>Error: This function has type
         Mirage.conduit Mirage.impl -&gt; Mirage.http Mirage.impl
       It is applied to too many arguments; maybe you forgot a `;'.
</code></pre>
<p>To update, change <code>config.ml</code> to:</p>
<pre><code>let server =
  http_server (conduit_direct (stack default_console))
</code></pre>
<p>and move the address to your <code>unikernel.ml</code>:</p>
<pre><code>let start http =
  ...
  http (`TCP 8080) (H.make ~callback ~conn_closed ())
</code></pre>
<p>Note that the <code>Port</code> tag has also been removed.</p>
<p>This change was needed to support TLS servers, since TLS configuration (keys and certificates) is more complex and cannot be declared in the <code>config.ml</code>.</p>
<p>Commit: <a href="https://github.com/mirage/mirage/commit/56e500d4210bf7fdcdc296f3c34ce13c9f57cdf5">https://github.com/mirage/mirage/commit/56e500d4210bf7fdcdc296f3c34ce13c9f57cdf5</a></p>
|js};
      };
      {
        updated = {js|2014-12-11 17:23|js};
        author =
          {
            name = {js|Thomas Leonard|js};
            uri = Some {js|http://roscidus.com/blog/|js};
            email = Some {js|talex5@gmail.com|js};
          };
        subject = {js|Tracing and Profiling|js};
        permalink = {js|profiling|js};
        body =
          {js|<p>When tracking down bugs or performance problems, or just trying to understand how something works, it is often useful to look at a trace of the execution of your unikernel.</p>
<p>As a motivating example, we'll track down a (real, but now fixed) bug in MirageOS's TCP stack.</p>
<p>Here's a small program that demonstrates the problem:</p>
<pre><code class="language-OCaml">let target_ip = Ipaddr.V4.of_string_exn &quot;10.0.0.1&quot;

module Main (S: V1_LWT.STACKV4) = struct
  let buffer = Io_page.get 1 |&gt; Io_page.to_cstruct

  let start s =
    let t = S.tcpv4 s in

    match_lwt S.TCPV4.create_connection t (target_ip, 7001) with
    | `Error _err -&gt; failwith &quot;Connection to port 7001 failed&quot;
    | `Ok flow -&gt;
    
    let payload = Cstruct.sub buffer 0 1 in
    Cstruct.set_char payload 0 '!';

    match_lwt S.TCPV4.write flow payload with
    | `Error _ | `Eof -&gt; assert false
    | `Ok () -&gt;

    S.TCPV4.close flow
end
</code></pre>
<p>This unikernel opens a TCP connection to 10.0.0.1, sends a single &quot;!&quot; character, and then closes the connection.
Most of the time it works, generating output similar to the following:</p>
<pre><code>ARP: sending gratuitous from 10.0.0.2
Manager: configuration done
ARP: transmitting probe -&gt; 10.0.0.1
ARP: updating 10.0.0.1 -&gt; fe:ff:ff:ff:ff:ff
main returned 0
</code></pre>
<p>Occasionally, however, it hangs after getting the ARP response and doesn't send the data:</p>
<pre><code>ARP: sending gratuitous from 10.0.0.2
Manager: configuration done
ARP: transmitting probe -&gt; 10.0.0.1
ARP: updating 10.0.0.1 -&gt; fe:ff:ff:ff:ff:ff
</code></pre>
<h4>Enabling tracing</h4>
<p>To enable tracing, pass the optional <code>tracing</code> argument to the <code>register</code> function in <code>config.ml</code>.
For example:</p>
<pre><code class="language-OCaml">open Mirage

let main = main &quot;Unikernel.Main&quot; (stackv4 @-&gt; job)
let stack console = direct_stackv4_with_default_ipv4 console tap0

let tracing = mprof_trace ~size:1000000 ()

let () =
  register &quot;example&quot; ~tracing [
    main $ stack default_console;
  ]
</code></pre>
<p>The size argument gives the size in bytes of the ring buffer to use.
When you run <code>mirage configure</code>, you will probably be prompted to install a version of Lwt with tracing enabled; just run the <code>opam pin</code> command provided.
This will automatically trigger a recompile of all the MirageOS libraries with tracing enabled.</p>
<p>To view the trace data, use <a href="https://github.com/talex5/mirage-trace-viewer">mirage-trace-viewer</a>.
If you don't want to compile from source, there are <a href="http://talex5.github.io/mirage-trace-viewer/mtv.xml">pre-compiled binaries</a> for Linux-x86_64 and Linux-armv7l (e.g. for the Cubietruck).
You can get them with 0install:</p>
<pre><code>sudo apt-get install zeroinstall-injector
0install add mirage-trace-viewer http://talex5.github.io/mirage-trace-viewer/mtv.xml
</code></pre>
<p>If you compiled your MirageOS program as a Unix process, the trace data will appear in a file called <code>trace.ctf</code> (you can view the trace while the process is still running).
To view the trace using the GTK viewer, use:</p>
<pre><code>mirage-trace-viewer trace.ctf
</code></pre>
<p>If you don't have GTK, you can use <code>mirage-trace-viewer --html=htdocs ...</code> to create an <code>htdocs</code> directory with a JavaScript viewer.</p>
<p>The files can also be read by other CTF readers, such as <a href="http://www.efficios.com/babeltrace">babeltrace</a>, with the appropriate <a href="https://github.com/mirage/mirage-profile/blob/master/metadata">metadata</a> file.</p>
<h4>Tracing Xen guests</h4>
<p>To get the trace data from a Xen unikernel, run <code>mirage-trace-viewer -d NAME</code> as root.
I use a wrapper script for this (<code>~/bin/sudo-mtv</code>):</p>
<pre><code>#!/bin/sh
exec 0launch -w sudo mirage-trace-viewer &quot;$@&quot;
</code></pre>
<p>To dump the trace buffer from the Xen domain <code>example</code> to the file <code>trace.ctf</code>:</p>
<pre><code>sudo-mtv -d example -w trace.ctf
</code></pre>
<p>To fetch trace data from a remote Xen host (e.g. a Cubietruck board) and view it on your laptop:</p>
<pre><code>ssh mirage@cubietruck sudo-mtv -d example -w - | mirage-trace-viewer -
</code></pre>
<p>Tip: If your Xen guest crashes before you can read the data, put these lines in your <code>.xl</code> file:</p>
<pre><code>on_crash = 'preserve'
on_poweroff = 'preserve'
</code></pre>
<h4>Navigating a trace</h4>
<p>Here's the trace for a successful run (where the message was transmitted):</p>
<div class='trace-viewer'>
<canvas tabindex='1' id='good' style='width: 100%; height:500px'>
<noscript>Sorry, you need to enable JavaScript to see this page.</noscript>
</canvas>
</div>
[View full screen](/html/trace-viewer.html?trace=good)
<p>Use your mouse's scroll wheel (or the buttons at the bottom) to zoom.</p>
<p>Time runs left to right:</p>
<ul>
<li>At the start (far left), the tracing system shares all the pages of its trace buffer with dom 0, allowing us to read the trace. The <code>gntref</code> counter (the red line) increases rapidly during this time.
</li>
<li>Next, the tracing system stores the grant ref details in XenStore, followed immediately by the TCP stack getting the network details from XenStore.
</li>
<li>The <code>gntref</code> metric then goes up again as the network code shares its buffer with dom0.
</li>
<li>Then our test code runs, opening the TCP connection and sending the data.
The <code>tcp-to-ip</code> counter goes up here (to 1), showing where the single-byte packet is passed from the TCP buffer to the IP layer for transmission.
</li>
</ul>
<p>Horizontal black lines are Lwt threads. White regions indicate when the thread was running. Vertical black lines indicate threads creating new threads or merging with existing ones. Arrows show interactions between threads:</p>
<ul>
<li>A green arrow from A to B means that A resolved sleeping thread B (e.g. with <code>Lwt.wakeup</code>).
</li>
<li>A blue arrow from A to B means that B read the result of A.
</li>
<li>A red arrow is similar, but for the case where the thread failed.
</li>
<li>A yellow arrow from A to B means that A tried to read B but it wasn't ready yet.
In the common case where this is followed by a blue arrow, the yellow arrow isn't shown.
</li>
<li>An orange arrow from A to B means that A sent some other kind of message to B.
</li>
</ul>
<p>Libraries can annotate threads with labels, which makes reading the diagrams much easier.
If a thread doesn't have a label, its unique thread ID is displayed instead.</p>
<p>For more information about reading the visualisation, see the blog post <a href="http://roscidus.com/blog/blog/2014/10/27/visualising-an-asynchronous-monad/">Visualising an Asynchronous Monad</a>.</p>
<h4>Finding the bug</h4>
<p>To find the problem, we can compare a good trace and a bad trace:</p>
<div class='trace-viewer'>
<canvas tabindex='2' id='good-detail' style='width: 100%; height:500px'>No canvas support. </canvas>
</div>
[View full screen](/html/trace-viewer.html?trace=good-detail)
<p>Above: a trace from a successful run. Below: a trace from a failed run.</p>
<div class='trace-viewer'>
<canvas tabindex='3' id='bad-detail' style='width: 100%; height:500px'>No canvas support.</canvas>
</div>
[View full screen](/html/trace-viewer.html?trace=bad-detail)
<p>Normally, when a thread doesn't do anything it is drawn only as a tiny stub in the display.
To make the problem easier to spot, I modified the test program to call <code>MProf.Trace.should_resolve</code> on the program's main thread, which adds a hint that this thread is important.
The viewer sees that it didn't resolve, and so draws it in red and extending to the far right of the display.</p>
<p>Looking at the good trace, three important threads are created:</p>
<ol>
<li>A &quot;TCP connect&quot; thread to track the TCP connection (if you can't see it, click the menu button in the bottom left and search for <code>TCP connect</code> - it will highlight in yellow as you type.
</li>
<li>An &quot;ARP response&quot; condition thread to get the MAC address from the target IP address.
</li>
<li>A &quot;ring.write&quot; thread to track the ARP request being transmitted (you'll have to zoom in to see this).
</li>
</ol>
<p>Soon after creating these threads, the unikernel received an event on port-4, which is the network event channel.
The <code>Netif</code> driver determined this was an ack that the ARP request had been sent, and resolved the <code>ring.write</code> thread, which then triggered the page of memory containing the request to be unshared.
This then triggered the next step in the process, which was to start waiting for the &quot;ARP response&quot; condition to fire, creating an &quot;ARP response&quot; &quot;task&quot; thread.</p>
<p>Another event then arrived on port-4, which was the ARP response notification.
This resolved the &quot;ARP response&quot; thread, which allowed us to start the TCP connection (sending the SYN packet).
Once the remote end had ack'd the SYN, the TCP connection was ready (the <code>TCP connect</code> thread ends) and we sent the data, increasing the <code>tcp-to-ip</code> counter.</p>
<p>In the bad case:</p>
<ul>
<li>The main thread (that we annotated with <code>MProf.Trace.should_resolve</code>) appears as a long red line with <code>should-resolve thread never resolved</code> at the end.
</li>
<li>Looking at the start of this red thread, you can see a yellow arrow to a bind thread (indicating that the main thread was waiting for it).
</li>
<li>Following the yellow arrows, you'll eventually end up at a <code>try</code> thread waiting on <code>Wait for ARP response</code> (tip: to avoid losing track of where you are, you can double-click a thread to highlight it).
</li>
</ul>
<p>Following the ARP response task thread backwards, we can see that the order of the events was different.
In this case, the first event from the network is not the confirmation that the ARP request has been sent, but the notification of the ARP response. You can see that the network code now first notifies the &quot;ARP response&quot; condition (but nothing is waiting for it, so this is ignored). Then, confirmation of the request being sent arrives, ending the &quot;ring.write&quot; thread.
This triggers us to start waiting for a notification from the &quot;ARP response&quot; condition, but this will never arrive because the event has already happened.</p>
<p>Indeed, the bug is in this code in <code>arpv4.ml</code>:</p>
<pre><code class="language-OCaml">let cond = MProf.Trace.named_condition &quot;ARP response&quot; in
(* printf &quot;ARP query: %s -&gt; [probe]\\n%!&quot; (Ipaddr.V4.to_string ip); *)
Hashtbl.add t.cache ip (Incomplete cond);
(* First request, so send a query packet *)
output_probe t ip &gt;&gt;= fun () -&gt;
Lwt_condition.wait cond
</code></pre>
<p>One solution here would be to call <code>Lwt_condition.wait</code> before waiting for the result of <code>output_probe</code>.
However, a better solution (the one actually adopted) replaces the use of a condition with a simple wait thread.
A wait thread can only be resolved once, so it doesn't matter whether you check it before or after it gets its value.</p>
<h4>Collecting more information</h4>
<p>You might notice that many of the threads are unlabelled, as we haven't fully instrumented all the MirageOS libraries.
To add extra annotations, clone the appropriate library with Git, add some extra reporting, and use <code>opam pin</code> to build against your version.
If you think your annotations would be generally useful, please send a pull request.</p>
<p>In general, any code that uses <code>Lwt.wait</code>, <code>Lwt.task</code>, <code>Lwt_condition.create</code>, or <code>Lwt_mvar.create</code> should be changed to use the corresponding labelled version in <a href="https://github.com/mirage/mirage-profile">mirage-profile</a> (e.g. <code>MProf.Trace.named_wait</code>, etc).
When Lwt is compiled without tracing support, these labels will be optimised out and have no runtime cost.</p>
<script type="text/javascript" src="/js/profile-examples.js"></script>
|js};
      };
      {
        updated = {js|2014-08-21 11:19|js};
        author =
          {
            name = {js|Nick Betteridge|js};
            uri = Some {js|https://github.com/buzzheavyyear|js};
            email = Some {js|buzzheavyyear@hotmail.com|js};
          };
        subject = {js|Libvirt On Cubieboard|js};
        permalink = {js|libvirt-on-cubieboard|js};
        body =
          {js|<h4>Warning: Out of date</h4>
<p><em>(Updated 2020-10-26. The following information is of historical interest, since MirageOS 3.9.0 our Xen backend has been revised, and only supports PVH mode and x86_64 as architecture.)</em></p>
<h4>Bringing up the board</h4>
<ol>
<li>
<p>Download and unpack the image for your board.</p>
<p><a href="http://blobs.openmirage.org/cubieboard2-xen-iso.tar.bz2">For the cubieboard2</a></p>
<p><a href="http://blobs.openmirage.org/cubietruck-xen-iso.tar.bz2">For the cubietruck</a></p>
</li>
<li>
<p>Copy to the SDcard, e.g.</p>
<p><code>dd if=cubie.img of=/dev/mmcblk0</code></p>
</li>
<li>
<p>Boot the device. It should get an IP address by DHCP.</p>
</li>
<li>
<p>The device announces a .local name using mDNS, so you should be able to ssh to $BOARD.local</p>
<pre><code>ssh mirage@cubieboard2.local.
</code></pre>
</li>
<li>
<p>To change hostname of the cubieboard:</p>
<p>edit /etc/hosts</p>
<pre><code>127.0.1.1       newname
</code></pre>
<p>edit /etc/hostname</p>
<pre><code>newname
</code></pre>
</li>
<li>
<p>To change the cubieboard to get a static ip address:</p>
<p>edit /etc/network/interfaces and update with:</p>
<pre><code>auto lo
iface lo inet loopback

auto eth0
iface eth0 inet manual
  up ip link set eth0 up

auto br0
iface br0 inet static
  bridge_ports eth0
  address 192.168.1.11
  broadcast 192.168.1.255
  netmask 255.255.255.0
  gateway 192.168.1.254
</code></pre>
</li>
<li>
<p>reboot</p>
</li>
</ol>
<h4>SSH</h4>
<p>To set up ssh:</p>
<ol>
<li>
<p><code>ssh mirage@192.168.1.11</code> (password: mirage)</p>
</li>
<li>
<p><code>ssh-keygen</code></p>
</li>
<li>
<p>logout (ctrl-d)</p>
</li>
<li>
<p><code>scp ~/.ssh/id_rsa.pub mirage@192.168.1.11:.ssh/authorized_keys</code></p>
</li>
<li>
<p><code>ssh mirage@192.168.1.11</code></p>
</li>
<li>
<p><code>chmod 700 ~/.ssh</code></p>
</li>
<li>
<p><code>chmod 600 ~/.ssh/authorized_keys</code></p>
</li>
</ol>
<h4>MirageOS</h4>
<p>You should now have a working Xen host (&quot;xl list&quot; to list current VMs, &quot;lvcreate&quot;
to create guest disks).</p>
<p>To install the ARM version of mirage:</p>
<pre><code>opam init
opam install mirage
</code></pre>
<p>You should now be able to follow the rest of the MirageOS tutorial.</p>
<h4>Libvirt</h4>
<ol>
<li>
<p>To install libvirt (the precompiled version doesn't contain the drivers for xen):</p>
<pre><code>sudo apt-get install uuid-dev libxml2-dev libdevmapper-dev libpciaccess-dev \\
libnl-dev libxen-dev libgnutls-dev
</code></pre>
</li>
<li>
<p>Download a release tarball from libvirt.org (I used 1.2.6). Download to local
machine, decompress</p>
<pre><code>scp libvirt-1.2.6.tar mirage@cubieboard2:
ssh mirage@cubieboard2
tar xf libvirt-1.2.6.tar
rm libvirt-1.2.6.tar
cd libvirt-1.2.6
</code></pre>
</li>
<li>
<p>Configure:</p>
<pre><code>./configure --prefix=/usr --localstatedir=/var  --sysconfdir=/etc --with-xen \\
--with-qemu=no --with-gnutls --with-uml=no --with-openvz=no --with-vmware=no \\
--with-phyp=no --with-xenapi=no --with-libxl=yes --with-vbox=no --with-lxc=no \\
--with-esx=no  --with-hyperv=no --with-parallels=no --with-init-script=upstart
</code></pre>
</li>
<li>
<p><code>make</code></p>
</li>
<li>
<p><code>sudo make install</code></p>
</li>
<li>
<p>Create a 'libvirt' group if one doesn't already exist</p>
<p><code>sudo addgroup libvirt</code></p>
</li>
<li>
<p>Add the two scripts (below, if they don't already exist) to
/etc/init.d/libvirt-bin and /etc/default/libvirt-bin</p>
</li>
<li>
<p>Ensure that /etc/default/libvirt-bin has '-l' to libvirtd_opts</p>
</li>
<li>
<p>Follow the instructions in http://wiki.libvirt.org/page/TLSSetup in install
tls on the cubieboards and admin machine</p>
<ul>
<li>Use the libvirt group instead of qemu as the owner of /etc/pki/libvirt/
</li>
</ul>
</li>
<li>
<p>System init scripts:</p>
<pre><code>cd /etc/rc5.d
sudo ln -s ../init.d/libvirt-bin S22libvirt-bin

cd /etc/rc6.d
sudo ln -s ../init.d/libvirt-bin K19libvirt-bin
sudo update-rc.d libvirt-bin defaults
sudo service libvirt-bin start
</code></pre>
</li>
<li>
<p>Reboot the board</p>
</li>
<li>
<p>From the admin machine, edit /etc/hosts and add the cubieboard addresses and
names so that (a) the names are resolvable and (b) matches the name on the certificates, e.g.</p>
<p><code>192.168.1.10 cubieboard2</code></p>
</li>
<li>
<p>Test that the admin machine can talk to the cubieboard:</p>
<p><code>sudo virsh -c xen://cubieboard2/system hostname</code></p>
<p>and you should get 'cubieboard2' returned, if not, ssh to the cubieboard
and check/restart the daemon (sudo service libvirt-bin start)</p>
</li>
</ol>
<p>To set up the admin machine to ensure another user (instead of root) can run virsh commands:</p>
<p>On the admin machine:</p>
<ol>
<li>
<p>Add the user to the libvirt group (on older releases of libvirt, this group
is sometimes 'libvirtd')</p>
</li>
<li>
<p>Ensure that the clientcert.pem and clientkey.pem in /etc/pki/libvirt belong
to the libvirt group, e.g.:</p>
<pre><code>sudo chgrp libvirt /etc/pki/libvirt/clientcert.pem
sudo chmod 440 /etc/pki/libvirt/clientcert.pem
sudo chgrp libvirt /etc/pki/libvirt/private/clientkey.pem
sudo chmod 440 /etc/pki/libvirt/private/clientkey.pem
</code></pre>
</li>
<li>
<p>Edit /etc/libvirt/libvirtd.conf and ensure unix_sock_group, unix_sock_ro_perms,
unix_sock_rw_perms are uncommented, allowing users in the libvirt(d) group to use tls, i.e.</p>
<pre><code>unix_sock_group = &quot;libvirt&quot;
unix_sock_ro_perms = &quot;0777&quot;
unix_sock_rw_perms = &quot;0770&quot;
</code></pre>
</li>
</ol>
<p>On the cubieboard:</p>
<ol start="4">
<li>
<p>ssh into the cubieboard and create a user which matches the 'admin' user ( - 'nick' in my case),</p>
<p><code>sudo adduser 'username'</code></p>
</li>
<li>
<p>Add the admin user to the libvirt group</p>
<p><code>sudo adduser 'username' libvirt</code></p>
</li>
<li>
<p>Reboot</p>
</li>
</ol>
<p>The cubieboard should now be accessible remotely from a non-root account.</p>
<p>Clone the mirage example mirage-skeleton/xen/static_website+ip</p>
<p>Compile the example (this currently needs to be built on a cubieboard), and then
edit www.xl. Change the ipaddress, gateway etc. to suit, and then run the
virsh 'domxml-from-native' translator to get the libvirt xml file</p>
<pre><code>virsh -c xen:/// domxml-from-native xen-xm www.xl &gt; www.xml
virsh -c xen://cubie0/system create www.xml
</code></pre>
<p><strong>/etc/default/libvirt-bin</strong></p>
<pre><code># Defaults for libvirt-bin initscript (/etc/init.d/libvirt-bin)
# This is a POSIX shell fragment

# Start libvirtd to handle qemu/kvm:
start_libvirtd=&quot;yes&quot;

# options passed to libvirtd, add &quot;-l&quot; to listen on tcp
libvirtd_opts=&quot;-d -l&quot;

# pass in location of kerberos keytab
#export KRB5_KTNAME=/etc/libvirt/libvirt.keytab
</code></pre>
<p><strong>/etc/init.d/libvirt-bin</strong></p>
<pre><code>#! /bin/sh
#
# Init script for libvirtd
#
# (c) 2007 Guido Guenther &lt;agx@sigxcpu.org&gt;
# based on the skeletons that comes with dh_make
#
### BEGIN INIT INFO
# Provides:          libvirt-bin libvirtd
# Required-Start:    $network $local_fs $remote_fs $syslog
# Required-Stop:     $local_fs $remote_fs $syslog
# Should-Start:      hal avahi cgconfig
# Should-Stop:       hal avahi cgconfig
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: libvirt management daemon
### END INIT INFO

PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
DAEMON=/usr/sbin/libvirtd
NAME=libvirtd
DESC=&quot;libvirt management daemon&quot;
export PATH

test -x $DAEMON || exit 0
. /lib/lsb/init-functions

PIDFILE=/var/run/$NAME.pid
DODTIME=1                   # Time to wait for the server to die, in seconds

# Include libvirtd defaults if available
if [ -f /etc/default/libvirt-bin ] ; then
	. /etc/default/libvirt-bin
fi

check_start_libvirtd_option() {
  if [ ! &quot;$start_libvirtd&quot; = &quot;yes&quot; ]; then
    log_warning_msg &quot;Not starting libvirt management daemon libvirtd, disabled via /etc/default/libvirt-bin&quot;
    return 1
  else
    return 0
  fi
}

running_pid()
{
    # Check if a given process pid's cmdline matches a given name
    pid=$1
    name=$2
    [ -z &quot;$pid&quot; ] &amp;&amp; return 1 
    [ ! -d /proc/$pid ] &amp;&amp;  return 1
    cmd=`cat /proc/$pid/cmdline | tr &quot;\\000&quot; &quot;\\n&quot;|head -n 1 |cut -d : -f 1`
    # Is this the expected child?
    [ &quot;$cmd&quot; != &quot;$name&quot; ] &amp;&amp;  return 1
    return 0
}

running()
{
# Check if the process is running looking at /proc
# (works for all users)
    # No pidfile, probably no daemon present
    [ ! -f &quot;$PIDFILE&quot; ] &amp;&amp; return 1
    # Obtain the pid and check it against the binary name
    pid=`cat $PIDFILE`
    running_pid $pid $DAEMON || return 1
    return 0
}

force_stop() {
# Forcefully kill the process
    [ ! -f &quot;$PIDFILE&quot; ] &amp;&amp; return
    if running ; then
        kill -15 $pid
        # Is it really dead?
        [ -n &quot;$DODTIME&quot; ] &amp;&amp; sleep &quot;$DODTIME&quot;s
        if running ; then
            kill -9 $pid
            [ -n &quot;$DODTIME&quot; ] &amp;&amp; sleep &quot;$DODTIME&quot;s
            if running ; then
                echo &quot;Cannot kill $LABEL (pid=$pid)!&quot;
                exit 1
            fi
        fi
    fi
    rm -f $PIDFILE
    return 0
}

case &quot;$1&quot; in
  start)
	if check_start_libvirtd_option; then
		log_daemon_msg &quot;Starting $DESC&quot; &quot;$NAME&quot;
        	if running ;  then
            		log_progress_msg &quot;already running&quot;
            		log_end_msg 0
            		exit 0
        	fi
		rm -f /var/run/libvirtd.pid
		start-stop-daemon --start --quiet --pidfile $PIDFILE \\
			--exec $DAEMON -- $libvirtd_opts
		if running; then
			log_end_msg 0
		else
			log_end_msg 1
		fi
	fi
	;;
  stop)
	log_daemon_msg &quot;Stopping $DESC&quot; &quot;$NAME&quot;
	if ! running ;  then
           	log_progress_msg &quot;not running&quot;
            	log_end_msg 0
            	exit 0
       	fi
	start-stop-daemon --stop --quiet --pidfile $PIDFILE \\
		--exec $DAEMON
	log_end_msg 0
	;;
  force-stop)
	log_daemon_msg &quot;Forcefully stopping $DESC&quot; &quot;$NAME&quot;
	force_stop
	if ! running; then
		log_end_msg 0
	else
		log_end_msg 1
	fi
	;;
  restart)
	if check_start_libvirtd_option; then
		log_daemon_msg &quot;Restarting $DESC&quot; &quot;$DAEMON&quot;
		start-stop-daemon --oknodo --stop --quiet --pidfile \\
			/var/run/$NAME.pid --exec $DAEMON
		[ -n &quot;$DODTIME&quot; ] &amp;&amp; sleep $DODTIME
		start-stop-daemon --start --quiet --pidfile \\
			/var/run/$NAME.pid --exec $DAEMON -- $libvirtd_opts
		if running; then
			log_end_msg 0
		else
			log_end_msg 1
		fi
	fi
	;;
  reload|force-reload)
  	if running; then
            log_daemon_msg &quot;Reloading configuration of $DESC&quot; &quot;$NAME&quot;
	    start-stop-daemon --stop --signal 1 --quiet --pidfile \\
	             /var/run/$NAME.pid --exec $DAEMON
	    log_end_msg 0
	else
            log_warning_msg &quot;libvirtd not running, doing nothing.&quot;
	fi
	;;
  status)
        log_daemon_msg &quot;Checking status of $DESC&quot; &quot;$NAME&quot;
        if running ;  then
            log_progress_msg &quot;running&quot;
            log_end_msg 0
        else
            log_progress_msg &quot;not running&quot;
            log_end_msg 1
            if [ -f &quot;$PIDFILE&quot; ] ; then
                exit 1
            else
                exit 3
            fi
	fi
    ;;
  *)
	N=/etc/init.d/libvirt-bin
	echo &quot;Usage: $N {start|stop|restart|reload|force-reload|status|force-stop}&quot; &gt;&amp;2
	exit 1
	;;
esac

exit 0

</code></pre>
|js};
      };
      {
        updated = {js|2014-08-12 22:56|js};
        author =
          {
            name = {js|Mindy Preston|js};
            uri = Some {js|https://github.com/yomimono|js};
            email = Some {js|mindy.preston@cl.cam.ac.uk|js};
          };
        subject = {js|Contributing to MirageOS|js};
        permalink = {js|contributing|js};
        body =
          {js|<p>MirageOS welcomes contributions from anyone interested in the project.  If you are planning a large contribution, be it a piece of documentation, a patch to the software, a new driver, or something else, please do send a note to <a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">the MirageOS development mailing list</a> describing your planned contribution - you may discover that other contributors are willing to help.</p>
<p>More information on being in touch with other MirageOS contributors <a href="https://mirage.io/community">is available</a>.</p>
<h2>Reporting Issues</h2>
<p>Issues (e.g. bugs in the software, unclear documentation, missing functionality) are best reported on the main <a href="http://www.github.com/mirage/mirage/issues">MirageOS repository</a> at GitHub, unless the issue is clearly contained in, and only relevant to, another specific repository.</p>
<p>When reporting an issue, please try to include any information you think may be relevant, including</p>
<ul>
<li>a link to the source code you're building with MirageOS
</li>
<li>relevant version info, e.g. your opam version (<code>opam --version</code>) and your MirageOS version (<code>mirage --version</code>), and your operating system and version.
</li>
<li>if applicable, a terminal log representing how you trigger the issue, and what happens when the problem is occurring
</li>
<li>a description of any way you may have tried to solve the issue, or gather more information about it
</li>
</ul>
<h2>Submitting Changes</h2>
<p>MirageOS uses the <a href="https://help.github.com/articles/using-pull-requests">pull request</a> facility of GitHub to manage patches for both code and documentation.  Patches should be as self-contained as possible, with one patch corresponding to (at most) one bugfix or feature.  For large changes, please coordinate with other contributors via the <a href="https://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a>.</p>
<p>The mechanics for submitting a pull request are as follows:</p>
<ul>
<li><a href="https://github.com/signup">Set up a free GitHub account</a>.
</li>
<li><a href="https://help.github.com/articles/fork-a-repo">Fork</a> the repository to which you intend to commit your code.  For example, a patch to the TCP/IP stack in MirageOS should fork <a href="http://www.github.com/mirage/mirage-tcpip">mirage-tcpip</a>, and a patch correcting a problem with the website's documentation should fork <a href="http://www.github.com/mirage/mirage-www">mirage-www</a>.
</li>
<li>Make a <a href="https://github.com/blog/1377-create-and-delete-branches">branch</a> with a descriptive name for the changes you plan to make.
</li>
<li>If you are making code changes, you may wish to point <code>opam</code> to your local repository for that code with <code>opam pin</code>.  <a href="https://opam.ocaml.org/doc/Packaging.html">More details on using opam when developing are available at the <code>opam</code> site.</a>
</li>
<li>Make changes in your local repository.  <a href="https://wiki.gnome.org/Git/CommitMessages">Here are some simple guidelines on commit messages.</a>
</li>
<li>When you're satisfied that your changes are ready to be submitted, <a href="https://help.github.com/articles/pushing-to-a-remote">push your changes to GitHub</a>.
</li>
<li>The web view for your repository should now have a button labeled <code>submit pull request</code>, where you can view the summary of your change and request that it be merged into the main repository.
</li>
<li>Keep an eye out for notifications on your pull request!  By default, GitHub will email you when other contributors have questions or comments that they'd like to discuss with you before merging your changes.
</li>
</ul>
|js};
      };
      {
        updated = {js|2014-04-16 17:30|js};
        author =
          {
            name = {js|Thomas Leonard|js};
            uri = Some {js|http://roscidus.com/blog/|js};
            email = Some {js|talex5@gmail.com|js};
          };
        subject = {js|Running Xen on the Cubieboard2|js};
        permalink = {js|xen-on-cubieboard2|js};
        body =
          {js|<p><strong>Author:</strong> Thomas Leonard, addendums from Anil Madhavapeddy</p>
<p>These notes detail the process of setting up a Xen system on a Cubieboard2 (or Cubietruck).
They are based on the <a href="http://wiki.xen.org/wiki/Xen_ARM_with_Virtualization_Extensions/Allwinner">Xen ARM with Virtualization Extensions/Allwinner</a> documentation, but try to collect everything into one place.
I'm trying to document the exact steps I took (with the wrong turns removed); some changes will be needed for other systems.</p>
<p><strong>TL;DR</strong>: There is now a script available that generates an image with Xen, Ubuntu dom0, and the OCaml tools installed.  Just run the <code>make</code> instructions at <a href="https://github.com/mirage/xen-arm-builder">mirage/xen-arm-builder</a> and copy the resulting image onto an SDcard and boot up your Cubieboard2 or Cubietruck (password <code>mirage</code>/<code>mirage</code> which you should change as the first thing you do). The script is kept more up-to-date than the instructions on this page.</p>
<p>The remainder of this guide covers:</p>
<ul>
<li>Installing U-Boot, Xen and a Linux Dom0
</li>
<li>Running a Linux DomU
</li>
<li>Running a FreeBSD DomU
</li>
<li>Running a Mini-OS DomU
</li>
</ul>
<h2>Warning: Out of date</h2>
<p><em>(Updated 2020-10-26. The following information is of historical interest, since MirageOS 3.9.0 our Xen backend has been revised, and only supports PVH mode and x86_64 as architecture.)</em></p>
<h2>Glossary</h2>
<dl><dt><a href="http://en.wikipedia.org/wiki/ARM_architecture">ARMv7</a></dt>
<dd>Version 7 of the ARM architecture, which adds optional virtualisation support.</dd>
<dt><a href="http://www.arm.com/products/processors/cortex-a/cortex-a7.php">ARM Cortex-A7</a></dt>
<dd>A 32-bit RISC CPU designed by ARM. It implements ARMv7, including the virtualisation extensions.</dd>
<dt><a href="http://linux-sunxi.org">sunxi</a></dt>
<dd>An ARM SoC (System-on-Chip) family, made by Allwinner Tech.</dd>
<dt><a href="http://linux-sunxi.org/A20">A20</a></dt>
<dd>An SoC with two Cortex-A7 CPUs (plus GPU, memory controller, etc).</dd>
<dt><a href="http://docs.cubieboard.org/products/start">Cubieboard2</a></dt>
<dd>A small board with an A20, 1 GB RAM, etc.</dd>
<dt><a href="http://wandboard.org/index.php/57-20131104-wandboard-spl-universal-boot">SPL</a> (Secondary Program Loader)</dt>
<dd>&quot;SPL is a very small bootloader able to fit into the very small amount of memory (128kB) available inside the CPU. SPL does autodetection and sets up memory accordingly. After memory is set up, SPL loads u-boot, and the booting proceeds as usual.&quot;</dd>
</dl>
<h3>Initial testing</h3>
<p>This step can be skipped, but it's useful to check that everything works.</p>
<p>Download <a href="http://www.cubieforums.com/index.php/topic,528.0.html">Cubieez</a>, a Debian 7.1 image that works on the Cubieboard2.
Write to microSD card with:</p>
<pre><code>dd if=cubieez_1.0.0_A20.img of=/dev/mmcblk0
</code></pre>
<p>You will need to hook up the serial console on the Cubieboard, being careful not to connect up one of the pins.
One good cable that is known is work can be bought <a href="http://proto-pic.co.uk/usb-to-ttl-serial-cable-debug-console-cable-for-raspberry-pi/">here</a>.
Follow the instructions at the <a href="http://linux-sunxi.org/Cubieboard/TTL">Sunxi/TTL</a> page to connect up 3 of the cables to the right pins.</p>
<p>Connect the USB serial cable and run &quot;screen&quot; to monitor it:</p>
<pre><code>screen -h 10000 /dev/ttyUSB0 115200
</code></pre>
<p>Note: I tried using &quot;minicom&quot; first, but for some reason keyboard input didn't work with that.</p>
<p>Insert microSD card in board and connect power. You should see boot messages in screen:</p>
<pre><code>U-Boot SPL 2013.04-07297-gc8f265c (Jun 17 2013 - 17:26:22)
Board: Cubieboard2
DRAM: 1024MB
CPU: 960000000Hz, AXI/AHB/APB: 3/2/2
SUNXI SD/MMC: 0
</code></pre>
<p>You can connect a keyboard/mouse/screen and use it. The login is cubie/cubieboard.</p>
<p>If the device boots instead into Android then it is probably booting from NAND (it tries the microSD first, then the NAND).</p>
<h2>ARM Toolchain</h2>
<p>To build the various binaries (U-Boot, Linux, Xen), we need an <a href="http://linux-sunxi.org/Toolchain">ARM cross-compiler toolchain</a>.</p>
<p><a href="http://en.wikipedia.org/wiki/ARM_Cortex-A7_MPCore">The A20 has hardware FPU</a>, so use the hf version of the cross-compiler for best performance.</p>
<p>On Arch Linux, run:</p>
<pre><code>yaourt -S arm-linux-gnueabihf-gcc
</code></pre>
<p>On Debian testing, run (as root):</p>
<pre><code>apt-get install gcc-arm-none-eabi
</code></pre>
<p>On a modern Ubuntu, run:</p>
<pre><code>sudo apt-get install gcc-arm-linux-gnueabihf
</code></pre>
<p>This installs files such as, say, on Ubuntu:</p>
<pre><code>/usr/bin/arm-linux-gnueabihf-ld
/usr/bin/arm-linux-gnueabihf-gcc
</code></pre>
<p>Take note of the common prefix.  Define a variable to hold it:</p>
<pre><code>export CROSS_COMPILE=arm-linux-gnueabihf-
</code></pre>
<h2>U-Boot</h2>
<p>Xen needs to be started in non-secure HYP mode. Use this U-Boot Git repository:</p>
<pre><code>git clone git://github.com/jwrdegoede/u-boot-sunxi.git
cd u-boot-sunxi
git checkout -b sunxi-next origin/sunxi-next
</code></pre>
<p><strong>WARNING</strong> This branch no longer exists.</p>
<p>Note: only the &quot;sunxi-next&quot; branch has the required hypervisor support; DO NOT use the &quot;sunxi&quot; branch.</p>
<p>Configure and build U-Boot using the ARM toolchain:</p>
<pre><code>make CROSS_COMPILE=$CROSS_COMPILE Cubieboard2_config
make CROSS_COMPILE=$CROSS_COMPILE -j 4
</code></pre>
<h2>U-Boot configuration</h2>
<p>Create a directory for the boot commands (e.g. <code>boot</code>). Create
<code>boot/boot.cmd</code> whose content is the same as
<a href="https://github.com/mirage/xen-arm-builder/blob/master/boot/boot-cubieboard2.cmd">boot-cubieboard2.cmd</a>
for the Cubieboard2 or
<a href="https://github.com/mirage/xen-arm-builder/blob/master/boot/boot-cubietruck.cmd">boot-cubietruck.cmd</a>
for the Cubietruck.</p>
<p>The above is configured to:</p>
<ul>
<li>Load Xen, the FDT and Linux from <code>mmcblk0p1</code>
</li>
<li>Use <code>mmcblk0p2</code> as Linux's root FS
</li>
<li>Wait for the device (<code>rootwait</code>)
</li>
<li>Run <code>/bin/bash</code> as init.
</li>
</ul>
<p>More information on
<a href="http://www.denx.de/wiki/view/DULG/UBoot">the format of <code>boot.cmd</code></a>
is available on the <a href="http://www.denx.de/wiki/view/DULG/Manual">denx site</a>.</p>
<p>Create a <code>boot/Makefile</code> to compile it using
<a href="https://github.com/jwrdegoede/u-boot-sunxi/blob/sunxi/doc/mkimage.1">mkimage</a>:</p>
<pre><code>all: boot.scr

%.scr: %.cmd
    ../tools/mkimage -C none -A arm -T script -d &quot;$&lt;&quot; &quot;$@&quot;
</code></pre>
<p>Go to <code>boot</code> and run <code>make</code> to build <code>boot.scr</code>.</p>
<p>Remark: You may have noticed that the above <code>.cmd</code> files allocate a
rather large amount of memory to <code>dom0</code> (look at the <code>dom0_mem</code>
parameter).  This is needed to compile large libraries like
<a href="https://github.com/janestreet/core">Core</a>.
However, if you use <code>autoballoon=on</code> in
<a href="http://xenbits.xen.org/docs/unstable/man/xl.conf.5.html"><code>/etc/xen/xl.conf</code></a>,
<code>xl</code> will automatically reduce the amount of memory assigned to dom0
to free memory for new domains.  An OCaml daemon
<a href="https://github.com/xapi-project/squeezed">squeezed</a>, currently in
development (and based on
<a href="https://github.com/xapi-project/xenopsd">xenopsd</a>), will dynamically
move memory between dom0 and VMs to satisfy their needs.</p>
<h2>Building Linux</h2>
<p>Get my <a href="https://github.com/talex5/linux.git">Linux Git tree</a>, master branch. This fork has a few extra patches we need.</p>
<pre><code>cd ../..
git clone https://github.com/talex5/linux.git
cd linux
</code></pre>
<p>Configure:</p>
<pre><code>make ARCH=arm multi_v7_defconfig
make ARCH=arm menuconfig
</code></pre>
<p>Here are the settings I used (check it works with just these settings and whether they're all actually necessary):</p>
<pre><code>CONFIG_CROSS_COMPILE=&quot;/usr/bin/arm-linux-gnueabihf-&quot;
CONFIG_XEN_DOM0=y
CONFIG_XEN=y
CONFIG_IPV6=y
CONFIG_NETFILTER=y
CONFIG_NETFILTER_ADVANCED=y
CONFIG_BRIDGE_NETFILTER=y
CONFIG_STP=y
CONFIG_BRIDGE=y
CONFIG_SYS_HYPERVISOR=y
CONFIG_XEN_BLKDEV_FRONTEND=y
CONFIG_XEN_BLKDEV_BACKEND=y
CONFIG_AHCI_SUNXI=y
CONFIG_XEN_NETDEV_FRONTEND=y
CONFIG_XEN_NETDEV_BACKEND=y
CONFIG_INPUT_AXP20X_PEK=y
CONFIG_INPUT_XEN_KBDDEV_FRONTEND=y
CONFIG_HVC_DRIVER=y
CONFIG_HVC_IRQ=y
CONFIG_HVC_XEN=y
CONFIG_HVC_XEN_FRONTEND=y
CONFIG_MFD_AXP20X=y
CONFIG_REGULATOR_AXP20X=y
CONFIG_FB_SYS_FOPS=y
CONFIG_FB_DEFERRED_IO=y
CONFIG_XEN_FBDEV_FRONTEND=y
CONFIG_MMC_SUNXI=y
CONFIG_VIRT_DRIVERS=y
CONFIG_XEN_BALLOON=y
CONFIG_XEN_SCRUB_PAGES=y
CONFIG_XEN_DEV_EVTCHN=y
CONFIG_XEN_BACKEND=y
CONFIG_XENFS=y
CONFIG_XEN_COMPAT_XENFS=y
CONFIG_XEN_SYS_HYPERVISOR=y
CONFIG_XEN_XENBUS_FRONTEND=y
CONFIG_XEN_GNTDEV=y
CONFIG_XEN_GRANT_DEV_ALLOC=y
CONFIG_SWIOTLB_XEN=y
CONFIG_XEN_PRIVCMD=y
ONFIG_PHY_SUN4I_USB
CONFIG_HAS_IOPORT=y

# LVM
CONFIG_MD=y
CONFIG_BLK_DEV_DM_BUILTIN=y
CONFIG_BLK_DEV_DM=y
CONFIG_DM_BUFIO=y
CONFIG_DM_SNAPSHOT=y
</code></pre>
<p>A simpler alternative to <code>make ARCH=arm menuconfig</code> is to copy
<a href="https://github.com/mirage/xen-arm-builder/blob/master/config/config-cubie2"><code>config-cubie2</code></a>
to <code>.config</code>
(note that <code>CONFIG_CROSS_COMPILE</code> <em>must</em> have the value of <code>$CROSS_COMPILE</code>).</p>
<p>Then:</p>
<pre><code>make ARCH=arm zImage dtbs modules -j 4
</code></pre>
<h2>Building Xen</h2>
<p>Currently, some minor patches are needed to the official <a href="http://www.xenproject.org/downloads/xen-archives/xen-44-series/xen-440.html">Xen 4.4 release</a>, so use this Git version:</p>
<pre><code>cd ..
git clone -b stable-4.4 https://github.com/talex5/xen.git
cd xen
</code></pre>
<p>Edit <code>Config.mk</code> and turn debug on: <code>debug ?= y</code>.
This enables some features that are useful when debugging guests, such as allowing guests to write debug messages to the Xen console.</p>
<p>Note: If you already built Xen without debug, <code>make clean</code> is NOT sufficient! Use <code>git clean -xfd</code> for a clean build.</p>
<p>Compile with:</p>
<pre><code>make dist-xen XEN_TARGET_ARCH=arm32 CROSS_COMPILE=$CROSS_COMPILE CONFIG_EARLY_PRINTK=sun7i -j4
</code></pre>
<h2>Partitioning the SD card</h2>
<p>Source: <a href="http://linux-sunxi.org/Bootable_SD_card">Bootable SD card</a></p>
<p>Clear the device (maybe not really necessary):</p>
<pre><code>dd if=/dev/zero of=/dev/mmcblk0 bs=1M count=1
</code></pre>
<p>Create a partition table. I used gparted (Device -&gt; Create Partition Table -&gt; msdos).</p>
<p>Create the partitions (a 16 MB FAT boot partition, a 4 GB dom0 root, and the rest for the guests as an LVM volume):</p>
<pre><code>sfdisk -R /dev/mmcblk0
cat &lt;&lt;EOT | sudo sfdisk --in-order -uM /dev/mmcblk0
1,16,c
,4096,L
,,8e
EOT

mkfs.vfat /dev/mmcblk0p1
mkfs.ext4 /dev/mmcblk0p2
</code></pre>
<h2>Installing the bootloader</h2>
<p>Write the U-Boot SPL and main program:</p>
<pre><code>dd if=u-boot-sunxi-with-spl.bin of=/dev/mmcblk0 bs=1024 seek=8
</code></pre>
<p>Mount the fat partition and copy in <code>boot.scr</code>, the Linux kernel, the
FDT and Xen (you must create <code>/mnt/mmc1</code> if it does not exist):</p>
<pre><code>mount /dev/mmcblk0p1 /mnt/mmc1
cp u-boot-sunxi/boot/boot.scr /mnt/mmc1/
cp linux/arch/arm/boot/zImage /mnt/mmc1/vmlinuz
cp linux/arch/arm/boot/dts/sun7i-a20-cubieboard2.dtb /mnt/mmc1/
cp xen/xen/xen /mnt/mmc1/
umount /mnt/mmc1
</code></pre>
<p>For the Cubietruck, replace the third line with:</p>
<pre><code>cp linux/arch/arm/boot/dts/sun7i-a20-cubietruck.dtb /mnt/mmc1/
</code></pre>
<p>(You must run these commands as root or prefix them with <code>sudo</code>.)</p>
<h2>Root FS</h2>
<p>The wiki's links to the prebuilt root images are broken, but a bit of searching turns up some alternatives.</p>
<p>I used <a href="http://releases.linaro.org/14.05/ubuntu/trusty-images/developer/linaro-trusty-developer-20140522-661.tar.gz">linaro-trusty-developer-20140522-661.tar.gz</a>.</p>
<pre><code>mount /dev/mmcblk0p2 /mnt/mmc2
cd /mnt/mmc2
sudo tar xf /your/path/to/linaro-trusty-developer-20140522-661.tar.gz
sudo mv binary/* .
sudo rmdir binary
</code></pre>
<p>Go back to the directory where you compiled your Linux kernel and do:</p>
<pre><code>make ARCH=arm INSTALL_MOD_PATH='/mnt/mmc2' modules_install
</code></pre>
<p><code>/mnt/mmc2/etc/fstab</code> should contain:</p>
<pre><code>/dev/mmcblk0p2  / ext4   rw,relatime,data=ordered       0 1
</code></pre>
<p><code>/mnt/mmc2/etc/resolv.conf</code>:</p>
<pre><code>nameserver 8.8.8.8
</code></pre>
<p>Append to <code>/mnt/mmc2/etc/network/interfaces</code> (this sets up a bridge, which will be useful for guest networking):</p>
<pre><code>auto lo
iface lo inet loopback

auto eth0
iface eth0 inet manual
  up ip link set eth0 up

auto br0
iface br0 inet dhcp
  bridge_ports eth0
</code></pre>
<p>Unmount:</p>
<pre><code>umount /mnt/mmc2
</code></pre>
<h2>Boot process</h2>
<p>At this point, it's possible to boot and get the U-Boot prompt and run Xen and Dom0:</p>
<pre><code>U-Boot SPL 2014.04-rc2-01269-gf8616c0 (Apr 07 2014 - 18:53:46)
Board: Cubieboard2
DRAM: 1024 MiB
CPU: 960000000Hz, AXI/AHB/APB: 3/2/2
spl: not an uImage at 1600


U-Boot 2014.04-rc2-01269-gf8616c0 (Apr 07 2014 - 18:53:46) Allwinner Technology

CPU:   Allwinner A20 (SUN7I)
Board: Cubieboard2
I2C:   ready
DRAM:  1 GiB
MMC:   SUNXI SD/MMC: 0
*** Warning - bad CRC, using default environment

In:    serial
Out:   serial
Err:   serial
Net:   dwmac.1c50000
Warning: failed to set MAC address

Hit any key to stop autoboot:  0
</code></pre>
<p>The first bit &quot;U-Boot SPL&quot; is the SPL running, setting up the RAM and loading the main U-Boot.
The &quot;spl: not an uImage at 1600&quot; warning is harmless. It looks at offset 1600 first, and then tries 80 next and succeeds.</p>
<p>The &quot;bad CRC&quot; warning is just because we didn't specify an environment file.</p>
<h2>Dom0 setup</h2>
<p>After booting, you should get a root prompt. Install openssh:</p>
<pre><code>mount -o remount,rw /
mount -t proc proc /proc
export PATH=/bin:/usr/bin:/sbin:/usr/sbin
export HOME=/root
ifup eth0
ip addr show dev eth0
apt-get install openssh-server
</code></pre>
<p>Add your ssh key:</p>
<pre><code>cd
mkdir .ssh
vi .ssh/authorized_keys
</code></pre>
<p>Install Avahi:</p>
<pre><code>apt-get install avahi-daemon libnss-mdns
</code></pre>
<p>You must also install these packages and <code>avahi-utils</code> on your
computer.</p>
<p>You probably want to give your Cubieboard a nice name.  Edit
<code>/etc/hostname</code> and replace the existing name with the one of your
choice — <code>cubie2</code> for the following.
(You should also change <code>linaro-developer</code> in <code>/etc/hosts</code>
to <code>cubie2</code>.)
For the changes to take effect, you can either reboot or run
<code>hostname cubie2</code> followed by <code>/etc/init.d/avahi-daemon restart</code>.
You should now be able to connect with e.g., from your computer</p>
<pre><code>ssh root@cubie2.local
</code></pre>
<p>To see the list of Avahi services on your network, do <code>avahi-browse -alr</code>.  If you do not see your Cubieboard, check that its network is
up: doing</p>
<pre><code>ip addr show
</code></pre>
<p>at the Cubieboard root prompt, should output some information
including a line starting with <code>br0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</code>.  If it doesn't try</p>
<pre><code>brctl addbr br0
</code></pre>
<p>If you get <code>add bridge failed: Package not installed</code>, you forgot to
include Ethernet bridging in your kernel (it is included with the
recommended <code>.config</code> file above so this should not happen).</p>
<p>Kill the network and shut down:</p>
<pre><code>ifdown eth0
mount -o remount,ro /
halt -f
</code></pre>
<p>Remove the <code>init=/bin/bash</code> from <code>boot.cmd</code> and put the new <code>boot.scr</code> into mmcblk0p1. Then boot again.
You should now be able to ssh in directly.</p>
<h2>Xen toolstack</h2>
<p>Ssh to your Cubieboard and install the Xen tools:</p>
<pre><code>apt-get install xen-utils-4.4
</code></pre>
<p>Once Xen 4.4 is installed, you can list your domains:</p>
<pre><code># xl list
Name                                        ID   Mem VCPUs      State   Time(s)
Domain-0                                     0   512     2     r-----      19.7
</code></pre>
<h2>LVM configuration</h2>
<p>Install the LVM tools in dom0 and set up the volume group:</p>
<pre><code>apt-get install lvm2
pvcreate /dev/mmcblk0p3
vgcreate vg0 /dev/mmcblk0p3
</code></pre>
<h2>Linux DomU</h2>
<p>Source: <a href="http://wiki.xenproject.org/wiki/Xen_ARM_with_Virtualization_Extensions/RootFilesystem">Xen ARM with Virtualization Extensions/RootFilesystem</a></p>
<p>Create a new LVM partition for the guest's root FS and format it:</p>
<pre><code>lvcreate -L 4G vg0 --name linux-guest-1
/sbin/mkfs.ext4 /dev/vg0/linux-guest-1
</code></pre>
<p>Note: we're going to make a fairly big VM, as we'll be using it as a build machine soon.</p>
<p>Mount it and install an OS (e.g. Ubuntu 14.04 here):</p>
<pre><code>mount /dev/vg0/linux-guest-1 /mnt
debootstrap --arch armhf trusty /mnt
chroot /mnt
passwd
</code></pre>
<p>Edit <code>/etc/hostname</code>, <code>/etc/network/interfaces</code>:</p>
<pre><code>auto eth0
iface eth0 inet dhcp
</code></pre>
<p><code>/etc/fstab</code> should contain:</p>
<pre><code>/dev/xvda       / ext4   rw,relatime,data=ordered       0 1
</code></pre>
<p>Add any extra software you want:</p>
<pre><code>apt-get install openssh-server
mkdir -m 0700 /root/.ssh
vi /root/.ssh/authorized_keys
</code></pre>
<p>Note: openssh will fail to start as port 22 is taken, but it still installs.</p>
<p>Unmount:</p>
<pre><code>exit
umount /mnt
</code></pre>
<p>Copy the Linux kernel image into /root (the dom0 one is fine). Create <code>domU_test</code>:</p>
<pre><code>kernel = &quot;/root/zImage&quot;
memory = 512
name = &quot;Ubuntu-14.04&quot;
vcpus = 2
serial=&quot;pty&quot;
disk = [ 'phy:/dev/vg0/linux-guest-1,xvda,w' ]
vif = ['bridge=br0']
extra = 'console=hvc0 xencons=tty root=/dev/xvda'
</code></pre>
<p>You should now be able to boot the Linux guest:</p>
<pre><code>xl create domU_test -c
</code></pre>
<h2>FreeBSD guest</h2>
<p>Source: <a href="http://lists.freebsd.org/pipermail/freebsd-xen/2014-January/001974.html">Add support for Xen ARM guest on FreeBSD</a></p>
<p>I created a VM on my laptop and installed FreeBSD from <a href="http://www.freebsd.org/where.html">FreeBSD-10.0-RELEASE-amd64-bootonly.iso</a>. I then used that to cross-compile the Xen/ARM version. Your build VM will need to have at least 4 GB of disk space.</p>
<p>Get the <code>xen-arm-v2</code> branch:</p>
<pre><code>git clone git://xenbits.xen.org/people/julieng/freebsd.git -b xen-arm-v2
</code></pre>
<p>Note: I tested with the <code>xen-arm</code> branch, but the <code>xen-arm-v2</code> branch has some useful fixes.</p>
<p>Note: Installing Git using FreeBSD using ports on a clean system is very slow, uses a lot of disk space, requires many confirmations and, in my case, failed. So I suggest cloning the repository with your main system and then transferring the files directly to the FreeBSD build VM instead.</p>
<p>In the build FreeBSD (note: the build takes several hours; you might want to assign multiple CPUS to your VM and use <code>-j</code> here):</p>
<pre><code>cd freebsd
truncate -s 512M xenvm.img
mdconfig -f xenvm.img -u0
newfs /dev/md0
mount /dev/md0 /mnt

make TARGET_ARCH=armv6 kernel-toolchain
make TARGET_ARCH=armv6 KERNCONF=XENHVM buildkernel
make TARGET_ARCH=armv6 buildworld
make TARGET_ARCH=armv6 DESTDIR=/mnt installworld distribution

echo &quot;/dev/xbd0 / ufs rw 1 1&quot; &gt; /mnt/etc/fstab
echo 'xc0 &quot;/usr/libexec/getty Pc&quot; xterm on secure' &gt;&gt; /mnt/etc/ttys

umount /mnt
mdconfig -d -u0
</code></pre>
<p>Then you can copy <code>xenvm.img</code> and the kernel (<code>/usr/obj/arm.armv6/root/freebsd/sys/XENHVM/kernel</code>) to dom0 on the Cubieboard2.
You might want to rename the kernel (e.g. to <code>freebsd-kernel</code>).</p>
<p>Create a new partition for it and copy the filesystem in:</p>
<pre><code>lvcreate --name freebsd -L 512M vg0
dd if=xenvm.img of=/dev/vg0/freebsd
</code></pre>
<p>Here's a suitable <code>freebsd.cfg</code> config file:</p>
<pre><code>kernel=&quot;freebsd-kernel&quot;
memory=64
name=&quot;freebsd&quot;
vcpus=1
autoballon=&quot;off&quot;
disk=[ 'phy:/dev/vg0/freebsd,xvda,w' ]
</code></pre>
<p>If you try to start the domain with Debian's version of <code>xl</code>, you'll get <code>Unable to find arch FDT info for xen-3.0-unknown</code>.
To fix this, you need to rebuild the Xen toolstack with these two patches (I applied them to the <code>stable-4.4</code> branch):</p>
<ul>
<li>https://patches.linaro.org/22228/
</li>
<li>https://patches.linaro.org/22227/
</li>
</ul>
<p>Build it using the ARM build guest:</p>
<pre><code>cd xen/tools
./configure --prefix=/opt/xen-freebsd
make
make install
</code></pre>
<p>Transfer <code>/opt/xen-freebsd</code> to dom0 and you can then start the FreeBSD domain with:</p>
<pre><code>export LD_LIBRARY_PATH=/opt/xen-freebsd/lib/
/opt/xen-freebsd/sbin/xl create -c freebsd.cfg
</code></pre>
<p>You should get a root prompt:</p>
<pre><code># uname -a
FreeBSD  11.0-CURRENT FreeBSD 11.0-CURRENT #2: Tue Apr 15 20:37:04 BST 2014     root@freebsd:/usr/obj/arm.armv6/root/freebsd/sys/XENHVM  arm
</code></pre>
<h2>Xen Mini-OS</h2>
<p>Mini-OS is a small demonstration OS for Xen. I had to make some changes to the (experimental) ARM version to make it work on the Cubieboard2.
You'll need to install a few things to build it:</p>
<pre><code>apt-get install build-essential libfdt-dev git
</code></pre>
<p>Clone the repository and build:</p>
<pre><code>git clone -b devel https://github.com/talex5/xen.git
cd xen/extras/mini-os
make
</code></pre>
<p>Transfer the resulting <code>mini-os.img</code> to your dom0 and add a configuration file for it:</p>
<pre><code>kernel = &quot;/root/mini-os.img&quot;
memory = 128
name = &quot;Mini-OS&quot;
vcpus = 1
serial=&quot;pty&quot;
disk = [ 'phy:/dev/vg0/mini-os,xvda,w' ]
vif = ['bridge=br0']
</code></pre>
<p>Create a disk for it:</p>
<pre><code>lvcreate -L 8M vg0 --name mini-os
</code></pre>
<p>You should now be able to start it:</p>
<pre><code>xl create mini-os.cfg
</code></pre>
<p>On success, it will write lots of text to the Xen console (note: this requires a debug build of Xen):</p>
<pre><code>(d6) dtb_pointer : 87fff000
(d6) MM: Init
(d6)     _text: 80008000(VA)
(d6)     _etext: 80018f1c(VA)
(d6)     _erodata: 8001b000(VA)
(d6)     _edata: 8002820c(VA)
(d6)     stack start: 8001c000(VA)
(d6)     _end: 8002dee0(VA)
(d6)     start_pfn: 80415
(d6)     max_pfn: 8282d
(d6) MM: Initialise page allocator for 80415000(80415000) - 0(8282d000)
(d6) MM: done
(d6) Initialising timer interface
...
</code></pre>
<p>You can now try <a href="/blog/introducing-xen-minios-arm">running a MirageOS unikernel</a>.</p>
|js};
      };
      {
        updated = {js|2014-02-02 17:56|js};
        author =
          {
            name = {js|Dave Scott|js};
            uri = Some {js|http://dave.recoil.org/|js};
            email = Some {js|dave@recoil.org|js};
          };
        subject = {js|Synthesizing virtual disks for Xen|js};
        permalink = {js|xen-synthesize-virtual-disk|js};
        body =
          {js|<p>[ updated 2014-02-01 for mirage.1.1.0 and xen-disk.1.2.1 ]</p>
<p>This page describes how to create a synthetic, high-performance
virtual disk implementation for Xen based on the MirageOS libraries.</p>
<h2>Disk devices under Xen</h2>
<p>The protocols used by Xen disk and network devices are designed to
permit fast and efficient software implementations, avoiding the
inefficiencies inherent in emulating physical hardware in software.
The protocols are based on two primitives:</p>
<ul>
<li><em>shared memory pages</em>: used for sharing both data and metadata
</li>
<li><em>event channels</em>: similar to interrupts, these allow one side to signal the other
</li>
</ul>
<p>In the disk block protocol, the protocol starts with the client
(&quot;frontend&quot; in Xen jargon) sharing a page with the server (&quot;backend&quot;).
This single page will contain the request/response metadata, arranged
as a circular buffer or &quot;ring&quot;. The client (&quot;frontend&quot;) can then start
sharing pages containing disk blocks with the backend and pushing request
structures to the ring, updating shared pointers as it goes. The client
will give the server end a kick via an event channel signal and then both
ends start running simultaneously. There are no locks in the protocol so
updates to the shared metadata must be handled carefully, using write
memory barriers to ensure consistency.</p>
<h3>Xen disk devices in MirageOS</h3>
<p>Like everything else in MirageOS, Xen disk devices are implemented as
libraries. The following libraries are used:</p>
<ul>
<li><a href="https://github.com/mirage/io-page">io-page</a>:
for representing raw memory pages
</li>
<li><a href="https://github.com/xapi-project/ocaml-gnt">xen-gnt</a>:
APIs for &quot;granting&quot; pages to other domains and &quot;mapping&quot; pages granted to us
</li>
<li><a href="https://github.com/xapi-project/ocaml-evtchn">xen-evtchn</a>:
APIs for signalling other VMs
</li>
<li><a href="https://github.com/mirage/shared-memory-ring">shared-memory-ring</a>:
manipulates shared memory request/response queues
used for paravirtualised disk and network devices. This library is a mix of
99.9% OCaml and 0.1% asm, where the asm is only needed to invoke memory
barriers, to ensure that metadata writes issued by one CPU core appear
in the same order when viewed by another CPU core.
</li>
<li><a href="https://github.com/mirage/mirage-block-xen">mirage-block-xen</a>:
frontend (&quot;blkfront&quot;) and backend (&quot;blkback&quot;) implementations
</li>
</ul>
<p>Note that all these libraries work equally well in userspace (for development
and debug) and kernelspace (for production): the target is chosen at
link-time.</p>
<h2>Userspace disk implementations</h2>
<p>Userspace MirageOS apps are ideal for development, since they have access to
the full suite of Unix debug and profiling tools. Once written, the exact
same code can be relinked and run directly in kernelspace for maximum
performance.</p>
<p>The <a href="https://github.com/mirage/xen-disk">xen-disk</a> demonstrates how to
create a synthetic Xen virtual disk. To compile it, first, install
<a href="http://www.xen.org/">Xen</a> (including the -dev, or -devel packages),
<a href="http://www.ocaml.org/">OCaml</a> and <a href="http://opam.ocamlpro.com/">OPAM</a>.</p>
<p>Second initialise your system:</p>
<pre><code>  opam init
  eval `opam config env`
</code></pre>
<p>Third install the unmodified <code>xen-disk</code> package, this will ensure all the build
dependencies are installed:</p>
<pre><code>  opam install xen-disk
</code></pre>
<p>When this completes it will have installed a command-line tool called
<code>xen-disk</code>. If you start a VM using your Xen toolstack of choice
(&quot;xl create ...&quot; or &quot;xe vm-install ...&quot; or &quot;virsh create ...&quot;) then you
should be able to run:</p>
<pre><code>  xen-disk connect &lt;vmname&gt;
</code></pre>
<p>which will hotplug a fresh block device into the VM &quot;vmname&quot; using the
&quot;discard&quot; backend, which returns &quot;success&quot; to all read and write requests,
but actually throws all data away. Obviously this backend should only be
used for basic testing!</p>
<p>Assuming that worked ok, clone and build the source for <code>xen-disk</code> yourself:</p>
<pre><code>  git clone git://github.com/mirage/xen-disk
  cd xen-disk
  make
</code></pre>
<h2>Making a custom virtual disk implementation</h2>
<p>The <code>xen-disk</code> program can use any MirageOS disk implementation satisfying
Mirage
<a href="https://github.com/mirage/mirage/blob/master/types/V1.mli#L134">BLOCK signature</a>.
The key functions are:</p>
<ul>
<li><a href="https://github.com/mirage/mirage/blob/master/types/V1.mli#L40">connect</a>:
to open a connection to a named device
</li>
<li><a href="https://github.com/mirage/mirage/blob/master/types/V1.mli#L164">read</a>:
to fill application buffers with block device data
</li>
<li><a href="https://github.com/mirage/mirage/blob/master/types/V1.mli#L170">write</a>:
to write application buffers to the block device
</li>
</ul>
<p>By default <code>xen-disk</code> uses the following disk implementations:</p>
<ul>
<li><a href="https://github.com/mirage/mirage-block-unix">mirage-block-unix</a>: reads and writes
to/from an existing Unix file or block device
</li>
<li><a href="https://github.com/djs55/ocaml-vhd">vhd-format</a>: reads and writes data encoded
in the .vhd file format (as used by XenServer and Hyper-V)
</li>
<li><a href="https://github.com/mirage/xen-disk/blob/master/src/backend.ml#L45">DISCARD</a>:
returns <code>Ok ()</code> to all requests without doing any work (typically used for
performance testing the ring code)
</li>
</ul>
<p>Let's make a virtual disk implementation which uses an existing disk
image file as a &quot;gold image&quot;, but uses copy-on-write so that no writes
persist.
This is a common configuration in Virtual Desktop Infrastructure deployments
and is generally handy when you want to test a change quickly, and
revert it cleanly afterwards.
A useful Unix technique for file I/O is to &quot;memory map&quot; an existing file:
this associates the file contents with a range of virtual memory addresses
so that reading and writing within this address range will actually
read or write the file contents.
The &quot;mmap&quot; C function has a number of flags, which can be used to request
&quot;copy on write&quot; behaviour. Reading the
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Bigarray.Genarray.html">OCaml manual Bigarray.map_file</a>
it says:</p>
<blockquote>
<p>If shared is true, all modifications performed on the array are reflected
in the file. This requires that fd be opened with write permissions. If
shared is false, modifications performed on the array are done in memory
only, using copy-on-write of the modified pages; the underlying file is
not affected.</p>
</blockquote>
<p>So we should be able to make a virtual disk implementation which memory
maps the image file and achieves copy-on-write by setting &quot;shared&quot; to false.
For extra safety we can also open the file read-only.</p>
<p>Luckily there is already an
<a href="https://github.com/mirage/xen-disk/blob/master/src/backend.ml#L72">&quot;mmap&quot; implementation</a>
in <code>xen-disk</code>; all we need to do is tweak it slightly.
In the &quot;connect&quot; function we simply need to set &quot;shared&quot; to &quot;false&quot; to
achieve the behaviour we want i.e.</p>
<pre><code>let connect id =
  let fd = Unix.openfile (filename_of_id id) [ Unix.O_RDONLY ] 0o0 in
  let stats = Unix.LargeFile.fstat fd in
  let mmap = Cstruct.of_bigarray (Lwt_bytes.map_file ~fd ~shared:false ()) in
  Unix.close fd;
  let size = stats.Unix.LargeFile.st_size in
  return (`Ok { id; size; mmap })
</code></pre>
<p>The read and write functions can be left as they are:</p>
<pre><code>let forall offset bufs f =
  let rec loop offset = function
  | [] -&gt; ()
  | b :: bs -&gt;
    f offset b;
    loop (offset + (Cstruct.len b)) bs in
  loop (Int64.to_int offset * 512) bufs;
  return (`Ok ())

let read t offset bufs =
  forall offset bufs
    (fun offset buf -&gt;
      Cstruct.blit t.mmap offset buf 0 (Cstruct.len buf)
    )

let write t offset bufs =
  forall offset bufs
    (fun offset buf -&gt;
      Cstruct.blit buf 0 t.mmap offset (Cstruct.len buf)
    )
</code></pre>
<p>Now if we rebuild and run something like:</p>
<pre><code>  dd if=/dev/zero of=disk.raw bs=1M seek=1024 count=1

  dist/build/xen-disk/xen-disk connect &lt;myvm&gt; --path disk.raw --backend mmap
</code></pre>
<p>Inside the VM we should be able to do some basic speed testing:</p>
<pre><code>  djs@ubuntu1310:~$ sudo dd if=/dev/xvdg of=/dev/null bs=1M
  16+0 records in
  16+0 records out
  16777216 bytes (17 MB) copied, 0.0276625 s, 606 MB/s
</code></pre>
<p>Plus we should be able to mount the filesystem inside the VM, make changes and
then disconnect (send SIGINT to xen-disk by hitting Control+C on your terminal)
without disturbing the underlying disk contents.</p>
|js};
      };
      {
        updated = {js|2014-02-01 01:00|js};
        author =
          {
            name = {js|Jon Ludlam|js};
            uri = Some {js|http://jon.recoil.org|js};
            email = Some {js|jon@recoil.org|js};
          };
        subject = {js|How Xen suspend and resume works|js};
        permalink = {js|xen-suspend|js};
        body =
          {js|<p>This article is part of a series documenting how MirageOS applications run under
<a href="http://www.xenproject.org/">Xen</a>. This article is about suspend, resume and
live migration.</p>
<h4>Background</h4>
<p>One of the important advantages of using virtual machines (VMs)
over physical machines to run your operating systems is that
management of VMs is simpler and more powerful than managing physical
computers. One new tool in the management toolkit is that of
suspending and resuming to a state file. In many ways equivalent to
shutting the lid on a laptop and having it go to sleep, a VM can be
suspended such that it no longer consumes any memory or CPU resources
on its host, and resumed at a later point when required. Unlike a
laptop, the state of the VM is encapsulated in a state
file on disk, which can be copied if you want to take a backup,
replicated many times if you want to have multiple instances of your
VM running, or copied to another physical host if you would like to
run it elsewhere. This operation also forms the basis of live
migration, where a running VM has its state replicated to another
physical host in such a way that its execution can be stopped on the
original host and almost immediately started on the destination, and
users of the services provided by that VM are none the wiser.</p>
<p>For VMs using hardware virtualization instead of
<a href="http://en.wikipedia.org/wiki/Paravirtualization">paravirtualization</a>, doing
this is actually relatively straightforward. The VM is stopped from executing,
then the memory is saved to disk, and the state of any device emulator (qemu,
in xen's case) is also persisted to disk. To resume, load the qemu
state back in, restore the memory, and unpause your domain. The
OS within the VM continues running, unaware that anything has
changed.</p>
<p>However, most operating systems inside VMs have software installed
that is aware that it is running in a VM, and generally speaking, this
is where work is required to ensure that these components survive a
suspend and resume. In the case of the MirageOS Xen unikernels, it is
mainly the IO devices that need to be aware of the changes that happen
over the course of the operation. Since our unikernels are not fully
virtualised but are paravirtualised kernels, there is also some
infrastructure work that is required. The aim of this page is to
document how these operations work.</p>
<h4>Philosophy</h4>
<p>The guiding principle in this work is to minimise the number of
exceptional conditions that have to be handled. In some cases,
application must be made aware that they have gone through a
suspend/resume cycle - for example, anything that is communicating
with xenstore. However, in most cases, the application logic
doesn't have to be aware of anything in particular happening.
For example, the block and network layers can reissue requests that were
in flight at the time of the suspend, and therefore any applications
using these can carry on without any special logic required.</p>
<h4>Walkthrough</h4>
<p>To explain the process of suspend and resume in MirageOS Xen guests,
we will walk though the various operations in sequence.</p>
<h4>Suspend</h4>
<p>The suspend example in the <a href="https://github.com/mirage/mirage-skeleton">mirage-skeleton</a> repository
contains the control logic needed to get the guest to be able to
suspend, and is therefore a good place to start looking.
The first thing that happens when a suspend is requested is that the
toolstack organising the operation will signal to the guest that it
should begin the process. This can be done via several mechanisms, but
the one supported in MirageOS today is by writing a particular key to
xenstore:</p>
<pre><code>/local/domain/&lt;n&gt;/control/shutdown = &quot;suspend&quot;
</code></pre>
<p>The code that watches for this path is
<a href="https://github.com/mirage/mirage-skeleton/blob/b9729f90cfd2c0ddf39a1217749440f2a9288090/suspend/mirage_guest_agent.ml#L17">here</a>.
The guest then acknowledges this by
<a href="https://github.com/mirage/mirage-skeleton/blob/b9729f90cfd2c0ddf39a1217749440f2a9288090/suspend/mirage_guest_agent.ml#L21">removing the key</a>.
It then jumps to the suspend code in
<a href="https://github.com/mirage/mirage-platform/blob/a47758c696797498e3eb7f3aac90830e2993090d/xen/lib/sched.ml#L32">sched.ml</a>.</p>
<p>The first thing that happens there is that we call the Xenstore
library to
<a href="https://github.com/mirage/ocaml-xenstore/blob/master/client/xs_client_lwt.ml#L227">suspend Xenstore</a>. This
works by waiting for any in-flight requests to be responded to, then
cancelling any threads that are waiting on watches. These have to be
cancelled because watches rely on state in the xenstore daemon and
therefore have to be reissued (potentially with different paths) when the VM resumes.</p>
<p>Then, the
<a href="https://github.com/mirage/mirage-platform/blob/a47758c696797498e3eb7f3aac90830e2993090d/xen/lib/sched.ml#L35">grant tables are suspended</a>
via the call to Gnt.suspend, which ends up calling a
<a href="https://github.com/mirage/mirage-platform/blob/a47758c696797498e3eb7f3aac90830e2993090d/xen/runtime/kernel/gnttab_stubs.c#L164">c function</a>
in the MirageOS kernel code. The main reason for calling this is that
the mechanism by which the grant code works is via shared memory
pages, and these pages are <a href="https://github.com/mirage/xen/blob/8940a13d6de1295cfdc4a189e0a5610849a9ef59/xen/common/grant_table.c#L1239">owned by xen</a> and not by the domain itself,
which causes problems when suspending the VM as we will see shortly.
Although the grant pages are mapped on demand, and thus could be
remapped before we've finished, this is fine as
we are actually now in a non-blocking part of the suspend code, and no other
Lwt threads will be scheduled.</p>
<p>At this point we call the C function in
<a href="https://github.com/mirage/mirage-platform/blob/a47758c696797498e3eb7f3aac90830e2993090d/xen/runtime/kernel/sched_stubs.c#L48">sched_stubs.c</a>.
The first thing done there is to rewrite two fields in the start_info
page: The MFNs of the xenstore page (store_mfn) and of the console
page (console_mfn) are turned into PFNs. This is done so that when
the guest is resumed, xenstored and xenconsoled can be given the pages
that the guest is expecting to talk to them on. It is the restore code in
libxc where the <a href="https://github.com/mirage/xen/blob/8940a13d6de1295cfdc4a189e0a5610849a9ef59/tools/libxc/xc_domain_restore.c#L2035">remapping takes place</a>.</p>
<p>We then <a href="https://github.com/mirage/mirage-platform/blob/a47758c696797498e3eb7f3aac90830e2993090d/xen/runtime/kernel/sched_stubs.c#L59">unmap the shared_info page</a>.
This is required because the shared_info page again belongs to
xen rather than to the guest, in a similar fashion to the grant
pages. The page is allocated <a href="https://github.com/mirage/xen/blob/8940a13d6de1295cfdc4a189e0a5610849a9ef59/xen/arch/x86/domain.c#L543">during domain creation</a>.</p>
<p>We are now in a position to do the <a href="https://github.com/mirage/mirage-platform/blob/a47758c696797498e3eb7f3aac90830e2993090d/xen/runtime/kernel/sched_stubs.c#L62">actual suspend hypercall</a>.
Interestingly, the suspend hypercall is defined in the header as a
<a href="https://github.com/mirage/mirage-platform/blob/a47758c696797498e3eb7f3aac90830e2993090d/xen/runtime/include/mini-os/x86/hypercall-x86_64.h#L293">three parameter call</a>,
but the implementation in xen <a href="https://github.com/mirage/xen/blob/8940a13d6de1295cfdc4a189e0a5610849a9ef59/xen/common/schedule.c#L924">ignores the 3rd parameter 'srec'</a>.
This is actually used by libxc to <a href="https://github.com/mirage/xen/blob/8940a13d6de1295cfdc4a189e0a5610849a9ef59/tools/libxc/xc_domain_save.c#L1882">locate the start_info page</a>.
Also of note is that xen will always return success when the domain
has suspended, but the hypercall has the notion of being 'cancelled',
by which it means the guest has woken up in the same domain as it
was when it called the hypercall. This is achieved by having libxc
<a href="https://github.com/mirage/xen/blob/8940a13d6de1295cfdc4a189e0a5610849a9ef59/tools/libxc/xc_resume.c#L105">alter the VCPU registers</a> on resume.</p>
<p>At this point, the domain will now be shutdown with reason 'suspend',
There is still work that needs to be done however. PV guests have
pagetables that reference the real MFNs rather than PFNs, so when
the guest is resumed into a different area of a hosts memory,
these will need to be rewritten. This is done by <a href="https://github.com/mirage/xen/blob/8940a13d6de1295cfdc4a189e0a5610849a9ef59/tools/libxc/xc_domain_save.c#L420">canonicalizing</a>
the pagetables, which in this context means replacing the MFNs with
PFNs. Since the function that maps MFNs to PFNs is only partial,
this fails if any of the MFNs are outside of the domain's memory.
This is the reason that all foreign pages such as the grant table
pages and the shared info page needed to be unmapped before
suspending.</p>
<p>We are now in a position to write the guests memory to disk in
the suspend image format. If a device emulator (qemu) was running,
it would also have its state dumped at this point ready to be
resumed later.</p>
<h4>Resume</h4>
<p>When the VM is resumed, libxc loads the saved image back into memory.
It then locates the pagetables, and 'uncanonicalizes' them back from
PFNs to the new MFNs.
The next task is to
rewrite the VCPU registers to pass back the suspend return code as
mentioned previously and then we are ready to unpause the new domain. At this point,
control is handed back to the MirageOS guest as if the hypercall has just
returned. At this point, the domain is close to the state of a cleanly
started guest, and so we have to <a href="https://github.com/mirage/mirage-platform/blob/a47758c696797498e3eb7f3aac90830e2993090d/xen/runtime/kernel/sched_stubs.c#L69">reinitialize</a> many of the same things
that are done on startup, including enabling event delivery, initialising
the timers and so on.</p>
<p>We then return to the ocaml code, and
<a href="https://github.com/mirage/mirage-platform/blob/a47758c696797498e3eb7f3aac90830e2993090d/xen/lib/sched.ml#L39">increment the generation count of the event channels</a>, which is explained below.
Then, we
<a href="https://github.com/xapi-project/ocaml-xen-lowlevel-libs/blob/ac112b963a3d91cd3ceb414bb5dc0b723b761b2b/lib/gnt.ml#L277">resume the grant tables</a>,
which currently is a
<a href="https://github.com/mirage/mirage-platform/blob/a47758c696797498e3eb7f3aac90830e2993090d/xen/runtime/kernel/gnttab_stubs.c#L171">no-op</a>
as the table is
<a href="https://github.com/xapi-project/ocaml-xen-lowlevel-libs/blob/ac112b963a3d91cd3ceb414bb5dc0b723b761b2b/lib/gnt.ml#L277">mapped on first (re)use</a>.
The activations thread is then
<a href="https://github.com/mirage/mirage-platform/blob/a47758c696797498e3eb7f3aac90830e2993090d/xen/lib/activations.ml#L95">restored</a>,
and we then
<a href="https://github.com/mirage/mirage-platform/blob/a47758c696797498e3eb7f3aac90830e2993090d/xen/lib/xs.ml#L89">restore Xenstore</a>. This
is done in this order to satisfy interdependencies - activations need
event channels working, xenstore needs grant tables and
activations. Once this is done we can move on to a more generic set of resume items: we iterate through a list of other post-resume
tasks, populated by other modules (such as <a href="https://github.com/mirage/mirage-block-xen">mirage-block-xen</a> which are currently assumed to be dependency free.</p>
<p>An example of a resume hook can be seen in the block driver
package, which is added when the module initialises.
It registers a <a href="https://github.com/mirage/mirage-block-xen/blob/master/lib/blkfront.ml#L339">callback</a> that
iterates through the list of connected devices and re-plugs them.
It then calls <a href="https://github.com/mirage/shared-memory-ring/blob/61fe10539b0783ab57f84fe20a25dde9b6018ade/lwt/lwt_ring.ml#L90">shutdown</a>
which wakes up every thread waiting for a response with an
exception, and also any thread that is waiting for a free slot.
These exceptions are handled back in <a href="https://github.com/mirage/mirage-block-xen/blob/master/lib/blkfront.ml#L232">mirage-block-xen</a>,
which simply retries the whole operation, being careful to use the
refreshed information about the backend.</p>
<p>The only thread that might possibly be running is the
<a href="https://github.com/mirage/mirage-block-xen/blob/master/lib/blkfront.ml#L78">service thread</a>
that takes responses from the ring and demultiplexes them, and this
thread will be killed when it attempts to wait on the
<a href="/wiki/xen-events">event channel</a>. Whenever an event channel is bound,
we pair up the integer event channel number with a 'generation count'
that is incremented on resume. Whenever the MirageOS guest attempts to
wait for a signal from an event channel, the generation count is
checked, and a stale generation results in a Lwt thread failure. The
generation count is <em>not</em> checked when attempting to notify via an
event channel, as this is a benign failure - it is only if we try to
wait for a notification that the error occurs. Any threads that were
already waiting at the point the domain suspended will be killed on
resume by the
<a href="https://github.com/mirage/mirage-platform/blob/b5641b343c2bfbd1048d124ee0b77e2b051588dd/xen/lib/activations.ml#L96">activations</a>
logic. In the case of the block device, this error mode is handled by
simply letting the thread die. A new one will have been set up during
the resume as part of the replug.</p>
<h4>Migration</h4>
<p>Live migration also uses this mechanism to move a running VM from one
host to another with very little downtime. In this case, when the
migration begins, the guest is switched to <a href="https://github.com/mirage/xen/blob/8940a13d6de1295cfdc4a189e0a5610849a9ef59/tools/libxc/xc_domain_save.c#L955">log-dirty</a> mode, where the
hypervisor starts to track which of the guests pages have been written
to. The toolstack can then iteratively go through these pages and
send them to the destination using the same protocol as suspending to
disk, but this time unmarshalling them straight back into memory. When it <a href="https://github.com/mirage/xen/blob/8940a13d6de1295cfdc4a189e0a5610849a9ef59/tools/libxc/xc_domain_save.c#L1537">decides</a> it has done enough iteratively, it then invokes the
suspend logic above and sends through only the last few dirty
pages, which will be much faster than the entire memory image. The
resume logic is then invoked and the domain starts running again.</p>
|js};
      };
      {
        updated = {js|2013-12-29 17:00|js};
        author =
          {
            name = {js|Dave Scott|js};
            uri = Some {js|http://dave.recoil.org/|js};
            email = Some {js|dave@recoil.org|js};
          };
        subject = {js|Understanding Xen events with MirageOS|js};
        permalink = {js|xen-events|js};
        body =
          {js|<p>This article is part of a series documenting how MirageOS applications run under
<a href="http://www.xenproject.org/">Xen</a>. This article is about &quot;events&quot;; i.e. how
can an app wait for input to arrive and tell someone that output is available?</p>
<h4>Background: Xen, domains, I/O, etc</h4>
<p>A running virtual machine under Xen is known as a <a href="http://wiki.xen.org/wiki/Xen_Overview">domain</a>.
A domain has a number of virtual CPUs (vCPUs) which run until the Xen scheduler
decides to pre-empt them, or until they ask to block via a <em>hypercall</em> (a
system call to the hypervisor).  A typical domain has no direct hardware access
and instead performs I/O by talking to other privileged <em>driver domains</em> (often
domain 0) via Xen-specific disk and network protocols. These protocols use two
primitives:</p>
<ol>
<li><em>granting</em> another domain access to your memory (which then
may be <em>shared</em> or <em>copied</em>); and
</li>
<li>sending and receiving <em>events</em> to and from another domain via
<em>event channels</em>.
</li>
</ol>
<p>This article focuses on how <em>events</em> work; a future article will describe how
shared memory works.</p>
<h4>What is an event channel?</h4>
<p>An <em>event channel</em> is a logical connection between (domain_1, port_1) and
(domain_2, port_2) where port_1 and port_2 are integers, like TCP port numbers
or Unix file descriptors. An <em>event</em> sent from one domain will cause the other
domain to unblock (if it hasn't been &quot;masked&quot;).  To understand how event
channels are used, it's worth comparing I/O under Unix to I/O under Xen:</p>
<p>When a Unix process starts, it runs in a context with environment variables,
pre-connected file descriptors and command-line arguments. When a Xen domain
starts, it runs in a context with a
<a href="https://github.com/mirage/mirage-platform/blob/v1.0.0/xen/lib/start_info.mli">start info page</a>,
pre-bound event channels and pre-shared memory for console and xenstore.</p>
<p>A Unix process which wants to perform network I/O will normally connect sockets
(additional file descriptors) to network resources, and the kernel will take
care of talking protocols like TCP/IP. A Xen domain
which wants to perform network I/O will share memory with- and then bind event
channels to- <em>network driver domains</em>, and then exchange raw
ethernet frames. The Xen domain will contain its own TCP/IP stack
(such as <a href="https://github.com/mirage/mirage-tcpip">mirage-tcpip</a>).</p>
<p>When a Unix process wants to read or write data via a file descriptor
it can use <em><a href="http://linux.die.net/man/2/select">select(2)</a></em> to wait until data
(or space) is available, and then use
<em><a href="http://linux.die.net/man/2/read">read(2)</a></em> or
<a href="http://linux.die.net/man/2/write">write(2)</a>, passing pointers to data buffers
as arguments. When a Xen domain wants to wait for data (or space) it will block
until an event arrives, and then send an event to signal that data has been
produced or consumed. Note that neither blocking nor sending take buffers as
arguments since under Xen, data (or metadata) is placed into shared memory
beforehand. The events are simply a way to say, &quot;look at the shared buffers
again&quot;.</p>
<h4>How do event channels work?</h4>
<p>Every domain maps a special
<a href="https://github.com/mirage/xen/blob/1e143e2ae8be3ba86c2e931a1ee8d91efca08f89/xen/include/public/xen.h#L637">shared info</a>
page which contains bitmaps representing the state of each event channel. This
per-channel state consists of:</p>
<ul>
<li><em>evtchn_pending</em>: which means &quot;an unprocessed event has been received, you should
check your shared memory buffers (or whatever else is associated with this
channel)&quot;; and
</li>
<li><em>evtchn_mask</em>: which means &quot;I'm not interested in events on this channel atm,
don't bother interrupting me until I clear the mask&quot;.
</li>
</ul>
<p>Every vCPU has a
<a href="https://github.com/mirage/xen/blob/1e143e2ae8be3ba86c2e931a1ee8d91efca08f89/xen/include/public/xen.h#L588">vcpu_info</a>
record in the shared info page, which stores two relevant domain-global (not
per event channel) bits:</p>
<ul>
<li><em>evtchn_upcall_pending</em>: which means &quot;at least one of the event channels has received an event&quot;; and
</li>
<li><em>evtchn_upcall_mask</em>: which means &quot;I'm actively processing events, don't bother interrupting me until I clear the mask&quot;.
</li>
</ul>
<p>Note that all MirageOS guests are single vCPU and therefore we can simplify things
by relying on the (single) per-vCPU evtchn_upcall_mask rather than the fine-grained
evtchn_mask (normally a multi-vCPU guest would use the evtchn_upcall_mask to
control reentrant execution and the evtchn_mask to coalesce event wakeups).</p>
<p>Note the shared info page is shared between the domain and the hypervisor
without any locks, so an architecture-specific protocol must be used to access
it (usually via C macros with names like <code>test_and_set_bit</code>)</p>
<p>When a domain wants to transmit an event, it calls the
calls the <em>EVTCHNOP_send</em> hypercall. Within Xen, this calls
<a href="https://github.com/mirage/xen/blob/1e143e2ae8be3ba86c2e931a1ee8d91efca08f89/xen/common/event_channel.c#L616">xen/common/event_channel.c:evtchn_set_pending</a>
which tests the evtchn_pending bit for this event channel. If it's already set then
no further work is needed and so it returns. If the bit isn't already set, then
it is set and then evtchn_mask is queried.
The evtchn_mask is always clear for
MirageOS guests, so control passes to
<a href="https://github.com/mirage/xen/blob/1e143e2ae8be3ba86c2e931a1ee8d91efca08f89/xen/arch/x86/domain.c#L2011">xen/arch/x86/domain.c:vcpu_mark_events_pending</a>
which sets the per-vCPU evtchn_upcall_pending bit and then calls
<a href="https://github.com/mirage/xen/blob/1e143e2ae8be3ba86c2e931a1ee8d91efca08f89/xen/arch/x86/domain.c#L1994">xen/arch/x86/domain.c:vcpu_kick</a> which calls
<a href="https://github.com/mirage/xen/blob/1e143e2ae8be3ba86c2e931a1ee8d91efca08f89/xen/common/schedule.c#L386">xen/common/schedule.c:vcpu_unblock</a> which calls
<a href="https://github.com/mirage/xen/blob/1e143e2ae8be3ba86c2e931a1ee8d91efca08f89/xen/common/schedule.c#L363">xen/common/schedule.c:vcpu_wake</a> which finally sets the vCPU to a &quot;runnable&quot; state.</p>
<p>When a domain wishes to wait for an event, it can either call <em>SCHEDOP_block</em>
to wait forever for any (unmasked) event, or call <em>SCHEDOP_poll</em> to wait for an
event on a small set
(specifically <a href="https://github.com/mirage/xen/blob/1e143e2ae8be3ba86c2e931a1ee8d91efca08f89/xen/common/schedule.c#L712">less than or equal to 128</a>)
of listed ports up to a timeout (like select(2)). Since we don't want to limit
ourselves to 128 ports, MirageOS applications on Xen exclusively use SCHEDOP_block.
The
<a href="https://github.com/mirage/xen/blob/1e143e2ae8be3ba86c2e931a1ee8d91efca08f89/xen/common/schedule.c#L874">implementation of SCHEDOP_block</a>
simply calls
<a href="https://github.com/mirage/xen/blob/1e143e2ae8be3ba86c2e931a1ee8d91efca08f89/xen/common/schedule.c#L698">xen/common/schedule.c:vcpu_block_enable_events</a>
which calls
<a href="https://github.com/mirage/xen/blob/1e143e2ae8be3ba86c2e931a1ee8d91efca08f89/xen/include/asm-x86/event.h#L36">xen/include/asm-x86/event.h:local_event_delivery_enable</a>
to clear the evtchn_upcall_mask bit
and then calls
<a href="https://github.com/mirage/xen/blob/1e143e2ae8be3ba86c2e931a1ee8d91efca08f89/xen/common/schedule.c#L680">xen/common/schedule.c:vcpu_block</a> which performs a final check for incoming events and takes the vCPU offline.</p>
<h3>How does MirageOS handle Xen events?</h3>
<p><em>(Updated 2020-10-26. The following information is of historical interest, since MirageOS 3.9.0 our Xen backend has been revised, and only supports PVH mode and does not use mini-os anymore.)</em></p>
<p>MirageOS applications running on Xen are linked with
<a href="https://github.com/mirage/mirage-platform/tree/master/xen/runtime/kernel">a small C library</a>
derived from
<a href="https://github.com/mirage/xen/tree/master/extras/mini-os">mini-os</a>. This library
takes care of initial boot: mapping the shared info page and initialising the
event channel state. Once the domain state is setup, the OCaml runtime is
initialised and the
<a href="https://github.com/mirage/mirage-platform/blob/v1.0.0/xen/runtime/kernel/main.c#L47">OCaml OS.Main.run callback</a>
is evaluated repeatedly until it returns false, signifying exit.</p>
<p>The OCaml &quot;OS.Main.run&quot; callback is registered in
<a href="https://github.com/mirage/mirage-platform/blob/v1.0.0/xen/lib/main.ml#L48">mirage-platform/master/xen/lib/main.ml</a> and interfaces the
<a href="http://ocsigen.org/lwt/">Lwt</a> user-level thread scheduler with the Xen event system.
The main loop:</p>
<ul>
<li>checks if the main thread has terminated (Lwt.poll t)
</li>
<li>if it hasn't, call <a href="https://github.com/mirage/mirage-platform/blob/v1.0.0/xen/runtime/kernel/eventchn_stubs.c#L33">mirage-platform/xen/runtime/kernel/eventchn_stubs.c:evtchn_look_for_work</a> to see if we have received any events
</li>
<li>if there are no events, set a timer to wake us up and call <em>SCHEDOP_block</em>.
</li>
</ul>
<p><a href="https://github.com/mirage/mirage-platform/blob/v1.0.0/xen/runtime/kernel/eventchn_stubs.c#L33">mirage-platform/xen/runtime/kernel/eventchn_stubs.c:evtchn_look_for_work</a>
contains mini-os boilerplate to safely interrogate the event channel bits in the
shared info page, and copies them to a shadow array which is private to the domain.
The function returns true if there is &quot;work to do&quot; i.e. some of the bits in the
event channel bitmap were set.</p>
<p>Assuming there is &quot;work to do&quot;,
<a href="https://github.com/mirage/mirage-platform/blob/v1.0.0/xen/runtime/kernel/eventchn_stubs.c#L33">mirage-platform/xen/lib/activations.ml:run</a>
iterates over the shadow copy of the event channel bits and wakes up any Lwt
threads which have registered themselves as waiters. Typically a MirageOS device
driver will repeatedly call
<a href="https://github.com/mirage/mirage-platform/blob/v1.0.0/xen/lib/activations.mli#L22">mirage-platform/xen/lib/activations.mli:after</a>
as follows:</p>
<pre><code>let rec process_events channel last_event =
  Activations.after channel last_event &gt;&gt;= fun latest_event -&gt;
  ...
  process_events channel latest_event
in
process_events channel Activations.program_start
</code></pre>
<p>The Activations module keeps a counter and a condition variable per event channel,
using the condition variable to wake any threads which are already blocked and the
counter to prevent a thread from blocking just <em>after</em> an event has been received.</p>
<p>If there is no &quot;work to do&quot;, then control passes to
<a href="https://github.com/mirage/mirage-platform/blob/v1.0.0/xen/runtime/kernel/main.c#L30">mirage-platform/xen/runtime/kernel/main.c:caml_block_domain</a>
which sets a timer and calls <em>SCHEDOP_block</em>. When Xen wakes up the domain, control
passes first to a global
<a href="https://github.com/mirage/mirage-platform/blob/v1.0.0/xen/runtime/kernel/hypervisor.c#L33">hypervisor callback</a>
which is where an OS would normally inspect the event channel bitmaps and call
channel-specific interrupt handlers.
In MirageOS's case all we do is clear the vCPU's evtchn_upcall_pending flag and
return, safe in the knowledge that the <em>SCHEDOP_block</em> call will now return, and
the main OCaml loop will be executed again.</p>
<h4>Summary</h4>
<p>Now that you understand how events work under Xen and how MirageOS uses them,
what else do you need to know?
Future articles in this series will answer the following questions:</p>
<ul>
<li>how do Xen guests share memory with each other?
</li>
<li>how do the console and xenstore rings work?
</li>
<li>how does the network work?
</li>
</ul>
|js};
      };
      {
        updated = {js|2013-12-25 22:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Deploying via Continuous Integration|js};
        permalink = {js|deploying-via-ci|js};
        body =
          {js|<p>This live MirageOS website is written as a MirageOS application itself, with the
source code on <a href="https://github.com/mirage/mirage-www">mirage/mirage-www</a> on
GitHub. Our workflow is such that we can send a
<a href="https://github.com/mirage/mirage-www/pulls?direction=desc&amp;page=1&amp;sort=created&amp;state=closed">pull request</a>
to update the website, and have a fully standalone unikernel
deployed at <a href="https://mirage.io/">https://mirage.io/</a>.</p>
<p>See <a href="https://github.com/ocurrent/ocurrent-deployer">https://github.com/ocurrent/ocurrent-deployer</a> for the deployment pipeline.</p>
|js};
      };
      {
        updated = {js|2013-12-21 12:50|js};
        author =
          {
            name = {js|Anil Madhavapeddy|js};
            uri = Some {js|http://anil.recoil.org|js};
            email = Some {js|anil@recoil.org|js};
          };
        subject = {js|Building mirage-www|js};
        permalink = {js|mirage-www|js};
        body =
          {js|<p>This assumes that you've followed the <a href="/wiki/hello-world">Hello World</a>
instructions from earlier and are now familiar with the basic console, block
device and networking configurations from the
<a href="https://github.com/mirage/mirage-skeleton">mirage-skeleton</a> repository. To
build the live MirageOS website, we'll need several device drivers: two block
devices for the static HTML content and the templates, and a network device to
actually serve the traffic.</p>
<p>First, clone the website <a href="https://github.com/mirage/mirage-www">source code</a>:</p>
<pre><code>$ git clone git://github.com/mirage/mirage-www
$ cd mirage-www/src
$ cat config.ml
</code></pre>
<p>This <code>config.ml</code> is more complex to reflect all the different ways we want to
statically build the website, but it also does a lot more! We'll walk through it
step by step.</p>
<h2>Building a Unix version</h2>
<p>In order to configure the unikernel, we can use the mirage tool. To see all the available options:</p>
<pre><code>cd src
mirage configure --help
</code></pre>
<p>Alternatively, You can get a quick overview of all the options (and their current value):</p>
<pre><code>mirage describe
</code></pre>
<h3>A Unix development workflow</h3>
<p>For editing content and generally working with the website on a day-to-day
basis, we simply compile it using kernel sockets and a pass-through filesystem.
This is pretty similar a conventional web server, and means you can edit content
using your favourite editor (though you must restart the website binary to make
edits visible).</p>
<p>First, if you wish to build the site to present the site statistics (garbage
collection, etc) data, build the JavaScript:</p>
<pre><code>make prepare
</code></pre>
<p>Then configure and build the website itself:</p>
<pre><code>$ cd src
$ mirage configure -t unix --kv_ro crunch --net socket
$ make depend
$ make
</code></pre>
<p>Finally, run the website application:</p>
<pre><code>$ sudo dist/www
</code></pre>
<p>The website will now be available on <code>http://localhost/</code>.</p>
<h2>Building the direct networking version</h2>
<p>Now you can build the Unix unikernel using the direct stack, via a similar
procedure to the <a href="/wiki/hello-world">hello world</a> examples. As before,
Mirage will configure the stack to use the
<a href="http://en.wikipedia.org/wiki/TUN/TAP">tap0 interface</a> with an address
of <code>10.0.0.2/255.255.255.0</code>.  The application, when run, will create
a <code>tap0</code> interface for itself; in order to communicate with it,
you must configure the &quot;host OS&quot; end of the tap interface (i.e., your
operating system) to share compatible IPv4 network settings.</p>
<pre><code>$ cd src
$ mirage configure -t unix --net direct
$ make
$ sudo dist/www &amp;
$ sudo ip link set tap0 up #initialize tap
$ sudo ip addr add 10.0.0.1/24 dev tap0 #configure IP
</code></pre>
<p>You should now be able to ping the unikernel's interface:</p>
<pre><code>$ ping 10.0.0.2
</code></pre>
<p>If you see ping responses, then you are now communicating with the MirageOS
unikernel via the OCaml TCP/IP stack! Point your web browser at
<code>http://10.0.0.2</code> and you should be able to surf this website too.</p>
<h3>Serving the site from a FAT filesystem instead</h3>
<p>This site won't quite compile to Xen yet. Despite doing all networking via an
OCaml TCP/IP stack, we still have a dependency on the Unix filesystem for our
files. MirageOS provides a <a href="http://github.com/mirage/ocaml-fat">FAT filesystem</a>
which we'll use as an alternative. Our new <code>config.ml</code> will now contain this:</p>
<p>The FAT filesystem needs to be installed onto a block device, which we assign to
a Unix file. The driver for this is provided via <em>mmap</em> in the
<a href="https://github.com/mirage/mirage-block-unix">mirage/mirage-block-unix</a> module.</p>
<p>Now build the FAT version of the website. The <code>config.ml</code> supplied in the real
<code>mirage-www</code> repository uses an environment variable to switch to these
variables, so we can quickly try it as follows.</p>
<pre><code>$ cd src
$ mirage configure -t unix --kv_ro fat
$ make depend
$ make
$ sudo dist/www &amp;
$ sudo ip link set tap0 up #initialize tap
$ sudo ip addr add 10.0.0.1/24 dev tap0 #configure IP
</code></pre>
<p>The <code>make-fat_*-images.sh</code> script uses the <code>fat</code> command-line helper installed by
the <code>ocaml-fat</code> package to build the FAT block image for you. If you now access
the website, it is serving the traffic straight from the FAT image you just
created, without requiring a Unix filesystem at all!</p>
<p>You can inspect the resulting FAT images for yourself by using the <code>fat</code> command
line tool, and the generated scripts.</p>
<pre><code>$ file fat_block1.img
fat1.img: x86 boot sector, code offset 0x0, OEM-ID &quot;ocamlfat&quot;,
sectors/cluster 4, FAT  1, root entries 512, Media descriptor 0xf8,
sectors/FAT 2, sectors 1728 (volumes &gt; 32 MB) , dos &lt; 4.0 BootSector (0x0)

$ fat list fat_block1.img
/wiki (DIR)(1856 bytes)
/wiki/xen-synthesize-virtual-disk.md (FILE)(8082 bytes)
/wiki/xen-suspend.md (FILE)(14120 bytes)
/wiki/xen-events.md (FILE)(10921 bytes)
/wiki/xen-boot.md (FILE)(5244 bytes)
/wiki/weekly (DIR)(768 bytes)
</code></pre>
<p>(The details of the file listing may vary if, for example, new posts have been
added to the site recently.)</p>
<h2>Building a Xen kernel</h2>
<p>We're now ready to build a Xen kernel.  This can use either FAT or a builtin
crunch (to avoid the need for an external block device).  The latter is the
default, for simplicity's sake.</p>
<pre><code>$ cd src
$ mirage configure -t xen
$ make
</code></pre>
<p>This will build a static kernel that uses the <code>ocaml-crunch</code> tool to convert the
static website files into an OCaml module that is linked directly into the
image. While it of course will not work for very large websites, it's just fine
for this website (or for configuration files that will never be very large). The
advantage of this mode is that you don't need to worry about configuring any
external block devices for your VM, and boot times are much faster as a result.</p>
<p>You can now boot the <code>mir-www.xen</code> kernel using <code>sudo xl create -c www.xl</code> --
don't forget to edit <code>www.xl</code> to supply a VIF first though!</p>
<h3>Modifying networking to use DHCP or static IP</h3>
<p>Chances are that the Xen kernel you just built doesn't have a useful IP address,
since it was hardcoded to <code>10.0.0.2</code>. You can modify the HTTP driver to give it
a static IP address, as the
<a href="https://github.com/mirage/mirage-www/blob/master/.travis-www.ml">live deployment script</a>
does.</p>
<p>We've shown you the very low-levels of the configuration system in MirageOS
here. While it's not instantly user-friendly, it's an extremely powerful way of
assembling your own components for your unikernel for whatever specialised
unikernels you want to build.</p>
<p>We'll talk about the deployment scripts that run the
<a href="https://mirage.io">live site</a> in the
<a href="/docs/deploying-via-ci">next article</a>.</p>
|js};
      };
      {
        updated = {js|2013-12-09 16:00|js};
        author =
          {
            name = {js|Anil Madhavapeddy|js};
            uri = Some {js|http://anil.recoil.org|js};
            email = Some {js|anil@recoil.org|js};
          };
        subject = {js|Frequently Asked Questions (FAQ)|js};
        permalink = {js|faq|js};
        body =
          {js|<p><em>Q: Is MirageOS 'still' Linux? Does it require a Linux host on which to run?</em></p>
<p>MirageOS is a '<a href="http://anil.recoil.org/papers/2013-asplos-mirage.pdf">library operating system</a>', which means that it can run on any target for which a suitable bootloader and drivers exist. Versions earlier than 3 supported Unix and Xen targets; MirageOS version 3 added support for the KVM hypervisor via <a href="/blog/introducing-solo5">solo5</a>.  We have prototypes that compile the same application source code (e.g. the MirageOS website) to run as kernel modules inside FreeBSD, or even to JavaScript. MirageOS provides support to more easily target such diverse environments due to its emphasis on modular programming and compile-time specialisation.  If you'd like to dig into some code, see <a href="https://github.com/mirage/mirage-platform">the mirage-platform library</a>, which has the OCaml modules referred to in the Unix and Xen targets.</p>
<p><em>Q: Is MirageOS 'production ready'?</em></p>
<p>The 1.0 release is the first 'stable toolkit' release that is sufficient to self-host its infrastructure on the Internet.  <a href="https://github.com/mirage/mirage/releases/latest">The current release</a> includes many improvements to stability and more supported features, including support for <a href="/blog/mirage-entropy">gathering entropy</a>, <a href="http://roscidus.com/blog/blog/2014/10/27/visualising-an-asynchronous-monad/">execution trace collection and visualisation</a>, and <a href="https://mirage.io/blog/introducing-xen-minios-arm">ARM</a>.  The various libraries used in MirageOS (e.g. <a href="https://github.com/mirage/mirage-tcpip">mirage-tcpip</a> and <a href="https://github.com/mirage/irmin">Irmin</a>) follow their own release cadences, but similarly are in use in self-hosting infrastructure.  Some libraries are currently being used in large-scale commercial products like <a href="https://blog.docker.com/2016/03/docker-for-mac-windows-beta/">Docker for Mac and Windows</a>.</p>
<p><em>Q: How does MirageOS compare against other cloud-friendly OS options (e.g like OSv) and also different approaches like like containers (e.g Docker)?</em></p>
<p>MirageOS represents our desire for a radically simpler way of building complex distributed systems using a modern modular, functional and type-safe programming language such as OCaml. Unlike other cloud-friendly operating systems such as OSv, we do not attempt to optimize <em>existing</em> code, but instead focus on a toolkit to make it easier to quickly assemble <em>new</em> systems without having to be a domain expert in (e.g.) kernel programming.</p>
<p>The downside to our approach is that we only work with open protocols, since we cannot build clean-slate versions of closed protocols for which we have no specification.  Instead, we hope to build a system which enables easy development of arbitrary protocols and integration of them into the stack; a measure of our success is whether users can implement such protocols themselves, without specialised systems or kernel knowledge.</p>
<p>On the other hand, the current release contains clean-slate libraries for <a href="https://github.com/mirleft/ocaml-tls">TLS</a>, <a href="https://github.com/mirage/mirage-tcpip">TCP/IP</a>, <a href="https://github.com/mirage/ocaml-dns">DNS</a>, Xen <a href="https://github.com/mirage/mirage-net-xen">network</a> and <a href="https://github.com/mirage/mirage-block-xen">storage</a> device drivers], <a href="https://github.com/mirage/ocaml-cohttp">HTTP</a>, and other common Internet protocols, but all written in a completely type-safe fashion so that they are resistant to attacks such as buffer overflows that are plaguing the Internet. There's a good chance that a few years from now, existing systems will still be suffering those attacks, but MirageOS will continue to grow and mature its protocol implementations without sacrificing safety.</p>
<p><em>Q: What's next for MirageOS?</em></p>
<p>Back in the Cambridge Computer Laboratory, we are embarking on several major, multi-year projects that use MirageOS at their heart. The <a href="http://usercentricnetworking.eu">User Centric Networking</a> project (with Nottingham and Technicolor among others) is building a privacy-preserving distributed system for recommender and content delivery systems. Instead of a monolithic cloud storing our personal data, we are porting MirageOS to Xen/ARM and deploying small, energy efficient devices inside people's homes. This &quot;personal information hub&quot; will talk to third-party service providers and enable control over what personal data is transmitted and allow users to balance their desire for social networking vs the cost of privacy breaches.</p>
<p>We've built prototypes of this technology in the past, but quickly discovered that securing and managing embedded devices running Linux and C code is incredibly difficult. Cloud providers employ an army of security professions to secure their perimeters, but embedded devices do not have this luxury. Since OCaml has supported fast native code compilation to ARM for over a decade, MirageOS provides the perfect balance of resource efficiency and security to drive these embedded systems and benefit the coming wave of the Internet of Things.</p>
<p>OCaml (the programming language that we use under the hood of MirageOS) also has deep connections to the formal methods community, with other major tools such as Coq (a widely used theorem prover) and CompCert (a verified C compiler) written in it. We have several initiatives (<a href="http://rems.io">http://rems.io</a>) ongoing to verify components of MirageOS (such as the garbage collector), to support hardware compilation to FPGAs for datacenters (via the EPSRC-funded Networks-as-a-Service project) and support new experimental CPU targets such as the <a href="http://www.cl.cam.ac.uk/research/security/ctsrd/beri.html">BERI processor</a>.</p>
<p>We're extremely grateful to our research funding bodies (RCUK, EPSRC, EU FP7 and DARPA) for supporting such long-term research and making MirageOS possible. <a href="http://janestreet.com">Jane Street</a> and <a href="http://www.citrix.com">Citrix</a> have also contributed funding and expertise for an entire research group called <a href="http://ocamllabs.io/">OCaml Labs</a> in the Cambridge Computer Lab to support the continued growth of the functional programming ecosystem. Anil has also recently published an O'Reilly book called Real World OCaml that's freely available at <a href="https://realworldocaml.org">https://realworldocaml.org</a>.</p>
<p>Last but not least it's simply more fun to exploit the flexibility of the MirageOS approach as a programmer to regain control over the myriad complexity of current software systems. Too much of modern systems construction involves wrestling with configuration files, mystical kernel policies, and occasionally documented APIs. Simply put, MirageOS is just a lot more enjoyable to use and develop code in when building server systems and network services. Several of the developers have replaced pieces of their personal infrastructure (like homepages, DNS servers, and home routers) with MirageOS unikernels!</p>
|js};
      };
      {
        updated = {js|2013-11-10 16:00|js};
        author =
          {
            name = {js|Christine Koppelt|js};
            uri = Some {js|https://github.com/cko|js};
            email = Some {js|ch.ko123@gmail.com|js};
          };
        subject = {js|Technical Background of MirageOS|js};
        permalink = {js|technical-background|js};
        body =
          {js|<p>(based on the <a href="http://queue.acm.org/detail.cfm?id=2566628">article</a> by Anil Madhavapeddy and David J. Scott)</p>
<p>Operating system virtualization such as Xen or VMWare allows to multiplex virtual machines (VMs) on a shared cluster of physical machines. Each VM presents as a self-contained computer, booting a standard OS kernel and running unmodified applications just as if it were executing on a physical machine.</p>
<p>While this is useful in many situations, it adds yet another layer to an already highly-layered software stack now including: support for old physical protocols (e.g. disk standards developed in the 80s such as IDE); irrelevant optimisations (e.g. disk elevator algorithms on SSD drives); backward-compatible interfaces (e.g. POSIX); user-space processes and threads (in addition to VMs on a hypervisor); managed code runtimes (e.g. OCaml, .NET or Java) which all sit beneath your application code. Are we really doomed to adding new layers of indirection and abstraction every few years, leaving future generations of programmers to become virtual archeologists as they dig through hundreds of layers of software emulation to debug even the simplest applications?</p>
<p>Our goal with MirageOS is to restructure entire VMs - including all kernel and userspace code - into more modular components that are flexible, secure and reusable in the style of a library operating system.</p>
<h2>Unikernels &amp; Library operating system</h2>
<p>Our architecture is dubbed unikernels. Unikernels are specialised OS kernels written in a high-level language which act as individual software components. A full application (or appliance) consists of a set of running unikernels working together as a distributed system.</p>
<img src="/graphics/comparison-vm-unikernel.png" alt="Comparison between vm and unikernel" width="50%"/>
<p>They are based on a radical operating system architecture from the 1990s, called library operating system (or libOS). In a libOS, protection boundaries are pushed to the lowest hardware layers, resulting in: (i) a set of libraries that implement mechanisms, such as those needed to drive hardware or talk network protocols; and (ii) a set of policies that enforce access control and isolation in the application layer.</p>
<p>The libOS architecture has several advantages over more conventional designs. For applications where performance is required, a libOS wins by allowing applications to access hardware resources directly without having to make repeated privilege transitions to move data between userspace and kernelspace. The libOS does not have a central &quot;networking service&quot; into which both high priority network packets (such as those from a video conference call) and low priority packets (such as from a background file download) are forced to mix, join the same queues and generally interfere. Instead libOS applications will have entirely separate queues, and packets will only mix together when they arrive at the network device itself.</p>
<p>A libOS running as a VM needs to implement drivers for the virtual hardware devices provided by the hypervisor. Furthermore it needs to create the protocol libraries to replace the services of a traditional OS.</p>
<h2>Why OCaml</h2>
<p>Modern kernels are all written in C, which excels at low-level programs such as device drivers but lacks the abstraction facilities of higher-level languages and demands careful manual tracking of resources such as memory buffers. Beside this high-level languages are steadily gaining ground in general application development, some of them include:</p>
<ul>
<li>
<p>Static type checking rejects unsafe code at compilation time rather than execution time</p>
</li>
<li>
<p>Automatic memory management, which eliminiates many resource leaks.</p>
</li>
<li>
<p>Modules help software development scale as internal implementation details can be abstracted</p>
</li>
<li>
<p>Metaprogramming: if the run-time configuration of a system is partially understood at compile-time, then a compiler can optimise the program much more than it would normally be able to</p>
</li>
</ul>
<p>We chose OCaml as the sole base language for MirageOS. It is a full-fledged systems programming language with a flexible programming model that supports functional, imperative and object-oriented styles. It also features a portable single-threaded runtime that makes it ideal for porting to restricted environments such as a barebones Xen VM. The compiler heavily emphasises static type checking, and the resulting binaries are fast native code with no runtime type information and the module system is among the most powerful in a general-purpose programming language in terms of permitting flexible and safe code reuse and refactoring. Finally, we had several examples of large-scale uses of OCaml in industry at Jane Street and within Xen itself, and the positive results were encouraging before embarking on the large multi-year project that MirageOS turned out to be.</p>
<h2>Modular OS Libraries</h2>
<p>MirageOS provides modular OS libraries, which can be switched when needed.</p>
<img src="/graphics/mirage-sample-application.png" alt="example" width="50%"/>
<p>The application MyHomePage depends on an HTTP signature that is provided by the Cohttp library. A developer just starting out wants to explore their code interactively using a Unix-style development environment. The Cohttp library needs a TCP implementation to satisfy its module signature, which can be provided by the UnixSocket library. When development is finished, the on Unix is entirely dropped, and the application is recompiled using the MirNet module to directly link against a Xen network driver, which in turn pulls in all the dependencies it needs to boot on Xen.</p>
<h2>Development Workflow</h2>
<ul>
<li>
<p><strong>Build System</strong>: All source code dependencies of the input application
are explicitly tracked, including all the libraries required to implement kernel functionality</p>
</li>
<li>
<p><strong>Compiler</strong>: The compiler outputs a full standalone kernel instead of just a Unix executable. It is linked against a minimal embedded runtime which provides boot support and the garbage collector. There is no preemptive threading and the kernel is
event-driven via an I/O loop that polls Xen devices.</p>
</li>
<li>
<p><strong>Deployment</strong>: The specialized unikernels are deployed online on the public cloud and are recompiled to reconfigure them. They have a significantly smaller attack surface than
the conventional virtualized equivalents, and are more  resource-efficient in terms of boot time, binary size and runtime performance.</p>
</li>
</ul>
<h2>Other Unikernels</h2>
<p>MirageOS is certainly not the only unikernel for Xen that has emerged in the last few years:</p>
<ul>
<li>Haskell: <a href="https://github.com/GaloisInc/HaLVM#readme">HalVM</a>
</li>
<li>Erlang: <a href="http://erlangonxen.org">ErlangOnXen</a>
</li>
<li>Java: <a href="https://kenai.com/projects/guestvm">GuestVM</a>
</li>
</ul>
|js};
      };
      {
        updated = {js|2013-10-15 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Overview of MirageOS|js};
        permalink = {js|overview-of-mirage|js};
        body =
          {js|<p>If you're familiar with the using the command line, The best way to
learn about MirageOS is to try out the <a href="https://mirage.io/wiki/install">installation
instructions</a> for yourself!</p>
<h3>What is MirageOS and why is it important?</h3>
<p><a href="http://www.berndnaut.nl/images/NimbusNP3web.jpg"><img style="float:right; margin-left: 15px; margin-bottom: 15px;" src="/graphics/nimbus-np3-smilde.jpg"></img></a></p>
<p>Most applications that run in the cloud aren't optimised to do so.
They inherently carry assumptions about the underlying operating
system with them, including vulnerabilities and bloat.
Compartmentalisation of large servers into smaller <a href="http://en.wikipedia.org/wiki/Virtual_machine">virtual
machines</a> has enabled
many new businesses to get started and achieve scale. This has been
great for new services but many of those virtual machines are
single-purpose and yet they contain largely complete operating systems
which themselves run applications like web-servers. This means a large
part of the footprint is unused and unnecessary, which is both costly
and a security risk (due to the larger attack surface).</p>
<p>MirageOS represents a new approach where only the necessary components
of the OS are included and compiled along with the application into a
<a href="http://queue.acm.org/detail.cfm?id=2566628">unikernel</a>. This
results in highly efficient and extremely lean
<a href="http://en.wikipedia.org/wiki/Virtual_appliance">appliances</a>, with a
much smaller attack surface.  These appliances can be deployed
directly to the cloud and embedded devices, with the benefits of
reduced costs and increased security and scalability.</p>
<h3>How does MirageOS work?</h3>
<p><a href="http://www.xenproject.org/developers/teams/hypervisor.html"><img style="float:left; margin-right: 15px;" src="/graphics/Xen-Panda-Ecosystem-1.png"></img></a></p>
<p>MirageOS is a 'library operating system' for constructing secure,
high-performance network applications across a variety of cloud
computing and mobile platforms. It works by treating the <a href="http://www.xenproject.org/developers/teams/hypervisor.html">Xen
hypervisor</a>
as a stable hardware platform, allowing us to focus on
high-performance protocol implementations without worrying about
having to support the thousands of device drivers found in a
traditional OS.</p>
<p>Code can be developed in a high-level functional programming language
(OCaml) on a desktop OS such as Linux or Mac OSX, and is then compiled
into a fully-standalone, specialised unikernel. These unikernels run
directly on Xen hypervisor APIs. Since the Xen powers most public
clouds such as <a href="http://aws.amazon.com/ec2">Amazon EC2</a>, <a href="http://www.rackspace.com/cloud/">Rackspace
Cloud</a>, and many others, MirageOS lets
your servers run more cheaply, securely and faster in any Xen based
cloud or hosting service.</p>
<p>MirageOS is based around the <a href="http://ocaml.org">OCaml language</a>, with
syntax extensions and <a href="https://github.com/mirage">50+ libraries</a> which
map directly to operating system constructs when being compiled for
production deployment. As such, MirageOS includes clean-slate functional
implementations of protocols ranging from TCP/IP, DNS, SSH, Openflow
(switch/controller), HTTP, XMPP and Xen inter-VM transports.</p>
<h3>Where will MirageOS be useful?</h3>
<p><a href="http://www.flickr.com/photos/radnezeoz/7343684238/"><img style="float:right; margin-left: 15px;" src="/graphics/cumulous-cruisin.jpg"></img></a></p>
<p>An example of a current MirageOS appliance is this website which is a
completely self-hosted site, deployed on the public cloud and running
directly on the Xen hypervisor (in this case, on Amazon EC2). Such
appliances could be auto-configured and deployed directly to the
public cloud (e.g. Rackspace or Amazon EC2) or pushed to embedded
devices. There is also
<a href="http://decks.openmirage.org">http://decks.openmirage.org</a>, where
separate MirageOS appliances are being used to present slides for
conferences.  These are both cases of how MirageOS is being used right
now and below are examples of things we can do in the future.</p>
<h4>Self-scaling architecture</h4>
<p>We can create auto-scaling web-servers with very small footprints.
These would be cheaper to run than current solutions due to the small
size but they would also be highly elastic. If a sudden spike in
traffic occurs, the web-servers can be configured to create and deploy
copies of themselves to service the demand. This auto-scaling happens
so quickly that an incoming connection can trigger the creation of new
server and the <em>new server</em> can then handle that request before it
times out (which is on the order of milliseconds). When the demand
dies down again, these web-servers can automatically shut themselves
down. Since these machines boot fast we can be more elastic, raising
and lowering capacity to precisely meet demand and therefore only
spending what we actually need when we really need it.</p>
<h4>Deployment to embedded devices</h4>
<p><a href="http://www.flickr.com/photos/lukew/6171377827/"><img style="float:left; margin-right: 15px;" src="/graphics/device-love.jpg"></img></a></p>
<p>Using MirageOS, we can also create appliances that can run on embedded
devices. Such appliances can be deployed into small devices that are
scattered around your home, for example in plant pots to measure
moisture levels to chemical sensors in your fridge, which tell you
exactly what has gone off.  You could access the data from these
sensors via a web-sever appliance, which is also deployed locally in
your home on a device like a <a href="http://www.raspberrypi.org">Raspberry
Pi</a>.  Installing additional applications
into your Raspberry Pi appliance can be a a simple 1-click operation,
allowing you to share your data or compare with others.  Creating a
home-based network like this ensures you're not affected by any
upstream connectivity issues and that your data remains within your
control.</p>
<p>This same scenario can be deployed into a enterprise environment where
sensors around a building can monitor environmental conditions, adjust
lighting and many other things. When additional computation is
required, more appliances can automatically be created on a cloud
provider for the short duration that they're needed.</p>
<p>Overall, MirageOS provides substantial benefits in terms of increased
efficiency and safety and is ideal for deploying to both the public
cloud and embedded devices. Together with
<a href="http://nymote.org/software/irmin">Irmin</a> and
<a href="http://nymote.org/software/signpost">Signpost</a>, MirageOS forms a core
piece of the Nymote/MISO toolstack to power the coming wave of <a href="http://en.wikipedia.org/wiki/Internet_of_Things">Internet of
Things devices</a>.</p>
|js};
      };
      {
        updated = {js|2013-08-15 16:00|js};
        author =
          {
            name = {js|Balraj Singh|js};
            uri = None;
            email = Some {js|balraj.singh@cl.cam.ac.uk|js};
          };
        subject = {js|Getting Started with Lwt threads|js};
        permalink = {js|tutorial-lwt|js};
        body =
          {js|<p><a href="https://www.ocsigen.org/lwt">Lwt</a> is a lightweight cooperative threading library for OCaml. A good way to understand Lwt and its use in MirageOS is to write some simple code. This document introduces the basic concepts and suggests programs to write. Code for all examples is in the <code>mirage-skeleton/tutorial/lwt/</code> <a href="https://github.com/mirage/mirage-skeleton/tree/master/tutorial/lwt">repository</a>.</p>
<p>##Basics</p>
<p>The full Lwt manual is available <a href="https://ocsigen.org/lwt">elsewhere</a>, but the minimal stuff needed to get started is here.</p>
<p>The core type in Lwt is a &quot;thread&quot; (also known as a &quot;promise&quot; in some other systems).
An <code>'a Lwt.t</code> is a thread that should produce a value of type <code>'a</code> (for example, an <code>int Lwt.t</code> should produce a single <code>int</code>).
Initially a thread is <em>sleeping</em> (the result is not yet known). At some point, it changes to be either <em>returned</em> (with a value of type <code>'a</code>) or <em>failed</em> (with an exception). Once returned or failed, a thread never changes state again.</p>
<p>Lwt provides a number of functions for working with threads.
The first useful function is <code>return</code>, which constructs a trivial, already-returned thread:</p>
<pre><code>  val return: 'a -&gt; 'a Lwt.t
</code></pre>
<p>This is useful if an API requires a thread, but you already happen to know the value.
Once the value is wrapped in its Lwt thread, it cannot directly be used (as in general a thread may not have terminated yet). This is where the <code>&gt;&gt;=</code> operator (pronounced &quot;bind&quot;) comes in:</p>
<pre><code>  val ( &gt;&gt;= ): 'a Lwt.t -&gt; ('a -&gt; 'b Lwt.t) -&gt; 'b Lwt.t
</code></pre>
<p><code>t &gt;&gt;= f</code> creates a thread which first waits for thread <code>t</code> to return some value <code>x</code>, then behaves as the new thread <code>f x</code>. If <code>t</code> is a sleeping thread, then <code>t &gt;&gt;= f</code> will initially be a sleeping thread too. If <code>t</code> fails, then the resulting thread will fail with the same exception.</p>
<p>If you ignore the <code>Lwt.t</code> bits in the types above, you can see that <code>return</code> looks like the identity function and <code>&gt;&gt;=</code> looks like <code>|&gt;</code> (&quot;pipe&quot; or &quot;apply&quot;).
You can convert any synchronous program into an equivalent Lwt-threaded one using just <code>&gt;&gt;=</code> and <code>return</code>.
For example consider this code to input two values and add them:</p>
<pre><code class="language-ocaml">  let x =
    let a = get_input &quot;Enter a&quot; in
    let b = get_input &quot;Enter b&quot; in
    a + b
</code></pre>
<p>Removing the <code>let ... in ...</code> syntax, we could also write:</p>
<pre><code class="language-ocaml">  let x =
    get_input &quot;Enter a&quot; |&gt; fun a -&gt;
    get_input &quot;Enter b&quot; |&gt; fun b -&gt;
    a + b
</code></pre>
<p>If the <code>get_input</code> function's type is changed from <code>string -&gt; int</code> to the threaded-equivalent, <code>string -&gt; int Lwt.t</code>, then our example could be changed to:</p>
<pre><code class="language-ocaml">  let x =
    get_input &quot;Enter a&quot; &gt;&gt;= fun a -&gt;
    get_input &quot;Enter b&quot; &gt;&gt;= fun b -&gt;
    Lwt.return (a + b)
</code></pre>
<p>Note that the final result, <code>x</code>, is itself a thread now.
Since we didn't change <code>+</code> to return a thread, we must wrap the result with <code>return</code> to give it the correct type.</p>
<p>Of course, the reason for using Lwt is to write programs that do more than just behave like synchronous programs: we want to be doing multiple things at once, by composing threads in more ways than just &quot;<em>a</em> then <em>b</em>&quot;.
Two important functions to compose threads are <code>join</code> and <code>choose</code>.</p>
<pre><code class="language-ocaml">  val join : unit Lwt.t list -&gt; unit Lwt.t
</code></pre>
<p><code>join</code> takes a list of threads and waits for all of them to terminate. If at least one thread fails then <code>join l</code> will fail with the same exception as the first to fail, after all threads terminate.</p>
<pre><code class="language-ocaml"> val choose : 'a t list -&gt; 'a t
</code></pre>
<p><code>choose l</code> behaves as the first thread in <code>l</code> to terminate. If several threads are already terminated, one is chosen at random.</p>
<p>The <a href="https://ocsigen.org/lwt/5.1.2/api/Lwt_list">Lwt_list</a> module provides many other functions for handling lists of threads.</p>
<h2>Challenge 1: Sleep and join</h2>
<p>Now write a program that spins off two threads, each of which sleeps for some
amount of time, say 1 and 2 seconds and then one prints &quot;Heads&quot;, the other
&quot;Tails&quot;. After both have finished, it prints &quot;Finished&quot; and exits.</p>
<p>To sleep for some number of nanoseconds use <code>OS.Time.sleep_ns</code>, and to print to
the console use <code>C.log</code>. Note that <code>OS</code> is a Mirage-specific module; if you are
using Lwt in another context, use <code>Lwt_unix.sleep</code> and <code>Lwt_io.write</code>. (You will
also need to manually start the main event loop with <code>Lwt_main.run</code>.)</p>
<p>For convenience, you'll likely want to also use the
<a href="https://github.com/hannesm/duration">Duration</a> library, which provides handy
functions for converting between seconds, milliseconds, nanoseconds, and other
units of time.</p>
<pre><code class="language-ocaml">OS.Time.sleep_ns (Duration.of_sec 3) (* sleep for 3 seconds *)
</code></pre>
<p>You will need to have MirageOS <a href="/wiki/install">installed</a>. Create a file
<code>config.ml</code> with the following content:</p>
<pre><code class="language-ocaml">open Mirage

let packages = [package &quot;duration&quot;]

let () =
  let main = foreign ~packages &quot;Unikernel.Heads1&quot; (console @-&gt; job) in
  register &quot;heads1&quot; [ main $ default_console ]
</code></pre>
<p>Add a file <code>unikernel.ml</code> with the following content and edit it:</p>
<pre><code class="language-ocaml">open OS
open Lwt.Infix

module Heads1 (C: Mirage_console.S) = struct
  let start c =
    (* Add your implementation here... *)
    C.log c &quot;Finished&quot;
end
</code></pre>
<p>Assuming you want to build as a normal Unix process, compile the application with:</p>
<pre><code>  mirage configure -t unix
  make depend
  make
  ./main.native
</code></pre>
<p>If you prefer to build for another target (like <code>xen</code> or <code>hvt</code>), change the <code>-t</code> argument to <code>mirage configure</code>.  To see the available backends, have a look at the documentation available with <code>mirage configure --help</code>.</p>
<h3>Solution</h3>
<pre><code class="language-ocaml">open OS
open Lwt.Infix

module Heads1 (C: Mirage_console.S) = struct

  let start c =
    Lwt.join [
      (Time.sleep_ns (Duration.of_sec 1) &gt;&gt;= fun () -&gt; C.log c &quot;Heads&quot;);
      (Time.sleep_ns (Duration.of_sec 2) &gt;&gt;= fun () -&gt; C.log c &quot;Tails&quot;)
    ] &gt;&gt;= fun () -&gt;
    C.log c &quot;Finished&quot;

end
</code></pre>
<p>This code is also found in <a href="https://github.com/mirage/mirage-skeleton/blob/master/tutorial/lwt/heads1/unikernel.ml">tutorial/lwt/heads1/unikernel.ml</a> in the <a href="https://github.com/mirage/mirage-skeleton">mirage-skeleton</a> code repository.  Build it with <code>mirage configure -t unix &amp;&amp; make depend &amp;&amp; make</code>, as described above.</p>
<p>##Challenge 2: Looping echo server</p>
<p>Write an echo server that reads from a dummy input generator and, for each line it reads, writes it to the console. The server should stop after reading 10 lines.</p>
<p>Hint: it's easier to convert a program to use Lwt if you write loops in a functional style (using tail recursion) rather than using special syntax (e.g. <code>while</code> and <code>for</code>).</p>
<p>For convenience, here is a <code>config.ml</code> which you might use for this exercise:</p>
<pre><code class="language-ocaml">open Mirage

let packages = [package &quot;duration&quot;; package &quot;randomconv&quot;]

let () =
  let main = foreign ~packages &quot;Unikernel.Echo_server&quot; (console @-&gt; random @-&gt; job) in
  register &quot;echo_server&quot; [ main $ default_console $ default_random ]
</code></pre>
<p>You might notice that it's very similar to the previous example <code>config.ml</code>, but it requires an extra package <code>randomconv</code>.  <code>randomconv</code> has convenience functions for dealing with random data, which this challenge asks you to do.  Here is a basic dummy input generator you can use for testing:</p>
<pre><code>  let read_line () =
    OS.Time.sleep_ns (Duration.of_ms (Randomconv.int ~bound:2500 R.generate))
    &gt;|= fun () -&gt;
    String.make (Randomconv.int ~bound:20 R.generate) 'a'
</code></pre>
<p>By the way, the <code>&gt;|=</code> operator (&quot;map&quot;) used here is similar to <code>&gt;&gt;=</code> but automatically wraps the result of the function you provide with <code>return</code>. It's used here because <code>String.make</code> is synchronous (it doesn't return a thread). We could also have used <code>&gt;&gt;=</code> and <code>return</code> together to get the same effect.</p>
<p>###Solution</p>
<pre><code class="language-ocaml">open OS
open Lwt.Infix

module Echo_server (C: Mirage_console.S) (R: Mirage_random.S) = struct

  let read_line () =
    OS.Time.sleep_ns (Duration.of_ms (Randomconv.int ~bound:2500 R.generate))
    &gt;|= fun () -&gt;
    String.make (Randomconv.int ~bound:20 R.generate) 'a'

  let start c _r =
    let rec echo_server = function
      | 0 -&gt; Lwt.return ()
      | n -&gt;
        read_line () &gt;&gt;= fun s -&gt;
        C.log c s &gt;&gt;= fun () -&gt;
        echo_server (n - 1)
    in
    echo_server 10

end
</code></pre>
<p>This is in <a href="https://github.com/mirage/mirage-skeleton/blob/master/tutorial/lwt/echo_server/unikernel.ml">tutorial/lwt/echo_server/unikernel.ml</a> in
the <a href="https://github.com/mirage/mirage-skeleton">mirage-skeleton</a> code repository.</p>
<p>Note: Lwt's <code>&gt;&gt;=</code> operator does the threaded equivalent of a tail-call
optimisation, so this won't consume more and more memory as it runs.</p>
<p>##The main event loop</p>
<p>Understanding the basic principles behind Lwt can be helpful.</p>
<p>The core of Lwt is based on an event loop. In &quot;standard&quot; (non-MirageOS) settings,
this loop is started using the <code>Lwt_main.run</code> function. However, when using
MirageOS, the loop is automatically started by the <code>main.ml</code> file autogenerated
by the <code>mirage</code> command-line tool.</p>
<p>Because it's based on an event loop, threads are very cheap in Lwt
when compared to preemptive system threads. Sleeping registers an
event that will wake up the associated thread when possible.</p>
<p>##Mutexes and cooperation</p>
<p>With Lwt, it is often possible to avoid mutexes altogether! The web server from the <a href="https://ocsigen.org">Ocsigen</a> project uses only two, for example. In usual concurrent systems, mutexes are used to prevent two (or more) threads executing concurrently on a given piece of data. This can happen when a thread is preemptively interrupted and another one starts running. In Lwt, a thread executes serially until it explicitly yields (most commonly via <code>&gt;&gt;=</code>); for this reason, Lwt threads are said to be <a href="https://en.wikipedia.org/wiki/Cooperative_multitasking#Cooperative_multitasking.2Ftime-sharing">cooperative</a>.</p>
<p>For example, consider this code to generate unique IDs:</p>
<pre><code>let next =
  let i = ref 0 in
  fun () -&gt;
    incr i;
    !i
</code></pre>
<p>It is entirely safe to call this from multiple Lwt threads, since we know that <code>incr</code>, the only function we call, isn't going to somehow recursively call <code>next</code> while it's running.</p>
<p>Calling <code>x &gt;&gt;= f</code> (and similar) will run other threads while waiting for <code>x</code> to terminate, and these may well invoke the function again, so you can't assume things won't be modified across a bind.
For example, this version is <em>not</em> safe:</p>
<pre><code>let next =
  let i = ref 0 in
  fun () -&gt;
    incr i;
    foo () &gt;|= fun () -&gt;        (* Another thread might call [next] here *)
    !i
</code></pre>
<p>Of course, this is true of <em>any</em> function that might, directly or indirectly, call <code>next</code>, not just Lwt ones.</p>
<p>The obvious danger associated with cooperative threading is having threads not cooperating: if an expression takes a lot of time to compute with no cooperation point, then the whole program hangs. The <code>Lwt.yield</code> function introduces an explicit cooperation point. <code>sleep</code>ing also obviously makes the thread cooperate.</p>
<p>If locking a data structure is still needed, the <code>Lwt_mutex</code> module provides the necessary functions. To obtain more information on thread switching (and how to prevent it) read the Lwt mailing list archive: <a href="https://sympa.inria.fr/sympa/arc/ocsigen/2011-09/msg00029.html">Lwt_stream, thread switch within push function</a> which continues <a href="https://sympa.inria.fr/sympa/arc/ocsigen/2011-10/msg00001.html">here</a>.</p>
<p>##Spawning background threads</p>
<p>If you want to spawn a thread without waiting for the result, use <code>Lwt.async</code>:</p>
<pre><code>Lwt.async (fun () -&gt;
  OS.Time.sleep_ns (Duration.of_sec 10) &gt;&gt;= fun () -&gt;
  C.log c &quot;Finished&quot;
)
</code></pre>
<p><strong>Note</strong>: do <em>not</em> do <code>let _ = my_background_thread ()</code>. This ignores the result of the thread, which means that if it fails with an exception then the error will never be reported.</p>
<p><code>Lwt.async</code> reports errors to the user's configured <code>Lwt.async_exception_handler</code>, which may or may not terminate the unikernel depending on how it has been configured.</p>
<p>It is often better to catch such exceptions and log them with some contextual information.
Here's some real Mirage code that spawns a new background thread to handle a new frame received from the network.
The log message includes the exception it caught, a dump of the troublesome frame and, like all log messages, information about when it occurred and in which module.</p>
<pre><code>(* Handle a frame of data from the network... *)
Lwt.async (fun () -&gt;
  Lwt.catch (fun () -&gt; fn data)
    (fun ex -&gt;
       Log.err (fun f -&gt; f &quot;uncaught exception from listen callback \\
                            while handling frame:@\\n%a@\\nException: @[%s@]&quot;
                   S.pp_frame data (Printexc.to_string ex));
       Lwt.return ()
    )
)
</code></pre>
<p>By the way, the reason <code>async</code> and <code>catch</code> take functions that create threads rather than just plain threads is so they can start the thread inside a <code>try .. with</code> block and so handle OCaml exceptions consistently.
Be careful not to disable this safety feature by accident - consider:</p>
<pre><code>let test1 () =
  let t = raise (Failure &quot;early failure&quot;) in
  Lwt.catch (fun () -&gt; t)
    (fun ex -&gt; print_endline &quot;caught exception!&quot;; Lwt.return ())

let test2 () =
  let t = OS.Time.sleep_ns (Duration.of_sec 1) &gt;&gt;= fun () -&gt; raise (Failure &quot;late failure&quot;) in
  Lwt.catch (fun () -&gt; t)
    (fun ex -&gt; print_endline &quot;caught exception!&quot;; Lwt.return ())
</code></pre>
<p>Because <code>test1</code>'s <code>t</code> raises an exception immediately (without waiting for a sleeping thread and thus getting added to an event queue), <code>test1</code> will exit with an exception before even reaching the <code>catch</code> function.</p>
<p>However, <code>test2</code>'s <code>t</code> blocks first. In this case, the sleeping <code>t</code> is passed to <code>catch</code>, which handles the exception.</p>
<p>Moving the <code>let t = </code> inside the <code>catch</code> callback avoids this problem (as does using <code>Lwt.fail</code> instead of <code>raise</code>).</p>
<p>##Error handling</p>
<p>In Mirage code, we typically distinguish two types of error: programming errors (bugs, which should be reported to the programmer to be fixed) and expected errors (e.g. network disconnected or invalid TCP packet received).
We try to use the type system to ensure that expected errors are handled gracefully.</p>
<h3>Use result for expected errors</h3>
<p>For expected errors, you should use the <code>result</code> type, which provides <code>Ok</code> and <code>Error</code> constructors.
This is a built-in in OCaml 4.03 and available from the <code>result</code> opam package for older versions.</p>
<p>Here's an example that calls <code>read_arg</code> twice and returns the sum of the results on success. If either <code>read_arg</code> returns an error then that is returned immediately.</p>
<pre><code>let example () =
  read_arg () &gt;&gt;= function
  | Error _ as e -&gt; Lwt.return e
  | Ok a -&gt;
  read_arg () &gt;&gt;= function
  | Error _ as e -&gt; Lwt.return e
  | Ok b -&gt;
  Lwt.return (Ok (a + b))
</code></pre>
<p>It is often useful to provide some helpers to handle this pattern (using Lwt threads and result types together) more simply:</p>
<pre><code>let ok x = Lwt.return (Ok x)

let (&gt;&gt;*=) m f =
  m &gt;&gt;= function
  | Error _ as e -&gt; Lwt.return e
  | Ok x -&gt; f x

let example () =
  read_arg () &gt;&gt;*= fun a -&gt;
  read_arg () &gt;&gt;*= fun b -&gt;
  ok (a + b)
</code></pre>
<p>###Use raise or fail for bugs</p>
<p>If a bug is detected, you should raise an exception. In threaded code you should use <code>Lwt.fail</code>, although Lwt will catch exceptions and turn them into failures automatically if you forget.</p>
<p>###Catching exceptions</p>
<p>You shouldn't normally need to catch specific exceptions (it would be better to use an <code>Error</code> return in that case), but it is sometimes necessary.</p>
<p>The Lwt-equivalent of</p>
<pre><code>try foo x
with
| Error_you_want_to_catch -&gt; (* handle error here *)
</code></pre>
<p>is</p>
<pre><code> Lwt.catch
  (fun () -&gt; foo x)
  (function
   | Error_you_want_to_catch -&gt; (* handle error here *)
   | ex -&gt; Lwt.fail ex  (* Pass others on *)
  )
</code></pre>
<p>###Finalize</p>
<p>Depending on how the unikernel is set up, an exception may or may not be fatal.
In general, if you allocate a resource that won't be automatically freed by the garbage collector then you should use <code>Lwt.finalize</code> to ensure it is cleaned up whether the function using it succeeds or not:</p>
<pre><code>  let r = Resource.alloc () in
  Lwt.finalize
    (fun () -&gt; use r)
    (fun () -&gt; Resource.free r)
</code></pre>
<p>To make it harder to get this wrong, it is a good idea to provide a <code>with_</code> function, so users can just do:</p>
<pre><code>  with_resource (fun r -&gt; use r)
</code></pre>
<p>##User-defined threads</p>
<p>You can create a thread that sleeps until you explicitly make it return a result with <code>Lwt.wait</code>,
which returns a thread and a <em>waker</em>:</p>
<pre><code>let invoke_remote msg =
  let t, waker = Lwt.wait () in
  let id = new_id () in
  on_response_to id (fun resp -&gt; Lwt.wakeup waker resp);
  send_request id msg;
  t
</code></pre>
<p>This is mainly useful when interacting with external processes (as in this example), or libraries that don't support Lwt directly.</p>
<p>##Cancelling</p>
<p>In order to cancel a thread, the function <code>cancel</code> (provided by the module Lwt) is needed. It has type <code>'a t -&gt; unit</code> and does exactly what it says (except on certain complicated cases that are not in the scope of this tutorial). A simple timeout function that cancels a thread after a given number of seconds can be written easily:</p>
<pre><code>  (* In this example and all those afterwards, we consider Lwt and OS to be
     opened *)
  let timeout delay t =
    Time.sleep_ns delay &gt;|= fun () -&gt; cancel t
</code></pre>
<p>###Challenge 3: Timeouts</p>
<p>This <code>timeout</code> function does not allow one to use the result returned by the thread <code>t</code>.</p>
<p>Modify the <code>timeout</code> function so that it returns either <code>None</code> if <code>t</code> has not yet returned after <code>delay</code> seconds or <code>Some v</code> if <code>t</code> returns <code>v</code> within <code>delay</code> seconds. In order to achieve this behaviour it is possible to use the function <code>Lwt.state</code> that, given a thread, returns the state it is in, either <code>Sleep</code>, <code>Return</code> or <code>Fail</code>.</p>
<p>You can test your solution with this application, which creates a thread that may be cancelled before it returns:</p>
<pre><code class="language-ocaml">  let start c _r =
    let t =
      Time.sleep_ns (Duration.of_ms (Randomconv.int ~bound:3000 R.generate))
      &gt;|= fun () -&gt; &quot;Heads&quot;
    in
    timeout (Duration.of_sec 2) t &gt;&gt;= function
    | None   -&gt; C.log c &quot;Cancelled&quot;
    | Some v -&gt; C.log c (Printf.sprintf &quot;Returned %S&quot; v)
</code></pre>
<p>###Solution</p>
<pre><code class="language-ocaml">  let timeout delay t =
    Time.sleep_ns delay &gt;&gt;= fun () -&gt;
    match Lwt.state t with
    | Lwt.Sleep    -&gt; Lwt.cancel t; Lwt.return None
    | Lwt.Return v -&gt; Lwt.return (Some v)
    | Lwt.Fail ex  -&gt; Lwt.fail ex
</code></pre>
<p>This solution and application are found in <a href="https://github.com/mirage/mirage-skeleton/blob/master/tutorial/lwt/timeout1/unikernel.ml">tutorial/lwt/timeout1/unikernel.ml</a> in the repository.</p>
<p>Does your solution match the one given here and always returns after <code>f</code> seconds, even when <code>t</code> returns within <code>delay</code> seconds?</p>
<p>This is a good place to introduce a third operation to compose threads: <code>pick</code>.</p>
<pre><code>  val pick : 'a t list -&gt; 'a t
</code></pre>
<p><code>pick</code> behaves exactly like <code>choose</code> except that it cancels all other sleeping threads when one terminates.</p>
<h3>Challenge 4: Better timeouts</h3>
<p>In a typical use of a timeout, if <code>t</code> returns before the timeout has expired, one would want the timeout to be cancelled right away. The next challenge is to modify the timeout function to return <code>Some v</code> right after <code>t</code> returns. Of course if the timeout does expire then it should cancel <code>t</code> and return <code>None</code>.</p>
<p>In order to test your solution, you can compile it to a mirage executable and run it using the skeleton provided for the previous challenge.</p>
<h3>Solution</h3>
<pre><code class="language-ocaml">  let timeout delay t =
    let tmout = Time.sleep_ns delay in
    Lwt.pick [
      (tmout &gt;|= fun () -&gt; None);
      (t &gt;|= fun v -&gt; Some v);
    ]
</code></pre>
<p>Found in <a href="https://github.com/mirage/mirage-skeleton/blob/master/tutorial/lwt/timeout2/unikernel.ml">lwt/tutorial/timeout2/unikernel.ml</a> in the repository.</p>
<h3>Warning</h3>
<p>The <code>cancel</code> function should be used very sparingly, since it essentially throws an unexpected exception into the middle of some executing code that probably wasn't expecting it.
A cancel that occurs when the thread happens to be performing an uncancellable operation will be silently ignored.</p>
<p>A safer alternative is to use <a href="https://ocsigen.org/lwt/5.1.2/api/Lwt_switch">Lwt_switch</a>.
This means that cancellation will only happen at well defined points, although it does require explicit support from the code being cancelled.
If you have a function that only responds to cancel, you might want to wrap it in a function that takes a switch and cancels it when the switch is turned off.</p>
<h2>Other Lwt features</h2>
<p>Lwt provides many more features. See <a href="https://ocsigen.org/lwt/">the manual</a> for details.
However, the vast majority of code will only need the basic features described here.</p>
|js};
      };
      {
        updated = {js|2013-08-14 10:00|js};
        author =
          {
            name = {js|Richard Mortier|js};
            uri = Some {js|http://mort.io/|js};
            email = Some {js|mort@cantab.net|js};
          };
        subject = {js|Presentations|js};
        permalink = {js|talks|js};
        body =
          {js|<p>This page links to various technical talks and slide decks on MirageOS.  The bulk
of slide decks that we give are now hosted using MirageOS on
<a href="http://decks.openmirage.org">http://decks.openmirage.org</a>, so please browse there for the latest content.</p>
<h2>Videos</h2>
<p>Below are various videos of public presentations that are available online.
There is also a <a href="/links">link blog</a> of other articles available.</p>
<h3>Rainbows and Unikernels</h3>
<p><strong><a href="https://twitter.com/gar1t">Garett Smith</a> at CityCode - Oct 2015</strong></p>
<div class="flex-video">
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/cUvNths_5RA" frameborder="0" allowfullscreen=""></iframe>
</div>
<h3>Taking the Operating System out of Operations</h3>
<p><strong><a href="https://twitter.com/garethr">Gareth Rushgrove</a> at Operability - Sep 2015</strong></p>
<div class="flex-video">
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/nxofKgwgjHs" frameborder="0" allowfullscreen=""></iframe>
</div>
<h3>Look ma, no OS! Unikernels and their applications</h3>
<p><strong><a href="https://twitter.com/mattbajor">Matt Bajor</a> at Strangeloop - Sep 2015</strong></p>
<div class="flex-video">
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/W9F4pn9Lngc" frameborder="0" allowfullscreen=""></iframe>
</div>
<h3>Non-Imperative Network Programming</h3>
<p><strong><a href="http://somerandomidiot.com">Mindy Preston</a> at Strangeloop - Sep 2015</strong></p>
<div class="flex-video">
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/GNc1t6Q5Dls" frameborder="0" allowfullscreen=""></iframe>
</div>
<p>Mindy also wrote a post that has some information and links:
<a href="http://somerandomidiot.com/blog/2015/10/07/ocaml-workshop-and-strange-loop-talks">http://somerandomidiot.com/blog/2015/10/07/ocaml-workshop-and-strange-loop-talks</a></p>
<h3>Leaving legacy behind — A clean-slate approach to operating systems</h3>
<p><strong><a href="https://github.com/hannesm">Hannes Mehnert</a> at Source_Code Berlin - Aug 2015</strong></p>
<div class="flex-video">
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/PTtI8hpR7hQ" frameborder="0" allowfullscreen=""></iframe>
</div>
<h3>Unikernels!</h3>
<p><strong><a href="http://amirchaudhry.com">Amir Chaudhry</a> at PolyConf - July 2015</strong></p>
<div class="flex-video">
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/nZLy19eRWLk" frameborder="0" allowfullscreen=""></iframe>
</div>
<p>There's more information about this talk in the blog post at:
<a href="http://amirchaudhry.com/unikernels-polyconf-2015">http://amirchaudhry.com/unikernels-polyconf-2015</a></p>
<h3>Next Generation Cloud</h3>
<p><strong><a href="https://twitter.com/RCPavlicek">Russell Pavlicek</a> at SouthEast LinuxFest - June 2015</strong></p>
<div class="flex-video">
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/8UgiPODw3CY" frameborder="0" allowfullscreen=""></iframe>
</div>
<p><em>Russ has also been at many other Linuxfests this year!</em></p>
<h3>Unikernels: Functional Infrastructure with MirageOS</h3>
<p><strong><a href="http://anil.recoil.org">Anil Madhavapeddy</a> at Esper Technologies - May 2015</strong></p>
<div class="flex-video">
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/bC7rTUEZfmI" frameborder="0" allowfullscreen=""></iframe>
</div>
<h3>My Other Internet is a Mirage (QCon SF 2013)</h3>
<p>This talk was given by <a href="http://anil.recoil.org">Anil Madhavapeddy</a> towards the
end of 2013, and outlines the overall architecture of MirageOS 1.0.</p>
<p>You can find a video of the talk along with synched slides <a href="http://www.infoq.com/presentations/mirage-os">at the InfoQ
website</a>.</p>
<h3>Mirage: Extreme Specialization of Cloud Appliances (OSCon, summer 2013)</h3>
<p><a href="http://mort.io">Richard Mortier</a> and <a href="http://anil.recoil.org">Anil Madhavapeddy</a> presented a developer preview of MirageOS 1.0 at OSCon.  The screencast below still uses the old <code>mirari</code> tool instead of the final version that shipped with MirageOS 1.0, but the screencast is included here for historical reasons.</p>
<div class="flex-video">
<iframe width="560" height="315" src="//www.youtube.com/embed/2Mx8Bd5JYyo" frameborder="0" allowfullscreen=""> </iframe>
</div>
<h3>Programming the Xen Cloud with OCaml (OCaml Workshop, Sep 2012)</h3>
<p><a href="http://www.youtube.com/watch?v=dJlHBS7sP_c&amp;feature=plcp">Dave's presentation</a>
at the 2012 OCaml Users and Developers Workshop, describing MirageOS and its use
as a way to build VMs for Xen in OCaml.</p>
<div class="flex-video">
<iframe width="420" height="315" src="//www.youtube.com/embed/dJlHBS7sP_c" frameborder="0" allowfullscreen=""> </iframe>
</div>
<h3>Mirage: extreme specialisation of virtual appliances, XenSummit 2012</h3>
<p>Anil's <a href="http://vimeo.com/57412215">presentation</a> at <a href="http://www-archive.xenproject.org/xensummit/xs12na_talks/M10b.html">XenSummit 2012</a> describing the architecture of MirageOS, and giving a quick demonstration of how to build a web-server that runs as a unikernel on a standard Xen installation.</p>
<div class="flex-video">
<iframe src="//player.vimeo.com/video/57412215" width="500" height="375" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""> </iframe>
</div>
<h3>Mirage: Building a Better Internet (Verisign Internet Infrastructure, 2011)</h3>
<p><a href="http://www.youtube.com/watch?v=5-4lbyD_Fvw&amp;feature=player_detailpage&amp;t=79">A short video</a> Verisign requested as part of a showcase of the
recipients of their &quot;Building a Better Internet&quot; 2011 grant symposium, discussing MirageOS and its importance for the ongoing health of the Internet.</p>
<div class="flex-video">
<iframe width="560" height="315" src="//www.youtube.com/embed/5-4lbyD_Fvw?start=79" frameborder="0" allowfullscreen=""> </iframe>
</div>
<h3>Mirage, A New Multi-Scale Operating System for Clouds and Crowds (LinkedIn SNA Tech Talk, Oct 2010)</h3>
<p><a href="http://twitter.com/strlen">Alex Feinberg</a> kindly hosted a MirageOS talk at <a href="http://linkedin.com">LinkedIn</a>'s Search Networks and Analytics Team (<a href="http://sna-projects.com/blog/2010/10/mirage/">blog</a>).</p>
<div class="flex-video">
<iframe src="http://player.vimeo.com/video/16189862" width="400" height="225" frameborder="0"></iframe>
<p><a href="http://vimeo.com/16189862">LinkedIn Tech Talk</a> by <a href="http://anil.recoil.org/">Anil Madhavapeddy</a></p>
</div>
<h3>Using functional programming within an industrial product group: perspectives and perceptions (ACM ICFP, Sept 2010)</h3>
<p>This was a report delivered at ICFP 2010 about our experiences with using OCaml
in the Xen management toolstack. Not directly Mirage-related, but much of the
inspiration for trying out OCaml in a microkernel environment came out of this
work. The <a href="http://portal.acm.org/citation.cfm?id=1863557">video</a> is
unfortunately only available behind the ACM paywall, but the paper can be found
<a href="/wiki/papers">here</a>.</p>
|js};
      };
      {
        updated = {js|2013-08-11 15:00|js};
        author =
          {
            name = {js|Anil Madhavapeddy|js};
            uri = Some {js|http://anil.recoil.org|js};
            email = Some {js|anil@recoil.org|js};
          };
        subject = {js|Running MirageOS Xen kernels|js};
        permalink = {js|xen-boot|js};
        body =
          {js|<p>Building a MirageOS unikernel for the Xen backend results in a Xen PV kernel with a <code>.xen</code> extension. This must be booted as a normal Xen domU kernel.  If you manage your own Xen, you'll be able to use configuration information automatically generated by <code>mirage</code>; some advice on booting with popular Xen-based cloud providers is also given below.</p>
<h2>Locally Managed Xen</h2>
<p>For recent Xen versions, Mirage will attempt to provide a reasonable configuration document for use with the <code>xl</code> tool.  The filename will be based on the string argument given to <code>register</code> in the unikernel's <code>config.ml</code>.  For instance, if your <code>config.ml</code> has lines like this:</p>
<pre><code>let () =
  register &quot;hello&quot; [main $ default_posix_clock]
</code></pre>
<p>then running</p>
<pre><code>    $ mirage configure -t xen
</code></pre>
<p>will generate a <code>hello.xl</code> file which references the location where the Xen machine image will be created.  After running</p>
<pre><code>    $ make depend
    $ make
</code></pre>
<p>the compiled machine image should be present at <code>hello.xen</code>.</p>
<pre><code>    $ sudo xl create hello.xl -c
</code></pre>
<p>will try to boot the unikernel and attach a console in the terminal from which the command was run.  To detach the console and recover the terminal, use <code>Ctrl-]</code>.  The unikernel will continue running, and you can resume viewing the console output with</p>
<pre><code>    $ sudo xl console hello
</code></pre>
<p><code>mirage configure -t xen</code> does its best to generate a good <code>.xl</code>, but frequently the file needs editing to reflect your local configuration.  Common changes are the name of the network bridge given on a <code>vif</code> line, and the name or location of disks specified in a <code>disk</code> line.</p>
<h2>Amazon EC2</h2>
<p>Amazon's Elastic Compute Cloud supports booting <a href="http://ec2-downloads.s3.amazonaws.com/user_specified_kernels.pdf">user-specified kernels</a>.  Currently MirageOS only knows how to create paravirtualized Xen images, so only those instance types which support PV will boot MirageOS unikernels.  To see a list of instance types which support PV guests, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/virtualization_types.html">the EC2 documentation on virtualization types</a>.  Users wishing to run unikernels on the t1.micro instance type will need to create EBS volumes usable in that configuration.</p>
<h3>Automated Solutions</h3>
<p><a href="https://github.com/acwpdx">Adam Wick</a> created <a href="https://github.com/GaloisInc/ec2-unikernel">ec2-unikernel</a> for deploying <a href="https://galois.com/project/halvm">HaLVM</a> on EC2.  For users who are happy to install an additional toolchain or outside dependencies, this may be a good, quick, and free solution for deploying Mirage unikernels to EC2.</p>
<h3>Less-Automated Solutions</h3>
<p>Booting the unikernel requires a two-stage boot process:</p>
<ul>
<li>The VM is launched using a <code>pvgrub</code> stub domain that is a micro-kernel containing a small grub interpreter.
</li>
<li><code>pvgrub</code> mounts the root device, looks for <code>/boot/menu.lst</code>, and parses it for the default kernel location on that filesystem.
</li>
<li>The actual kernel is loaded into memory, and <code>pvgrub</code> execs it, erasing it from memory.
</li>
<li>From this point on, the second kernel is active and boot proceeds normally.
</li>
</ul>
<p>To boot a MirageOS kernel on EC2, it must first be copied onto a block device known to AWS. After that, the image needs to be bundled into an Amazon Machine Image (AMI), and then registered as a bootable image using the EC2 tools.  Once there is a valid AMI registration, it's possible ot create and boot an instance based on the AMI.</p>
<h4>Generating an AMI</h4>
<p>First download the <a href="http://aws.amazon.com/developertools/351">API tools</a> and <a href="http://s3.amazonaws.com/ec2-downloads/ec2-ami-tools.zip">AMI tools</a> from Amazon.
Set the following environment variables:</p>
<ul>
<li><code>EC2_USER</code>: 12 digit account number (not email) obtained from the EC2 management console.
</li>
<li><code>EC2_ACCESS</code>: from Account/Access credentials in the EC2 management console.
</li>
<li><code>EC2_ACCESS_SECRET</code>: as above, in a different tab.
</li>
<li><code>EC2_CERT</code>: location of the certificate file you download from the Account/Access page.
</li>
<li><code>EC2_PRIVATE_KEY</code>: location of the private key.
</li>
</ul>
<p>There is a script that then takes care of packaging up the MirageOS kernel image and uploading it to Amazon automatically.
It is found at <a href="https://raw.githubusercontent.com/mirage/mirage/master/scripts/ec2.sh">scripts/ec2.sh</a> in the <code>mirage</code> repository, and you specify your <code>kernel.xen</code> file as the first argument to the script.</p>
<h4>Using micro instances</h4>
<p>To use the EC2 <code>t1.micro</code> instances the kernel needs to reside inside an EBS volume. To create a bootable EBS volume containing an MirageOS kernel use the following steps:</p>
<ul>
<li>Start a t1.micro Linux instance: <code>ec2-run-instances ami-7f418316 -k mirage -t t1.micro</code> - We need this instance to access the EBS volume which will later contain our MirageOS kernel
</li>
<li>Create an EBS volume: <code>ec2-create-volume --size 1</code> - We use the smallest possible size: 1G
</li>
<li>Attach volume to your instance: <code>ec2-attach-volume ${VOLUME} -i ${INSTANCE} -d /dev/sdh</code> - Where <code>$VOLUME</code> is your volume id and <code>$INSTANCE</code> is your instance id
</li>
<li>Login to the miro instance using ssh: <code>ssh -i mirage-ssh-key.pem ec2-user@${PUBLIC-AWS-NAME}</code> - Where <code>$PUBLIC-AWS-NAME</code> is your public DNS name of your running micro instance
</li>
<li>Create a partition on <code>/dev/sdh</code> and format it using <code>mkfs.ext2 /dev/sdh1</code> and mount the volume: <code>sudo mount /dev/sdh1 /mnt</code>
</li>
<li>Copy a Xen MirageOS kernel (e.g. the http example with DHCP enabled) to the running micro instance
</li>
<li>Login via ssh and move the kernel to <code>/mnt/kernel</code>
</li>
<li>Create grub directories <code>sudo mkdir -p /mnt/boot/grub/</code>
</li>
<li>Create grub menu.lst file in <code>/mnt/boot/grub/menu.lst</code>
</li>
</ul>
<pre><code>    default 0
    timeout 1
    title Mirage-Test
         root (hd0,0)
         kernel /kernel
</code></pre>
<ul>
<li>Log out of instance
</li>
<li>Create EBS snapshot <code>ec2-create-snapshot ${VOLUME}</code>
</li>
<li>You can stop the running micro instance now
</li>
<li>Register your AMI using <code>ec2-register --snapshot ${SNAPSHOT} --kernel aki-4e7d9527 --architecture x86_64</code> Note the familiar kernel id: This is the pv-grub kernel that is also used in <code>scripts/ec2.sh</code>.
</li>
<li>Start your EBS backed MirageOS kernel in a micro instance: <code>ec2-run-instances ${EBSAMI} -k mirage -t t1.micro</code>
</li>
</ul>
<h2>Rackspace?  Other Xen-based Cloud Providers?</h2>
<p>No one has tried this yet. Get in touch if you do!</p>
|js};
      };
      {
        updated = {js|2013-07-17 15:00|js};
        author =
          {
            name = {js|Richard Mortier|js};
            uri = Some {js|http://mort.io/|js};
            email = Some {js|mort@cantab.net|js};
          };
        subject = {js|OPAM Libraries|js};
        permalink = {js|opam|js};
        body =
          {js|<h3>Maintenance</h3>
<p>The <code>opam update</code> command refreshes all your package repositories. The <code>opam upgrade</code> command recompiles any outdated libraries. You need to run this once per compiler installed, so <code>opam switch</code> between them.</p>
<p>If you run into any problems with OPAM, then first ask on the MirageOS <a href="/about">mailing list</a>, or report a <a href="http://github.com/OCamlPro/opam/issues">bug</a>. It is safe to delete <code>~/.opam</code> and just start the installation again if you run into an unrecoverable situation, as OPAM doesn't use any files outside of that space.</p>
<h3>Development</h3>
<p>There are two kinds of OPAM repositories: <code>stable</code> released versions of packages that have version numbers, and <code>dev</code> packages that are retrieved via git or darcs (and eventually, other version control systems too).</p>
<p>To develop a new package, create a new <code>opam-repository</code> Git repo.</p>
<pre><code>$ mkdir opam-repository
$ cd opam-repository
$ git init
$ mkdir packages
$ opam repository add mypkg .
</code></pre>
<p>This will configure your local checkout as a package repository, and OPAM will pull from it on every update. Each package lives in a directory named with the version, such as <code>packages/foo.0.1</code>, and requires three files inside it:</p>
<ul>
<li><code>foo.0.1/url</code> : the URL to the distribution file or git directory
</li>
<li><code>foo.0.1/opam</code> : the package commands to install and uninstall it
</li>
<li><code>foo.0.1/descr</code> : a description of the library or application
</li>
</ul>
<p>It's easiest to copy the files from an existing package and modify them to your needs (and read the <a href="http://opam.ocaml.org">doc</a> for more information). Once you're done, add and commit the files, issue an <code>opam update</code>, and the new package should be available for installation (<code>opam install</code>) or upgrade (<code>opam upgrade</code>).</p>
|js};
      };
    ]
end

module Weekly = struct
  type t = {
    updated : string;
    author : People.t;
    subject : string;
    permalink : string;
    description : string;
    body : string;
  }

  let all =
    [
      {
        updated = {js|2016-03-02 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2016-03-02|js};
        permalink = {js|weekly-2016-03-02|js};
        description =
          {js|2nd Mar 2016: Decision to drop 4.01, 2.7 released, Hackathon and CI.|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Quality and Test
</li>
<li>MirageOS 2.7 released!
</li>
<li>MirageOS Hackathon next week!
</li>
<li>GSoC / Xen
</li>
<li>Basic CI
</li>
<li>Pinned packages
</li>
</ul>
<p>Attendees:
Amir, Gemma, Dan Williams, talex5, mindy, Drup, ThomasG, Mort, Hannes
DavidK, SeanG, Anil, Chris ?, Daniel.</p>
<h3>Notes</h3>
<h4>Quality and Test</h4>
<ul>
<li>Anil working it. Got extra users now. Tests for 4.03.0 are running.
</li>
<li>Folks should switch to <code>-ppx</code> extensions instead (anyone using camlp4 should
switch)
</li>
<li>Discussion and decision that we should move to 4.02 support only (i.e. drop
support for 4.01). No strong objections to this in the last few weeks.
</li>
<li><code>camlp4toppx</code> works really well. Rudi wrote a good blog post on this. Anil
found some bugs so does it manually.
</li>
<li>Need to jump over at some point to ppx :) Need to do it together.
</li>
<li>If we had virtual packages it would have been easier to transition. Tedious
to go through every single package. TG: sometimes you have new depopts?
AM: Will take a look properly and figure it out. Virtual packages seem the way
to go, but no clean answer right now.
</li>
<li><code>cstruct</code> is one of the first packages that we need a pure version of (i.e.
not camlp4). It has many reverse dependencies. To build, it doesn't require
camlp4.
</li>
<li>Some comments about tyxml.
</li>
</ul>
<h4>MirageOS 2.7 released!</h4>
<ul>
<li>Yay for release! Thanks everyone!
</li>
<li>TG: Have seen an issue with the block devices. If you look at <code>mirage-www</code>
we notice block device issues. <code>mirage-www</code> needs only one but mounts 5.
</li>
<li>Gabriel thinks he knows why and will comment on the issue.
</li>
</ul>
<h4>MirageOS Hackathon</h4>
<ul>
<li>Hannes has booked flights. All seems to be fine!
</li>
<li>Food at breakfast, 2pm and evening! All sorted.
</li>
<li>Could possibly have people joining remotely, maybe folks from Cambridge.
</li>
<li>How many people interested in that and is it possible to do that?
<ul>
<li>There's internet at the venue and someone could do that (won't be Hannes).
</li>
<li>Benefit is it's in the same time zone as the UK.
</li>
</ul>
</li>
<li>Will use the IRC channel for comms if people want to join remotely.
If anyone can transport books to Morocco, please tell Hannes :)
</li>
</ul>
<h4>GSoC / Xen</h4>
<ul>
<li>Xen Project not part of GSoC this year. 2nd year in a row that Xen isn't
selected. Many other orgs didn't get selected either.
</li>
<li>SG: Clojure org not selected either  and they have been for several years.
Seems like Google just narrowing their organisation inclusion criteria.
</li>
<li>Suggestion about applying as unikernel.org. AC will take a look at
requirements.
</li>
<li>Suggestion to look into ESA summer of code.
</li>
<li>We're still part of Outreachy though.
</li>
</ul>
<h4>Basic CI</h4>
<ul>
<li>SeanG was surprised that when we went to deploy, he hit the <code>bootvar</code> issue
when deploying to public cloud. Having some basic test harness would be good.
</li>
<li>Looking at setting up a unikernel workshop at the OCaml meetups and having a
CI set up would be great for this. Sean can take a crack at getting this up
and running.
</li>
<li>SeanG's tests needs to be running on EC2 to test things. As we move into
more real world production it'll be an issue.
</li>
<li>Need to have test set ups working for all major cloud providers. Current
testing is mostly compilation and units tests (e.g. <code>mirage-skeleton</code>). Should
also be testing <code>bootvars</code> to see if it can handle arbitrary things.
</li>
<li>We're missing an end-to-end solution.
</li>
<li>Spiros has EC2 bindings so Mindy will plan a blog post. SG: Mindy's scripts
were really useful in getting started — thank you for those.
</li>
</ul>
<h4>Pinned packages</h4>
<ul>
<li>SG: Wants to deploy unikernel-based service at his company. Need to have a
consistent dev environment to share with others. Has manual instructions to
pin packages (frustrating). People should make releases (but even then,
doesn't deal with the problem of versions.).  Maybe functoria can be used to
define things?
</li>
<li>AM: Maybe have mirage output a manifest and that's consumed by opam (instead
of baking opam into Mirage). Then we can use container infrastructure. Trying
to control everything from config.ml is difficult.
</li>
<li>Containers make OPAM much easier. Right environment with everything
precompiled. Easy for app to build on top of the container rather than
controlling everything via config.ml
</li>
<li>Can also create your own remotes with packages. It's a pain but it does work
and only requires one instruction.
</li>
<li>These days we should not really call opam from within mirage :)  Would make
it easier to run mirage in a deployment pipeline. Would also make sense to
remove the depexts.
</li>
<li>Most of this possible but not well integrated yet. Would like to get a
config.ml to dockerfile thing.
</li>
<li>Need better cross-platform support.
</li>
<li>SG: Unclear about how mirage creates a makefile.
</li>
<li>DBuenzli: cross compilation for 1.3 in opam? Louis has a lot of stuff to
work on for opam internals. Windows has made good progress too. If anyone has
time to look at windows stuff, that would be useful too.
</li>
</ul>
<p>--</p>
<h4>AoB</h4>
<ul>
<li>
<p>Are video calls useful to people? Thoughts that calls are not useful without
previous notes. Amir thinks calls are useful as long as people contribute to
an agenda. Can try an IRC meeting during the Hackathon.</p>
</li>
<li>
<p>The next call is scheduled for <strong>16th March</strong>. Please add any
<a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">agenda items</a> you wish to discuss in advance and refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2016-02-17 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2016-02-17|js};
        permalink = {js|weekly-2016-02-17|js};
        description =
          {js|17th Feb 2016: Containers, 2.7 prep, Hackathon and Netmap.|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Quality and Test
</li>
<li>Functoria status
</li>
<li>GSoC
</li>
<li>MirageOS Hackathon status
</li>
<li>Persistent storage on Xen (FAT/btree/...)
</li>
<li>Netmap
</li>
</ul>
<p>Attendees:
Amir, ThomasL, Mindy, Gemma, Hannes, tchell, Mort, Dave Scott, DanielB,
Anil, Jeremy, ThomasG.</p>
<h3>Notes</h3>
<h4>Quality and Test</h4>
<ul>
<li>Anil has all containers pushed now and you can see them at
https://hub.docker.com/r/ocaml/opam/
</li>
<li>The <a href="https://hub.docker.com/r/ocaml/opam/">description</a> there contains all
the info you need
</li>
<li>We'll try and use Alpine as the 'base' as it's small.
</li>
<li>Anil planning to write this up when he gets a chance.
</li>
<li>These images should make it easier to run tests across many platforms etc
</li>
<li>Still needs support for Arch Linux etc.
</li>
<li>There are things to check but we're doing well. 150 containers now.
</li>
<li>DanielB tried it and liked it as he used to test his things with Virtual Box.
Now just has to log in with command line and test things.
</li>
</ul>
<h4>Functoria status</h4>
<ul>
<li>Jeremy is happy and has merged a few things into Functoria. No objections
from ThomasG.
</li>
<li>This will be a 2.7 release (not a 3.0).
</li>
<li>Functoria Blog post has a couple of TODO's — one of which was a come up with
a reasonable example. There's a PR in the mirage-www repo. Mindy will consider
that.
</li>
</ul>
<h4>GSoC</h4>
<ul>
<li>Mort will be one of the GSoC admins along with Lars. This is lightweight and
is mostly cover in case he's away.
</li>
<li>Application going in soon.
</li>
<li>Lars also wanted to check that our projects are up to date.
</li>
</ul>
<h4>MirageOS hackathon</h4>
<ul>
<li>Hannes has put up wiki pages. Not many people have added things to them.
</li>
<li>Support/sponsorship for students in place too.
</li>
</ul>
<h3>Persistent storage on Xen (FAT/btree/...)</h3>
<ul>
<li>Have a lot of people asking about storage.
</li>
<li>Dave working on block backend for Irmin and will take a while to get this
done. Anyone else available to work on filesystems?
</li>
<li>Mort has a UG student working on a filesystem thing. It's working well
enough that there's a performance evaluation underway.
</li>
<li>Not written up yet but will encourage a release.
</li>
<li>Question on the mailing list where folks are using the FAT filesystem to
store things. It's a shame that Irmin doesn't work on Xen.
</li>
</ul>
<h4>Netmap</h4>
<ul>
<li>We had a chat with Wassim from Erriscon for netmap backend instead of Xen
backend. We think this is something for xen-devel. Xen folks may have started
one but not sure where things stand. Maybe Wassim should use MiniOS for now.
</li>
<li>No-one's used netmap. Maybe Wassim et al can use it and get back to us with
comments.
</li>
<li>There are pieces in several places. Anil will reply to the email.
</li>
</ul>
<p>--</p>
<h4>AoB</h4>
<ul>
<li>
<p>Quite a few people posting questions on stack overflow. The tag is <code>mirage</code>.
DanielB saw them but was waiting for others to respond. We may want to
consider a link on the mirage.io site to point people at stack overflow. That
means spending more time there ourselves, though.</p>
</li>
<li>
<p>Late notes: Notes are still delayed — Amir has less time to write things up
properly. Dave recommends declaring a 'notes amnesty'. Focus on future notes
instead? Gemma offered to help. Amir will discuss with Gemma.</p>
</li>
<li>
<p>The next call is scheduled for <strong>2nd March</strong>. Please add any
<a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">agenda items</a> you wish to discuss in advance and refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2016-02-03 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2016-02-03|js};
        permalink = {js|weekly-2016-02-03|js};
        description = {js|3rd Feb 2016: Dropping 4.01 support and Hackathon.|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Quality and Test
</li>
<li>Functoria status
</li>
<li>Outreachy status
</li>
<li>MirageOS Hackathon status
</li>
</ul>
<p>Attendees:
Amir (chair), Anil, Thomas Leonard, Dave Scott, Thomas G, Mort,
Dan Williams, Daniel, Chris, matt-g, Hannes, pablo polvorin, Jeremy</p>
<h3>Notes</h3>
<h4>Quality and Test</h4>
<ul>
<li>Merged a huge test from Jane street.
</li>
<li>Now have a camlp4-free version and can compile very fast.
</li>
<li>Now need to do a bunch of point releases related to the change.
</li>
<li>Just need to rename some of the dependencies — will remove the constraints
we have.
</li>
<li>Overall effect is we can depend on PPX only.  Does anyone need to support
4.01 anymore?
</li>
<li>Should focus on 4.02 and trunk. Only the Xen people might care.
</li>
<li>Docker containers work and they're all published. Thanks to DBunzli for
feedback.
</li>
<li>Should be able to test all distros from a PR.
</li>
<li>4.01 is in Debian. Stick with it for that?
</li>
<li>Since we have docker containers and opam switch, we should probably leave
4.01 behind now. Hard to maintain both camlpp4 and ppx.
</li>
<li>Maybe keep the libs supporting 4.01 where possible but not be tied to it.
</li>
<li>DanW: The Docs should be updated to match. Anil: we have codoc that we used
but need to finish this. Thanks for reminder.
</li>
</ul>
<h4>Functoria status</h4>
<ul>
<li>Not much to say since last time. On the brink of the release.
</li>
<li>Should coordinate with press release?
</li>
<li>Code review status? Yallop looking over it but otherwise happy.
</li>
<li>Anil noticed one issue when trying to look at dependency chain for the xen
packages. Will file an issue.
</li>
<li>Some question since Solo5 is a different backend. Should we adjust the
config now to be able to work with this and other backends? We should have a
blocker to mirage 3.0?
</li>
<li>In terms of functoria tutorials. There's the blog post but not much more.
Mort is going to try out Solo5 stuff this weekend.
</li>
<li>Rumprun and MirageOS and Functoria? Cross-compilation is still a 'thing'.
Adam Wick is trying things with HaLVM and Rump kernels so we can follow in his
footsteps once things are clearer.
</li>
</ul>
<h4>Outreachy Status</h4>
<ul>
<li>Kia is on east coast US. Sent an email to list yesterday about the code and
a blog post. Another 4 weeks to go. All is in hand.
</li>
<li>Difficult to join calls due to timezone.
</li>
</ul>
<h4>MirageOS hackathon</h4>
<ul>
<li>We have over 30 people signed up — but we have 27 beds :)
</li>
<li>Can people participate remotely? Anil will bring video conf stuff
</li>
<li>If we have crucible projects that would be useful. Half the people are new
to MirageOS. Particularly end-to-end app problems would be good.
</li>
<li>Hannes has set up a mailing list for participants. Will kick this off so
people can chat. Will also bring labels to the meeting.
</li>
<li>Hannes' plan was to write to the mailing list and make a wiki page to enable
collaboration amongst people.
</li>
<li>Hope someone else will organise another one in three months!
</li>
</ul>
<p>--</p>
<h4>AoB</h4>
<ul>
<li>
<p>Mailing list and devel.unikernel.org: Should we use the latter more? Move
all the old MirageOS threads in there? There may be utility to share things
between unikernel projects. Would need to plan for a cut over date. DBunzli
likes mailing list for discussion quality. Should set up a test to ingest
archive.</p>
</li>
<li>
<p>SCALE conference: Snow storm cancelled Anil's flight. Amir and Mort made it.
Videos are online.</p>
</li>
<li>
<p>Cross compilation discussion with rump/solo5 etc. Next step for DanW is to
get familiar with build system stuff (and Functoria). Ask Gabriel Radanne re
the call. Can have a wiki to put info into as people discover things.
DBunzli: the first things we need is support in opam, which allows us to do it
in a clean fashion. People have been working on this.</p>
</li>
<li>
<p>The next call is scheduled for <strong>17th February</strong>. Please add any
<a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">agenda items</a> you wish to discuss in advance and refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2016-01-13 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2016-01-13|js};
        permalink = {js|weekly-2016-01-13|js};
        description =
          {js|13th January 2016: Test, Hackathon, Talks and Blog posts.|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Quality and Test
</li>
<li>Functoria release status
</li>
<li>Logging
</li>
<li>License files
</li>
<li>MirageOS hackathon status
</li>
<li>MirageOS talks at SCALEx14
</li>
<li>Irmin blog posts
</li>
</ul>
<p>Attendees:
Amir Chaudhry (chair), Dan Williams, Mindy, Thomas Leonard, Dave Scott, Anil,
Daniel Bunzli, David Kaloper, Hannes, Drup</p>
<h3>Notes</h3>
<h4>Quality and Test</h4>
<ul>
<li>Travis added support for Precise.
</li>
<li>Anil refreshed OCaml Docker images/builds
</li>
<li>Lot of work done on the new Travis CI. If anyone else wants to try it out,
get in touch with Anil. Can do Travis test of Ubuntu, Alpine, etc. from a
single .yml. Not Gentoo and nixOS.
</li>
<li>If anyone has a distro that's not in the list it's easy to add to the DSL
and we'd like all Linux distros to be there. Can eventually get windows in
there, too — depends on upstream support for docker.
</li>
<li>This should all make opam bulk builds a lot better
</li>
</ul>
<h4>Functoria status</h4>
<ul>
<li>Bits of it got refactored and some more to be done around the definition of
keys etc.
</li>
<li>Anil wil refresh decks to use it and will makes sure it boots on Xen. Was
mainly tested on Unix
</li>
</ul>
<h4>Logging</h4>
<ul>
<li>TL made some update to <code>mirage-logs</code> as a result of other updates.
</li>
<li>Would be interested in API suggestions etc and will make it an opam package
soon.
</li>
<li>Would be good to integrate with Functoria.
</li>
<li>Mindy intends to do that and Anil is using it with decks.openmirage.org.
</li>
<li>Gabriel replied to comments by email.
</li>
</ul>
<h4>MirageOS hackathon</h4>
<ul>
<li>15 people have registered!  More non-Cambridge than Cambridge people!  YAY!
</li>
<li>There are no replies when you register. Will send confirmations.
</li>
<li>Hannes will hopefully get some camel to eat.
</li>
<li>AC would like public visibility of hackathon activity/projects. HM doesn't
want to do upfront organisation of projects.
</li>
<li>Experience level of people attending not clear but people have motivation to
work on this.
</li>
<li>Might be worth sending reminder to list that any experience level is ok.
</li>
<li>Hopefully form groups of common interest.
</li>
<li>People might show up at random times at the beginning.
</li>
<li>Anil will bring a bunch of cubie boards. Hannes would also like some
yubikeys!
</li>
</ul>
<h4>LICENSE files</h4>
<ul>
<li>Nobody really wants to make any comments :)
</li>
<li>Multi licensed repos should arguably be split into multiple repos.
</li>
<li>Single license makes things easy.
</li>
<li>Some discussion on whether we need LICENSE files
</li>
</ul>
<h4>MirageOS at SCALEx14/CIF2016</h4>
<ul>
<li>There are 5 MirageOS related talks at SCALE/CIF2016
</li>
</ul>
<h4>Blog posts</h4>
<p><strong>MirageOS end-of-year review</strong> — Status update.  Anil has a bunch of notes.
holding off on that until the release and do the review at the same time.
Perhaps the end of Jan. Maybe February.  Want people to use Functoria when
they read the review post.</p>
<p><strong>Irmin posts</strong> - Ask on Monday :-P</p>
<p>--</p>
<h4>AoB</h4>
<ul>
<li>
<p>Outreachy student? Hannes will meet again in IRC. Parsing of NTP is done.
Invite to these calls but she's in Seattle timezone though.</p>
</li>
<li>
<p>SCALE/CIF2016 conference. Arriving Thursday evening. Leave Saturday.
Definitely two MirageOS folks.</p>
</li>
<li>
<p>Late notes: Amir is wondering if someone else would be interested in taking
notes. Would be better than having delayed notes. :)</p>
</li>
<li>
<p>The next call is scheduled for <strong>27th January</strong>. Please add any
<a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">agenda items</a> you wish to discuss in advance and refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2015-12-16 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2015-12-16|js};
        permalink = {js|weekly-2015-12-16|js};
        description =
          {js|16th December 2015: Conduit, Unikernel Events and end of 2015!|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>vchan and conduit
</li>
<li>Unikernel Events
<ul>
<li>CIF16 (CfP closes 19 Dec, event is in Pasadena CA on 22 Jan)
</li>
<li>Hello World party
</li>
<li>Hackathon
</li>
</ul>
</li>
<li>Blog posts
<ul>
<li>Status updates (unikernel.org, Charrua, end-of-year)
</li>
</ul>
</li>
<li>Pioneer Projects
<ul>
<li>review of list (1 star projects esp)
</li>
<li>outreachy (progress so far)
</li>
</ul>
</li>
<li>Last call of 2015!
</li>
</ul>
<p>Attendees:
Amir Chaudhry (chair), Thomas Leonard, Jon Ludlam, Mindy Preston, Dave Scott,
Dan Williams, Jeremy Yallop, Wassim.</p>
<h3>Notes</h3>
<h4>vchan and conduit</h4>
<ul>
<li>JonL not had a chance to look at vchan. Hopefully will have more time soon.
</li>
<li>It comes up during the logging discussions and etc.
</li>
<li>Mindy has used conduit, but can't really answer q's for others. Reminder
that <code>Conduit</code> is a an abstraction over networking things, including <code>vchan</code>.
</li>
</ul>
<h4>Functoria</h4>
<ul>
<li>Jeremy submitted a patch and Thomas merged.
</li>
<li>JonL made it work this time (possible that last time was due to older
MiniOS). Had to pin <code>mirage-xen-bootvar</code> repo as released version didn't work.
</li>
<li>Magnus has been looking after that. Has merged all patches submitted and
will check if we need a release. Mindy and JonL will then try.
</li>
<li>Drup's patch is important to look at.  That was also merged last night.
Folks should try Functoria master branch.
</li>
</ul>
<h4>Unikernel Events</h4>
<p><strong>Cloud Innovator Forum</strong> — Submitted three proposals. Some would rather be at
dev/winter but will submit anyway.  Jeremy can help prep something. Dan will
submit a talk to CIF16.</p>
<p><strong>Unikernel install party</strong> — Some folks would like this. Who's going to lead?
Needs a date (Feb 22nd?). Mindy can help but not be responsible for
organisation.</p>
<p><strong>MirageOS hackathon</strong> — Seems there are a bunch of ppl interested.</p>
<h4>Blog posts</h4>
<p><strong>MirageOS end-of-year review</strong> — Status update.  Jeremy made a list of things
to look at.  If someone from community with an outsider perspective would like
to help with this, that would be great. Our understanding is that Anil will
write this.</p>
<p><strong>Unikernel.org post</strong> - Ok to merge?</p>
<p><strong>Charrua post</strong> - Will merge this post tomorrow. Mort to check things work.</p>
<h4>Pioneer Projects</h4>
<p><strong>1 star projects</strong> — Should review the list.  Email list to ask for more
projects. Maybe add time-rating.</p>
<p><strong>Outreachy</strong> — One student will be working on NTP. Should invite them to join
the calls.</p>
<h4>Last call of 2015!</h4>
<p>Happy holidays!</p>
<p>--</p>
<h4>AoB</h4>
<ul>
<li>
<p>TL been adding netback support. Messing with Dave's and it's working and can
send packets. Looking at Mindy's NAT lib - soon to make firewall for QubesOS!</p>
</li>
<li>
<p>The next call is scheduled for <strong>NEXT YEAR!</strong> Please add any
<a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">agenda items</a> you wish to discuss in advance and refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2015-12-02 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2015-12-02|js};
        permalink = {js|weekly-2015-12-02|js};
        description =
          {js|2nd December 2015: Website stability, Functoria, QubesOS and Hackathons|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Quality and Test
</li>
<li>Functoria
</li>
<li>Blog posts
<ul>
<li>Charrua
</li>
<li>Irmin update
</li>
<li>End-of-year review
</li>
<li><a href="http://unikernel.org">unikernel.org</a>
</li>
</ul>
</li>
<li>MirageOS AppVMs on Qubes
</li>
<li>Unikernel size
</li>
<li>Unikernel hackathons
</li>
<li>Pioneer Projects
<ul>
<li>1-star projects
</li>
<li>Outreachy
</li>
<li>Longer term projects
</li>
</ul>
</li>
</ul>
<p>Attendees:</p>
<p>Amir Chaudhry (chair), Thomas Gazagnaire, Wassim Haddad, Thomas Leonard,
Jon Ludlam, Anil Madhavapeddy, Hannes Menhert, Richard (Mort) Mortier,
Mindy Preston, Dave Scott and Jeremy Yallop</p>
<h3>Notes</h3>
<h4>Quality and Test</h4>
<p>We've had some recent issues with MirageOS website uptime (see
<a href="https://github.com/mirage/mirage-www/issues/404">mirage/mirage-www#404</a> — the issue number is quite ironic).  Part of the
problem in debugging this is that we don't have adequate log capturing yet. We
could put the site in auto-restart mode but it's much better to know that it's
down and work towards a fix (rather than relying too heavily on restarts).</p>
<p>One approach is to rewrite <code>xenconsoled</code> to have more flexibility to output
logs.  We could turn this into a <a href="https://github.com/mirage/mirage-www/wiki/Pioneer-Projects">Pioneer Project</a>. Mort can write up a
short paragraph and Anil/Dave/ThomasG can be mentor(s). There may even be
existing patches out there that we could try now but it's actually quite
tricky to recompile these without crashing the machine. Any help from others
would be appreciated.</p>
<p>Another one of the required pieces is a reporter for logs.  ThomasL wrote one
and will send an email to the list with information on the issues he came
across.</p>
<h4>Functoria</h4>
<p>Jeremy has been looking over this carefully, comparing with things in
<code>mirage-dev</code>, and fixing some xen-related issues.  This is still ongoing and
it's just a lot of little things that need cleaning up e.g. console connects
to xenstore, so it's a little bit different. The unix aspects have been
checked over carefully but we're also checking that the xen pieces are also ok.
Jeremy will try and post updates on how things are going.  The release gate
for Functoria might be when <code>mirage-www</code> runs with a dynamic block device
using functoria (that should stress everything).</p>
<p>JonL tried functoria stuff and had a few issues but it wasn't clear if this
was due to functoria or some other issue with Opam.  Will delete <code>~/.opam</code> and
try again. ThomasL also tried functoria and it worked well but on Qubes (his
primary OS), there were some issues as it makes assumptions.</p>
<h4>Blog posts</h4>
<p><strong>Charrua</strong> — There's still a pending blog post which should be ready to merge.
The related code for <code>mirage-skeleton</code> has already been reviewed and merged
and the last step is to check the blog post one last time (it's already been
reviewed by others).</p>
<p>Sidenote: At the moment no-one has had a chance to look at making a DHCP
client with Charrua. It would be good if someone could work towards this and
perhaps we could make it a <a href="https://github.com/mirage/mirage-www/wiki/Pioneer-Projects">Pioneer Project</a>, but it would likely be a
5-star one.</p>
<p><strong>Irmin update</strong> - There have been a lot of Irmin releases since the
<a href="https://mirage.io/blog/introducing-irmin">introductory blog post</a> and it would be good to get a follow up
post about the progress that's been made.  Given the amount of work underway,
it's not likely that ThomasG will be able to write this.  He'd like to explain
what the summer interns did and also document the language bindings that
exist — getting all this in one post would be quite lengthy.  He'll try to
find some time to put thoughts down.  Perhaps we can encourage those who wrote
the language bindings to write things up.</p>
<p>Since there are likely to be a number of Irmin-related posts, we can set up a
short schedule of posts (as we've done before) — can aim to do this around
January or February.  There doesn't need to be any big fanfare about this,
just a mechanism to help get the posts out.  For example, surfacing details on
how to upgrade from v0.9 to v0.10 would be a useful post.</p>
<p><strong>MirageOS end-of-year review</strong> — We've done this previously for <a href="https://mirage.io/blog/2014-in-review">2014</a> and
it was well received, so we should continue the pattern. We have a lot of
material to draw on, in terms of <a href="https://mirage.io/releases/">changelogs</a>, <a href="https://mirage.io/blog/">blog posts</a> and
these <a href="https://mirage.io/wiki/#Weekly-calls-and-release-notes">call notes</a>. Jeremy agreed to take a look at this and see what he can
start pulling together for others to look over.</p>
<p><strong>Unikernel.org</strong> — There's also a new community site for unikernels as a
whole at <a href="http://unikernel.org">unikernel.org</a>. Having a short post here to introduce that would
be useful and Amir will put something together before the next call. Others
are welcome to discuss or comment via <a href="https://github.com/mirage/mirage-www/issues/412">mirage-www#412</a>.</p>
<h4>MirageOS AppVMs on Qubes</h4>
<p>ThomasL has been running some MirageOS VMs on <a href="https://www.qubes-os.org">Qubes OS</a> (which is his main
work environment). He's working on a library to provide support for this
(<a href="https://github.com/talex5/mirage-qubes">talex5/mirage-qubes</a>), which does enough help the user do something useful.</p>
<p>ThomasL would like to implement a MirageOS firewall VM to replace the existing
firewall in Qubes OS.  In order to do this, he needs to implement netback
support. Dave has a branch somewhere that may help with that and will look at
merging it into a current repo.  Joanna (Qubes OS project lead), was also
asking on Twitter about running a GPG backend as a MirageOS unikernel. It
wasn't clear how much additional work would be needed over the existing TLS
efforts.  Hannes pointed out that there could be quite a bit of work depending
on what exactly is required. Help is welcome and there's a thread on the
mailing list — &quot;<a href="http://lists.xenproject.org/archives/html/mirageos-devel/2015-11/msg00116.html">MirageOS AppVMs on Qubes</a>&quot;</p>
<p><a href="https://twitter.com/rootkovska/status/672079159687053313"><img src="/graphics/qubes-tweet.png" alt="rootkovska's tweet about MirageOS and Qubes OS" /></a></p>
<h4>Unikernel size</h4>
<p>There was a question on the list from Wassim about getting back to very small
unikernels.  Wassim is doing a project on MirageOS and running on a very low
memory budget (on x86). Hence any reduction will make a big impact on his use
case. The focus is a DHCP server on Xen and they need to reduce the size as
they're linking it with other components. He was wondering what the runtime
size was for the MirageOS DNS app. It seems that used to be below 8MB but
trying to make it any smaller was tricky just due to how Xen.  Wassim would be
overjoyed if he can get his runtime size down to such levels.</p>
<p>Anil pointed out that the upcoming 'flambda' patch to the OCaml compiler will
improve things for all OCaml code. Perhaps we can look again at memory usage
when we do our DHCP server using Charrua. Making this runtime small is
important for MirageOS too as, we want to deploy to ARM devices.</p>
<p>Wassim will make an issue on the mirage/mirage issue tracker so that we follow
up with this.</p>
<h4>Unikernel hackathons</h4>
<p>We ended up discussing two separate types of events, a unikernel 'install
party' (like the Linux install parties of yore) and a longer MirageOS
hackathon/retreat/dev-meeting.</p>
<p><strong>Unikernel install party</strong> — There seems to be desire amongst people to
explore some of the other unikernel implementations that are available, e.g.
HaLVM, Rump Kernel, IncludeOS, etc.  However, getting started with any of
these can be non-trival as the getting the environment set up appropriately
takes prior knowledge.  We thought about arranging the equivalent of an
'install party' (perhaps a 'Hello World!' party?), so that people can get
going quickly with a number of different implementations.  We'd likely find
many ways to improve the onboarding experience for all the implementations.
Perhaps we could link this up with the London Unikernel Meetup?  Mid-February
might be a good time to do this as a one-day/evening event and we could set
the scope to be quite broad (and thus invite a lot more people).</p>
<p><strong>MirageOS hackathon</strong> — There is also desire to hold an OpenBSD-style
hackathon purely for MirageOS.  This would be an event over several days, with
the emphasis on writing code and working towards some goals (to be defined at
the beginning of the event).  Ideally, this would be held at some other
location where people would travel to.  This event could be arranged to take
place in March/April to give people enough time to plan.</p>
<p>Since both events are serving different needs, there's no reason we couldn't
do both. It's mostly a matter of organising and ensuring that there would be
enough participants for both.</p>
<h4>Pioneer Projects</h4>
<p><strong>1 star projects</strong> — In the run up to the holidays, it would be great if we
can gather a few more 1-star Pioneer Projects.  This will help anyone who's
thinking of getting started with MirageOS over the break, even if they don't
contact anyone directly.  It would also be timely to review the star-ratings
for the current projects. On the next call, it would be good to review the
project list to see where things stand.</p>
<p><strong>Outreachy</strong> — One student will be working on NTP, which will have benefits
to a number of other projects.  Hannes is mentor and Mort can provide advice
on what he had to do as a mentor from last time — the reporting requirements
seem to be quite lightweight.</p>
<p><strong>Longer projects</strong> — There was also the suggestion of more 'elastic' projects.
These would be areas that start off easy and small but can expand and become
more substantive pieces of work (e.g. can last for 3 months). Performance
regression testing is one such area.  Projects like this would also help
onboard new contributors over an extended period.</p>
<p>--</p>
<h4>AoB</h4>
<ul>
<li>
<p><code>vchan</code> and <code>conduit</code> — JonL can pick up <code>vchan</code> again. ThomasL is using it
for Qubes and Mindy has a number of uses for it. Wassim is also using it so
improvements are welcome (it's a critical piece of their stack). Wassim's aim
is to use <code>conduit</code> but docs are quite sparse and any links to more would be
useful. Anil has blog post somewhere that he can link to.</p>
</li>
<li>
<p>The next call is scheduled for <strong>Wednesday, 16th December</strong>. Please add any
<a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">agenda items</a> you wish to discuss in advance and refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2015-11-11 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2015-11-11|js};
        permalink = {js|weekly-2015-11-11|js};
        description =
          {js|11th November 2015: Functoria, Logs, Protocol lists and unikernel logos|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Functoria release
</li>
<li>Logging
</li>
<li>Pioneer Projects
</li>
<li>List of Protocols
</li>
<li>mirage-www deployment
</li>
<li>Unikernel logo contest
</li>
</ul>
<p>Attendees:
Atluxitiv, Daniel Bunzli, Amir Chaudhry (chair), Justin Cormack,
Thomas Gazagnaire, David Kaloper, Thomas Leonard, Anil Madhavapeddy,
Richard (Mort) Mortier, Mindy Preston, Gabriel Radanne and Dave Scott</p>
<h3>Notes</h3>
<h4>Functoria release</h4>
<p><em>See release tracking in <a href="https://github.com/mirage/mirage/issues/447">mirage/mirage#447</a></em></p>
<p>Work on functoria is progressing and ThomasG finished doing his review and is
generally happy with the PRs. There are a few issues to deal with that are not
related to functoria itself.  The most important issues have been resolved. A
few people have tried things and said they were happy with it. It would really
benefit from more public testing and we've asked MattG to take a look.</p>
<p>Need to fix the <code>mirage-www</code> deployment scripts first (see below) and then use
functoria there and see that it works properly. Gabriel offered to redo the
commits that ThomasG had to revert.</p>
<p>Mindy and Jeremy have also been trying to write a front end to functoria
(ncurses etc) — Mindy was trying to write a JavaScript one. This would
showcase the other side of functoria for users of the libs (rather than just
for MirageOS developers).</p>
<p>There's a blog post to go along with the release (<a href="https://github.com/mirage/mirage-www/pull/396">mirage/mirage-www#369</a>),
which has been reviewed and the remaining TODOs have been addressed. Waiting
for a few things to be fixed before release and we don't want to rush this.
The next step will be to begin tagging things.</p>
<h4>Logging</h4>
<p>A few people are trying out Daniel's <a href="http://erratique.ch/software/logs">Logs</a> library. It would be good if
ThomasL can take a look at it in an <code>lwt</code> context. It's actually being tried
out in the ocaml-9p lib (<a href="https://github.com/mirage/ocaml-9p/pull/18">mirage/ocaml-9p#18</a>).  We might be able to use
this in functoria but needs more discussion.</p>
<p>We should prod for more of the logging discussion to happen on the main
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a>.</p>
<h4>Pioneer Projects</h4>
<p><strong>Outreachy</strong> — We're still in the <a href="https://wiki.gnome.org/Outreachy/2015/DecemberMarch#Participating_Organizations">Outreachy</a> process and Hannes has been
taking care of things. The current stage is the application process so we're
waiting to hear the outcome (due on 17th Nov).</p>
<p><strong>Charrua</strong> — There's a PR to <code>mirage-skeleton</code> to look at
(<a href="https://github.com/mirage/mirage-skeleton/pull/105">mirage/mirage-skeleton#105</a>), which should be tried out. Currently, it
doesn't seem to compile with OCaml 4.01 so should fix that and come back. Mort
will look in on this and report back in the next call.</p>
<h4>List of implemented protocols</h4>
<p>There was a suggestion to create a list of implemented protocols and their
status. This means manually making a list on the wiki-page. There was a
reminder that we also want to start using the Opam metadata tags to track the
MirageOS libraries in Opam — adding a <code>protocol</code> tag might help filter these.
Sometimes you need more data that you'd find in the opam metadata field so a
wiki-page is still useful.</p>
<p>The types of Opam tags were also discussed as we would use one to denote those
libraries that are maintained by MirageOS and others that offer certain
features that MirageOS can make use of.</p>
<h4>mirage-www deployment issues</h4>
<p><em>See discussion in <a href="https://github.com/mirage/mirage-www/issues/404">mirage/mirage-www#404</a></em></p>
<p>Recently there have been a few issues with the MirageOS website unikernel.
We've now put couple of fixes in scripts so they're run from outside the
<code>script</code> directory and things should start properly.  Also pushed a PR this
morning that will remove all the old bzip images as we don't need them.
Haven't yet updated the TravisCI scripts to remove the old scripts.</p>
<p>A suggestion that having an Opam repo hash would be useful (i.e. the state of
Opam repo at the time the unikernel was built).  That way we can reconstruct
anything with the just the hash and the config.ml</p>
<p>There were issues with <code>xvda</code> and <code>xvdb</code>, where it seems there was a mismatch
between assumptions in the various scripts. ThomasG can try to test things on
the live site today.</p>
<p>We also want to get <a href="http://blobs.openmirage.org">blobs.openmirage.org</a> running as a unikernel too,
probably using the <code>Crunch</code> file system.  However, this will need to have
something dynamically attached so will need to work on that.</p>
<h4>Unikernel logo contest</h4>
<p>Amir has started a <a href="http://99designs.co.uk/logo-design/contests/make-fun-logo-open-source-unikernel-projects-562612">Unikernel Logo contest</a> on 99designs. The intent is
to come up with a design that the community can use to promote unikernels.
The initial phase is to prepare a brief and then allow designers to submit
initial designs.  At some point, the process needs to involve more members of
the community so their views can also be incorporated (though we should be
wary of 'design by committee').  This process is likely to take several weeks
— it shouldn't be rushed as we intend to use the winning logo for some time.</p>
<p>At the moment, there are 211 logos to look through!</p>
<p>--</p>
<h4>AoB</h4>
<ul>
<li>
<p>Delayed notes: apologies that notes have not been on the website quickly
after the call.  Suggestion that perhaps we put them on a GitHub wiki and
build the website from there (using functoria).</p>
</li>
<li>
<p><code>nocrypto</code> on OpenBSD - DavidK has been working on this and needs feedback.
Things are broken on OpenBSD as versions of <code>gcc</code> etc seem to be different.
Anil can try this out and also suggested emailing OpenBSD ports. Once things
work, we can cut a release!</p>
</li>
<li>
<p>The next call is scheduled for <strong>Wednesday, 25th November</strong>. Please add any
<a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">agenda items</a> you wish to discuss in advance and refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2015-10-28 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2015-10-28|js};
        permalink = {js|weekly-2015-10-28|js};
        description =
          {js|28th October 2015: Logging, Pioneer Projects and Error Handling|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Quality and Test
</li>
<li>Logging
</li>
<li>Pioneer Projects
</li>
<li>Blog posts
</li>
<li>Error handling
</li>
</ul>
<p>Attendees:
Reynir Björnsson, Daniel Bunzli, Amir Chaudhry (chair), Justin Cormack,
Thomas Gazagnaire, Matt Gray, David Kaloper, Thomas Leonard,
Anil Madhavapeddy, Hannes Mehnert, Richard (mort) Mortier, Mindy Preston,
Gabriel (Drup) Radanne, Dave Scott, Magnus Skjegstad and Jeremy Yallop</p>
<h3>Notes</h3>
<h4>Quality and Test</h4>
<p>Some discussion about using CircleCI for automated builds.  There seems to be
a free option now so possibly worth exploring.  However, it doesn't appear to
show logs publicly the way TravisCI does (CircleCI requires login). Will put
this on hold until someone has time to look at it further.</p>
<h4>Logging</h4>
<p>ThomasL was wondering what the plans were regarding the new logging library.
Do we need support for <code>lwt</code> in the logging library? It's intended to be a
logging lib for OCaml.</p>
<p>Drup looked at the API and asked Daniel. The logging function is returning a
string at the moment. Messages could be out of order if scheduler doesn't keep
up (there's an open issue about this). ThomasL pointed out that ordering
things is solvable but he's more worried about running out of memory. We want
to separate logging from the reporting.</p>
<p>Discussion diverged into one of collecting logs and also of where/how to push
them.  We should keep these discussions focused as both aspects are important.</p>
<!-- Irmin is using dolog? -->
<p>Is there a plan of how to put part of this into mirage? Someone should use the
lib (dolog?) and write a reporter for Mirage. Right now there's reporter for
the console.  ThomasL will look at this and will check back in a couple of
weeks.</p>
<h4>Pioneer Projects</h4>
<p>Outreachy is ongoing and we may be able to request funds for a third
participant. Will have to see how this phase goes. Hannes is signed up as a
mentor on the Outreachy website but not sure what the next step is. The
participant is willing to implement NTP as the project. Mindy would like to
use it to get the rhythm for dom0 in the TCP/IP stack. Anyone on ARM will be
particularly keen to have this too, as they don't have a clock.</p>
<p>Mort is supervising a number of undergrad projects that relate to MirageOS.
Loosely, the areas are:</p>
<ul>
<li>The work that Mindy did for ARP can be done for TCP.
</li>
<li>Cosmin Boaca is getting started with multi-process/vm ocaml-ctypes.
</li>
<li>Some work with docs over Irmin.
</li>
<li>Collection of IoT type data (bus locations every 30s).
</li>
<li>Tweaking the TCP stack to make it look like it's a Windows stack.
</li>
</ul>
<p>We can check how these are going in due course.</p>
<h4>Blog posts</h4>
<p>A blog post on Charrua is in a PR to <code>mirage-www</code>.  At the moment the code
doesn't compile with 4.01 so will fix that and then come back.  Mort will
check the PR but will also need some other people to try out the instructions.</p>
<h4>Error handling</h4>
<p>This has been discussed before but we still need to make a decision. Now that
we have a <code>`Result</code> in the standard library we can just use that. There's
also a <code>Result</code> lib we can use.</p>
<p>Some questions about the benefits of using <code>Result</code> over polymorphic variants.
Should help us get sensible errors and easily turn them into strings to report
them (rather than having abstract types). We just need to make sure we choose
something consistent.</p>
<p>--</p>
<h4>AoB</h4>
<ul>
<li>
<p><code>nocrypto</code> — Turns out that it's non-trivial to fix the openBSD issue. The
release has been blocked on that. DavidK had to refactor c-include and other
pieces and hasn't had time yet (will ask again on the next call).</p>
</li>
<li>
<p>MattG, working on Clock things, wanted to know whether he should wait for
functoria to be released. Others mentioned that he should be able to use
functoria now as it's in <code>mirage-dev</code>. There's also a
<a href="https://github.com/mirage/mirage-www/pull/396">draft blog post</a> which should help him get started.</p>
</li>
<li>
<p>Seems that Jitsi is not as slick to use as Google Hangout. After some minor
initial hiccups it worked in the end.  Seems there are some issues with
networking (UDP, VLAN, etc) for people on certain networks.</p>
</li>
<li>
<p>The next call is scheduled for <strong>Wednesday, 11th November</strong>. Please add any
<a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">agenda items</a> you wish to discuss in advance and refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2015-10-14 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2015-10-14|js};
        permalink = {js|weekly-2015-10-14|js};
        description =
          {js|14th October 2015: Functoria, Irmin roadmap and upcoming blog posts|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Functoria
</li>
<li>Irmin roadmap
</li>
<li>Pioneer Projects
</li>
<li>Blog posts and videos
</li>
</ul>
<!-- - OPAM cross-compilation discussion -->
<p>Attendees:
Daniel Bunzli, Amir Chaudhry (chair), Justin Cormack, Thomas Gazagnaire,
David Kaloper, Thomas Leonard, Anil Madhavapeddy, Hannes Mehnert,
Richard Mortier, Mindy Preston, Dave Scott, Magnus Skjegstad and Jeremy Yallop</p>
<h3>Notes</h3>
<h4>Quality and Test</h4>
<p>Anil is trying to do more automated builds around <code>mirage</code> and using
CISO to build on pushes.  Hopefully can retire 'is-mirage-broken' when this is
done.  Currently working on this and hooking up the contiainer builds but they
run out of disk space. Trying to use <code>dog</code> to catch the logs and trying to
have a branch per package and version. At the moment there are a few thousand
contains unsuccessfully pushing to <code>dog</code>. Can hopefully use Thomas' package.</p>
<p>Some brief discussion about UI and a note that there should be something on
ThomasL's GitHub account.</p>
<h4>Functoria</h4>
<p><em>See release tracking in <a href="https://github.com/mirage/mirage/issues/447">mirage/mirage#447</a></em></p>
<p>ThomasG is refactoring the code to make it easier to understand. Also trying
to read the <code>.mli</code> file(s) and explaining why it's not in <code>mirage</code> anymore
(takes some effort to do this). <code>mirage</code> has two stages — compile and
run — and the user/developer typically wants control of when things happen.
There is building the <code>mirage</code> tool (which is an app itself) and your final
application — you want to build using functors, so you want a DSL.</p>
<p>ThomasG has some nice <code>.mli</code> files and will ask for review, probably by the
end of the week. One part is also an extension of <code>cmdliner</code>. Maybe talking to
someone with more experience of meta programming would be useful.</p>
<p>Not sure of ETA of Functoria yet. Every time there is some refactoring we have
to check that things compile and also have to check generated code, which
takes time.</p>
<h4>Irmin progress</h4>
<p>We should make a release of Irmin soon.</p>
<p>ThomasL has been making some changes, which may have broken code and things
are more git-like now. The API is a bit more verbose and bit more explicit.
If someone is making a back-end it should be a lot simpler and they can share
resources a lot more easily. There are enough useful things in <code>master</code> that
it's worth cutting a release. ThomasG likes how things are going, still
perhaps possible to make a few frequent use-cases a bit easier. No strong
opinions as to how though.</p>
<p>Regarding the refactoring work, chunking is now finished and encryption is
compiling but not passing tests/review. That component isn't ready for release
yet but if someone wants to look over it, that would be cool.</p>
<!-- Maybe encrypt the logs using dog (for science!).  -->
<p>Worth noting that <code>dog</code> might not work with new APIs.  The IMAP server that
Greg worked on might also need updating. ThomasL/ThomasG will follow up with
him separately.  There's also a new version of Jitsu coming soon.</p>
<!-- functor that takes a functor and returns a functor... ? -->
<p>Other pieces:</p>
<ul>
<li>
<p>Xen: Patches are there but probably need fixing now. There's likely a branch
in <code>mirage-dev</code>.</p>
</li>
<li>
<p>GC: Not much progress on this yet. Will need to change types as part of this
works and at the moment, we pass around IDs. Some discussion over how to do
this.</p>
</li>
<li>
<p>Memory issues: Jeremy looked at the memory usage issues too. Found a number
of culprits and fixed them but the remaining ones lead to a trade off between
memory usage and execution time. For example, we can reduce memory usage by
70% but that increases execution time by 2x. Caching seems to be the culprit
and we'll have to look at this further.</p>
</li>
</ul>
<h4>Pioneer Projects</h4>
<p>We have a candidate for Outreachy who is working with Hannes who submitted a
small patch (we note that this also survived a code review by Daniel Bünzli).
Mort has had one other enquiry.  The Outreachy process is ongoing.</p>
<h4>Blog posts</h4>
<p>We've been releasing things as usual but haven't had any blog posts for a
while. There are a few things that it would be worth writing up posts about.</p>
<ul>
<li>
<p>Summary of the recent talks that have taken place (Amir has a draft). Any
videos can be added to the <a href="https://mirage.io/wiki/talks">Videos</a> page of the website (which could do with
a refresh).</p>
</li>
<li>
<p>Introduction to the new DHCP server, <a href="https://github.com/haesbaert/charrua-core">Charrua</a>, which was a result of a
recent Pioneer Project. Christiano said he'd like to write one but the work is
not finished, yet. Might take another month to polish up. We should ask again
in a month.</p>
</li>
</ul>
<!-- #### OPAM cross-compilations ####
A headsup that this discussion has taken place on the opam-devel list and the
issue tracker. If you're interested, following along on those sources.
-->
<p>--</p>
<h4>AoB</h4>
<ul>
<li>
<p><code>nocrypto</code> work. Didn't get around to this but found out that it doesn't
compile with opam 1.1.1 (which is in Ubuntu) due to some variable in the OPAM
file. Must work with opam 1.2.0 or above.</p>
</li>
<li>
<p><code>codoc</code> status: We should check on this at the next meeting as it will be
needed for Irmin.</p>
</li>
<li>
<p>Boot logos for MirageOS! Some discussion on the list about boot logos. Would
be good if we had a library to turn a string into ASCII art. We could make
this a Pioneer Project but after some discussion, it seems DavidK already has
such a library, <a href="https://github.com/pqwy/notty">Notty</a>.</p>
</li>
<li>
<p>Logging: Factoring things out into a library would be good. Getting <code>vchan</code>
integrated and working correctly (dom0/domU) is important and then we can have
a better way to manage logs. Should add this to the agenda for next time.</p>
</li>
<li>
<p>The next call is scheduled for <strong>Wednesday, 28th October</strong>. Please add any
<a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">agenda items</a> you wish to discuss in advance and refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2015-09-30 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2015-09-30|js};
        permalink = {js|weekly-2015-09-30|js};
        description =
          {js|30th September 2015: Functoria, Irmin plans, numbering and Pioneers|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Functoria
</li>
<li>Irmin roadmap
</li>
<li>Version numbering
</li>
<li>Pioneer Projects
</li>
</ul>
<p>Attendees:
Reynir Björnsson, Daniel Bünzli, Amir Chaudhry (chair), Justin Cormack,
Thomas Gazagnaire, David Kaloper, Thomas Leonard, Anil Madhavapeddy,
Mindy Preston, Dave Scott, Magnus Skjegstad, Guybrush Threepwood and
Jim Tittlser</p>
<h3>Notes</h3>
<h4>Functoria</h4>
<p><em>See <a href="https://github.com/mirage/mirage/pull/441">mirage/mirage#441</a></em></p>
<p>There's been work towards a new EDSL that's captured in a library called
Functoria.  We discussed this last time and it needed rebasing due to an
earlier <code>.xl</code> patch being merged.</p>
<p>Things have been cleaned up with the patch but it seems there have been some
issues with Travis, which someone needs to take a closer look at.  Someone
also needs to review and test the patch (Anil will do this, feedback from
others also welcome). The examples should also be checked over.</p>
<p>One thing we know is still missing as there's an opportunity to retain the
shorthand flags we have for <code>--xen</code> and <code>--unix</code> as part of the configure step.
ThomasG's not had a chance to look at that yet but would be great to keep them
if we can.  There's also been some work on related tools we use (cmdliner), to
add support for environment variables (<a href="https://github.com/dbuenzli/cmdliner/commit/e82fd02842719167c3a04fc7ed0edf9a8036203c">dbuenzli/cmdliner@e82fd02</a>).</p>
<p>Aside from the code review, there's already a draft blog post prepared (Amir
will review), as well as a note for the <a href="https://mirage.io/wiki/breaking-changes">breaking changes</a> page of
the website (a few things may change for some people).</p>
<p>Getting the IPV6 support in was also blocked on the configuration step too.
Once we've completed the releases around Functoria, we can work on getting an
IPV6 site up!</p>
<h4>Irmin roadmap</h4>
<p>There are a number of things we can be doing with Irmin so there's a question
of how we decide what exactly what we should work on next. It seems people
have lists of things they'd like to get done but pulling these into a clearer
plan would be helpful.</p>
<p>ThomasL can compile Irmin to Javascript and then call it from Javascript.
It's a bit ugly but can be done and talks more about 'repos' and 'branches'
rather than 'stores'.  This might be something to make more consistent within
Irmin.  Would also like to get rid of <code>create</code> and clean up the webserver.
Built an <a href="https://github.com/talex5/irmin-www">Irmin-based webserver</a> but is currently missing the
ability to 'push to the server' and 'pull from the server'.
You can see the Irmin JS bindings at <a href="https://github.com/talex5/irmin-js">talex5/irmin-js</a>.
ThomasL is still new to Javascript so would be very happy to hear from anyone
who can show him a better syntax for the examples. There's an attempt at:
<a href="https://github.com/talex5/irmin-js/blob/master/examples/tests.js">https://github.com/talex5/irmin-js/blob/master/examples/tests.js</a></p>
<p>ThomasG is currently focused on upstreaming patches from work that Mounir did
earlier this year (chunking and encryption).  This is going well and involves
some minimal changes to the API.  The main change is a new link store (where
you can store links between keys).</p>
<p>There are also improvements to be made on the REST API — which kind of isn't
at the moment! It would be great if someone would be able to take look at that.
For now, the only users of this are the Go bindings.  Given this, perhaps we
can look at other REST implementations, then (re)write the bindings with the
API we'd like and then modify Irmin.</p>
<p>ThomasL also noticed a lot of memory usage while working with <code>ocaml-git</code> and
wondered what might be going on.  Amir mentioned that we'd seen this before
during work on 'cosmetrics' and Christophe filed issues with test cases (e.g.
<a href="https://github.com/mirage/irmin/issues/263">mirage/irmin#263</a> and <a href="https://github.com/mirage/ocaml-git/issues/125">mirage/ocaml-git#125</a>). Any assistance with these
would be appreciated!</p>
<p>Although all the above are useful things to work on, the most important thing
to solve is the garbage collection, because it hasn't been worked on yet. At
the moment it's enough to shell out to <code>git gc</code> but we need to take care about
locking and following the Git model properly.</p>
<p>In the short term, ThomasG is making a 0.9.10 release now with some changes
and is happy to let ThomasL improve the API beyond that.  The next release
will have no 1st class modules so a few things will break, including <a href="https://github.com/mirage/jitsu">Jitsu</a>.
ThomasG will talk to people affected by such changes and support any
transitions (this a good reason to add relevant projects to the
<a href="https://github.com/mirage/irmin/blob/master/README.md#use-cases">list of Irmin users</a>. ThomasG then knows who's stuff he might be
breaking ☺ )</p>
<h4>Version numbering</h4>
<p>After the last call, we started a discussion on aspects of release numbering
(see the <a href="http://lists.xenproject.org/archives/html/mirageos-devel/2015-09/msg00021.html">thread</a>). It seems this is a difficult problem to discuss by
email as we can't try to solve the general problem.</p>
<p>This discussion came about as we will soon release functoria and a new <code>mirage</code>
tool which will introduce a few incompatible changes. Hence we also thought
about how we bump version numbers of certain libraries.</p>
<p>Related to this is the question of what it means to have a 'version' of
MirageOS, which occasionally crops up. This is complicated by the fact that
were talking about a <a href="https://en.wikipedia.org/wiki/Unikernel">library OS</a> and the libraries necessarily have
their own versions — and people can pick and choose what they need for their
own purposes.  It may be stating the obvious but MirageOS is more than the
<code>mirage</code> tool itself, even though this is what people may interact with the
most (e.g. it's natural to think of trying <code>mirage --version</code> to find out what
you have installed). Having said this, when we've released a collection of new
things with new functionality we still label them as '<a href="https://mirage.io/blog/announcing-mirage10">MirageOS v1.0</a>',
'<a href="https://mirage.io/blog/announcing-mirage-20-release">MirageOS v2.0</a>' and '<a href="https://mirage.io/blog/announcing-mirage-25-release">MirageOS v2.5</a>' in news announcements and
this (broadly) maps to the version of the <code>mirage</code> tool at the time.</p>
<p>Daniel pointed out that we can think of this in two aspects.  The first aspect
is the API that developers will program against and the second is the tooling
around the API.  When the the tooling changes, then although some things are
affected, it's limited to those parts that make use of that tooling.  In this
case, the effects on the <code>config.ml</code> files is something that affects the
tooling, so isn't a 'major' change.  A change in the API would have a wider
impact.</p>
<p>This also led to some discussion about how we think of API versions and even
whether we should be having one opam package per module type. We still need to
think more about these things though.</p>
<p>In the meantime, one suggestion was to adjust the output of <code>mirage --version</code>
so that it produces more information about what's installed (perhaps something
similar to <code>opam config report</code>).  That would be useful to manage the
expectations between the <code>mirage</code> tool itself and what we talk about in news
announcements. Whatever changes we make need to be thought about, since this
output should be readable programatically.</p>
<p>In any case, we should take care to continue to communicate
<a href="https://mirage.io/wiki/breaking-changes">breaking changes</a> clearly as well as putting out
<a href="https://mirage.io/releases/">release notes</a>.</p>
<!--
Since we were discussing numbering, Amir was really hoping to insert a joke
about off-by-one errors — but that didn't happen. So he left this HTML comment
here as lamentation :-P
-->
<h4>Pioneer Projects</h4>
<p>MirageOS is taking part in <a href="https://wiki.gnome.org/Outreachy/2015/DecemberMarch#Participating_Organizations">Outreachy</a> this year, via Xen Project.  A number
of people have already been in touch (which is great!) and we've reviewed our
<a href="https://github.com/mirage/mirage-www/wiki/Pioneer-Projects">project list</a> already.  If anyone is interested in a project, please
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">email the list</a> and let us know!</p>
<p>--</p>
<h4>AoB</h4>
<ul>
<li>
<p>Anil is trying to do more automated builds around mirage/mirage and using
CISO to build on pushes.  Hopefully can retire is-mirage-broken when this is
done.</p>
</li>
<li>
<p>Dave has been working on the <code>xl</code> files stuff and has a small roadmap
(<a href="https://github.com/mirage/mirage/issues/443">mirage/mirage#443</a>) with a few issues in it.  Will go through this in the
background over time and slowly improve the deployment steps.</p>
</li>
<li>
<p>The OpenBSD port is nearly complete but it needs a release of <code>nocrypto</code> to
be able to finish it off. DavidK will look at this and release when ready.</p>
</li>
<li>
<p>The next call is scheduled for <strong>Wednesday, 14th October</strong>. Please add any
<a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">agenda items</a> you wish to discuss in advance and refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2015-09-09 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2015-09-09|js};
        permalink = {js|weekly-2015-09-09|js};
        description =
          {js|9th September 2015: Xen file generation, functoria and end-to-end systems|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Outstanding patches
<ul>
<li>xl generation
</li>
<li>Functoria
</li>
</ul>
</li>
<li>Docs for an end-to-end system
</li>
</ul>
<p>Attendees:
Amir Chaudhry (chair), Thomas Gazagnaire, Thomas Leonard, Hannes Mehnert,
Richard Mortier, Gabriel Radanne and Dave Scott</p>
<h3>Notes</h3>
<h4>Outstanding patches</h4>
<p><strong>xl files</strong> — Last time, a patch was mentioned about better <code>.xl</code> files.
There was some discussion on the PR (<a href="https://github.com/mirage/mirage/pull/440">mirage/mirage#440</a>), and this has now
been merged. There are still things to do as the deployment scripts will need
updating.  The plan is to update the skeleton file for the unikernel rather
than the generic one. Some discussion that it might be useful to think about a
more generic skeleton framework for deployment — like the one we ended up with
for TravisCI.  Dave will think about this but part of the process is to find
out where the abstractions should be made.  A separate comment was that the
logic for Xen file generation might be better placed in a standalone library
related to the point below).</p>
<p><strong>functoria</strong> — See <a href="https://github.com/mirage/mirage/pull/441">mirage/mirage#441</a>. The work on this is close to being
ready but unfortunately the above xl patch meant that a lot of messy work is
required before the functoria patch is ready to merge again (as it changes a
lot of things internally to the mirage tool).  Things are looking a lot tidier
already though.</p>
<p>The goal is to integrate this fairly soon and the next release of the <code>mirage</code>
command line tool will incorporate it.  There are a three pull requests to
merge before this one and perhaps a fourth one too. Note that the whole engine
is in functoria so the mirage tool will have a new dependency.</p>
<p>In terms of impact on users, it's largely the same as before. There may be
changes to how things work with TLS and there will be much better ways to do
certain things. It's not really a huge, breaking change as most existing
<code>config.ml</code> files will work (although a few will need tweaking). Should be
ready to look at for merge before the next call. Gabriel will work on some new
examples that will help explain the differences, as well as a blog post.
Should also add a note to the <a href="https://mirage.io/wiki/breaking-changes">breaking changes</a> page for anything
that does need updating (as well as emailing the list).</p>
<h4>Describing an end-to-end system</h4>
<p>We have a reasonably good toolchain that gets us from code push to deployable
unikernel but one of the less clear pieces is how to set up and deploy to a
Xen machine.  We do have the current deployment scripts Mort put together but
there's room for further simplification (Thomas also did some work to make
them more parameterised).  One way to think about this is to aim for a short
post (&lt;1000 words) that describes the three stages of local build, CI and
deployment.  Keeping it this short means we need to have enough automated
infrastructure to point people at. As an example, we've already achieved this
with the Travis skeleton scripts.</p>
<p>Ultimately, we agree that deploying to EC2 is important but a good first step
would be to document (and to some extent, automate) our deployment on the
current Bytemark machines. Dave has been looking at these machines anyway and
it's a manual process to set things up appropriately.  It would be great to
improve what we have and there have been new RPMs for Xen released recently
that can help with this.</p>
<p>--</p>
<h4>AoB</h4>
<ul>
<li>
<p>Release numbering. Related to the functoria patch, we should consider our
release numbering and how things are related to each other. For example, the
<code>mirage</code> tool has a version number (and we use <code>V1</code> in the APIs), functoria
will be versioned, and the major MirageOS announcements also use numbers.</p>
</li>
<li>
<p>Question about work on DHCP servers but folks aren't around to answer.</p>
</li>
<li>
<p>The next call is scheduled for <strong>Wednesday, 23rd September</strong>,
but it looks like we may need to shift the date. Please add any
<a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">agenda items</a> you wish to discuss in advance and refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2015-08-26 16:00|js};
        author =
          {
            name = {js|Richard Mortier|js};
            uri = Some {js|http://mort.io/|js};
            email = Some {js|mort@cantab.net|js};
          };
        subject = {js|Weekly Meeting: 2015-08-26|js};
        permalink = {js|weekly-2015-08-26|js};
        description =
          {js|26th August 2015: QA, Rust progress, Irmin API changes and minutes of previous calls|js};
        body =
          {js|<ul>
<li>Quality and Test
</li>
<li>Rust progress
</li>
<li>Irmin API changes
</li>
<li>Minutes of previous calls
</li>
</ul>
<h2>Attendees</h2>
<p>Daniel Buenzli, Amir Chaudhry, Thomas (samoht) Gazagnaire, Thomas Leonard, Jon
Ludlam, Anil Madhavapeddy, Hannes Mehnert, Richard (mort) Mortier (secretary),
Mindy Preston, Dave Scott, Magnus Skejgstad</p>
<h2>Notes</h2>
<h3>QA &amp; Test</h3>
<p>Work has proceeded on <code>ciso</code>, a distributed test infrastructure using Irmin as
the coordination layer. Operates somewhat like XenStore: you can register
watches, schedule &quot;tasks&quot; (comprising &quot;jobs&quot;) that are submitted by writing into
the store for workers who're registered via watches. Observe store to see entire
status of system: jobs, workers, etc. First large-scale Irmin application. Irmin
means you can inspect the entire state but also means that a mistake can nuke
your entire repo (though only once). This is essentially the Grand Unified Merge
of all of @samoht's projects over the years.</p>
<p>Discussion about deployments. @anil suggests running two deployments, for Mirage
and OPAM respectively. Some disucssion whether Citrix want to use it for XAPI.
Consensus from @dave/@jon was &quot;maybe&quot;. Similar discussion for Jane Street
leading to question whether XenStore pieces can be pulled out separately.
@samoht felt he could abstract the three schedulers (task, job, worker). @anil
will try to deploy towards end of this week.</p>
<p>@anil: on QA, have done lots of upstreaming, refreshed all packages on the
planet to everywhere. ~60 patches going into OpenBSD to allow <code>tlstunnel</code> to be
shipped. FreeBSD now fixed so works out of the box. ArchLinux still broken. But
generally we're in good shape to start getting command line tools in place to
get the libraries out there, then go for the Full Mirage Experience.</p>
<p>Discussion about ongoing <code>blockdev</code> naming, <code>.xl</code> generation etc. @dave felt PR
ok but Travis was having some problems. He'll take lead on merging. (<em>ed: and
this is now done I think.</em>)</p>
<p>Some discussion of grim @mort patch to get environment variable parsing into the
<code>mirage</code> CLI tool. Agreement it was indeed grim and @samoht would not merge :)
Discussion of what might need to be in <code>cmdliner</code> to parse environment
variables. @daniel indicated something is coming to fix all that: features to
compose environment variables with command-line flags, with the flag taking
precedence in creating the <code>Term</code>, with auto-documentation etc. On the issue
tracker as #23, should be complete in the next few days.</p>
<h3>Rust Support</h3>
<p>Unfortunately, no-one very active on Rust support could make it.</p>
<p>@thomas: More generally, Mini-OS patch upstreaming is on-going but Ian Campbell
is on holiday at present. When he's back the last patch is expected to go in.
This is going to break the <code>qdom</code> scripts but no-one wants to look at it. @anil
feels these may get nuked soon anyway.</p>
<p>@thomas is going to add some <code>figlet</code> (perhaps) ASCII art (and kill some of the
debug spew) to bootup to make everything friendlier.</p>
<h3>Irmin API Changes</h3>
<p>@samoht had &quot;nothing to say&quot; apart from begging for more time! :)</p>
<p>@thomas questions about concurrent connections and resulting API confusions.
@samoht says current API intended to make it easy to track which objects are
live, with the aim of hiding concurrency but at the cost of perhaps not always
being the correct thing to do.</p>
<p>Discussion about this issue and the way its supported for the indexdb backend,
and its ability to do atomic transactions in browser, while the POSIX file-based
backend can't.</p>
<p>Summary is that the issues arise due to invariants that the JS backend doesn't
maintain. Workarounds will be incoming as PRs; the first (#268) will be merged.</p>
<h3>Previous Minutes</h3>
<p>@thomas noted missing minutes from the index page. @amir explained this was due
to two issues: updates not being pushed, and the process for updating the index
being manual and not always being done.</p>
<p>(<em>ed: I note that three updates seem to be required-- adding the notes
themselves under <code>/tmpl/wiki/weekly/</code>, adding a reference in <code>src/data.ml</code>, and
adding a link to <code>/tmpl/wiki/index.md</code>.</em>)</p>
<h3>Jitsu on Monk</h3>
<p>@anil wanted to know about homepages being served by Jitsu and how often things
were being woken up by crawlers etc. @magnus noted that his demo pages sleep
most of the time. @anil asked if we can put Jitsu and unikernels on <code>monk</code>.
@dave felt not quite due to a Xen booting issue with CentOS7 (now installed). He
will tag a particularly good version of the XAPI code for us to use. @anil then
noted the main missing piece is Apache style logging from CoHTTP and Irmin which
requires Irmin/Xen to be merged. @samoht still has patches queued. @mindy noted
that the Irmin/ARP demo uses the Unix backend but can run in memory on Xen, and
@samoht that <code>git push</code> to a <code>git repo</code> doesn't work but <code>irmin push</code> is fine.
There was then some general realisation that we can simply have websites <code>irmin push</code> logs to an Irmin server running on Unix listening for log collection.</p>
<p>Revisiting the first point, @mort asked @anil about processing his decades of
website logs to (effectively) explore multiplexing factors of unikernel
(websites at least). @anil said he will look into this.</p>
<h3>AoB</h3>
<p>None specified at this time.</p>
|js};
      };
      {
        updated = {js|2015-07-01 16:00|js};
        author =
          {
            name = {js|Anil Madhavapeddy|js};
            uri = Some {js|http://anil.recoil.org|js};
            email = Some {js|anil@recoil.org|js};
          };
        subject = {js|Weekly Meeting: 2015-07-01|js};
        permalink = {js|weekly-2015-07-01|js};
        description =
          {js|1st July 2015: Network stack testing and Mirage 2.5 release|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Networking stack
</li>
<li>Mirage 2.5 release recap
</li>
<li>AoB (live stats, Irmin/Xen)
</li>
</ul>
<p>Attendees: Anil Madhavapeddy (chair), Hannes Mehnert, David Kaloper, Thomas
Leonard, Jeremy Yallop, Magnus Skjegstad, David Sheets, Justin Cormack, Mindy
Preston, Richard Mortier, Thomas Gazagnaire.</p>
<h3>Notes</h3>
<h4>Networking stack</h4>
<p>There were various issues around duplicate acks and TCP retransmission
which were exposed due to the TLS stack integration.  Many of these were
just regressions or lurking issues due to Lwt mvars, and are now fixed.</p>
<p>To stop them from coming back, we now have tests that run per PR within
Travis.  This uses vnetif to create virtual interfaces that directly short
circuit the need for a real <code>tuntap</code> device, and so happily work great inside a
container.  Coverage is patchy at the moment but is steadily improving (see
<a href="https://github.com/mirage/mirage-tcpip/issues/160">mirage/mirage-tcpip#160</a>
for coverage instructions).</p>
<p>ThomasG/L have put in <a href="https://github.com/mirage/mirage-tcpip/pull/152">debug logging</a>
so we now have full trace viewer capability.  When ThomasL looked at it, every connection ends with
an exception being thrown, that noone had noticed before!  (The stack resolved
a thread in RST processing and then looped again).  That issue is now fixed,
but everyone is encouraged to use the browser profiler and find other lurking
issues.</p>
<p>Hannes has a TCP/IP test harness and will generate traces based on Peter
Sewells <a href="http://www.cl.cam.ac.uk/~pes20/Netsem/">Netsem</a>. This has not been
used much since 2005, but is being modernised for testing against Mirage
TCP/IP.</p>
<p>Magnus and Mindy have written some iperf tests using the virtual vnetif
interface.  Travis is timing out all the time due to very variable performance
within their infrastructure, so its hard to figure out how much to test.  Anil
suggested that we run them from cron against a repo like
<a href="https://github.com/mirage/is-mirage-broken">mirage/is-mirage-broken</a>.</p>
<p>The next feature that we are aiming for is to get IPv6 working with the stack.
Nicolas Ojeda Bar has implemented everything needed, but the only thing
blocking it is the configuration interface (which should be the easiest bit).
Hannes, Justin and many others are keen on this...</p>
<p>#### Mirage 2.5 release</p>
<p>This was a very complex release due to the growing number of libraries that
we have in the project.  It all went well this time, but Anil suggested recapping
what went right and wrong in the release this time.  A poll around the team revealed:</p>
<ul>
<li>
<p>The blog posts were very close to the actual libraries releases, and it was
hard to predict when something would work without a beta cycle.  Made schedulig
the posts challenging.</p>
</li>
<li>
<p>We do not explicitly document API breakage for end users as we go along, and
so it had to be pieced together from the changelog.  This is getting more painful
for users as we grow in size and have more production infrastruture.</p>
</li>
<li>
<p>Do not release on a Friday afternoon and then go to the pub (or in the case of
ThomasG, a wedding)</p>
</li>
<li>
<p>The library changes are still happening in big chunks. This is partly due to the
fact that some of the core Channel APIs were revved.  We are getting better at
testing reverse dependencies, but this still needs some infrastructural help
from OPAM to do bulk builds after a large set of releases.</p>
</li>
<li>
<p>The use of a <a href="https://github.com/mirage/mirage-dev">mirage-dev</a> remote <em>generally</em>
worked successfully.  Unfortunately, remotes in OPAM are global and not per-switch,
and Anil pointed out that it would be nice to have some switches that were pristine
upstream.  This is possible when using just <code>opam pin</code>, but not with a remote.</p>
</li>
</ul>
<p><em>ThomasG:</em> Mirage is a set of libraries that work together and a frontend tool that glues
them together.  Its fine to release libraries as a batch since we have OPAM, but what we
didnt manage well is evolving the API of the Mirage DSL itself which glues it all together
(Anil: this is referring to the <code>config.ml</code> API).
<em>Mort:</em> the Mirage DSL eis an implicit collation of a bunch of library versions and it is
hard to track since its not captured in OPAM.
<em>ThomasG:</em> we can fix this by adding conflicts in the OPAM metadata.</p>
<p><em>ThomasL:</em> a number of Mirage packages have gone upstream into the OPAM package
repository and their unit tests fails. More testing on OPAM import is needed to
prevent dependent packages from breaking their unit tests due to an import of a
dependency.  <em>DavidS:</em> we only test the package version we are importing and so
we only test for one solution. Further changes will break upstream. We dont do
reverse dependencies for OPAM dependency tests.
<em>Anil</em>: The OPAM maintainers (several of whom are on this call) are aware of the
issue and are working on improving testing reverse dependencies on new package import.</p>
<p><em>Mort/DavidS</em>: the Mirage libraries should use the <a href="https://github.com/ocaml/ocaml-travisci-skeleton">ocaml-travis-ci-skeleton</a> so that they take advantage of the improvements in reverse depenedency testing.
<em>Mort</em>: we need to figure out how to get around the Travis 50 minute limit.</p>
<h4>Any Other Business</h4>
<p><strong>Irmin/Xen</strong> is at the pull request stage, and is green! ThomasG will do some more testing,
but is confident that we can merge it in now that the Xen/TLS changes are all in.
It is still memory-only, so we will need to put together a block device store for
persistence (perhaps using <a href="https://github.com/Incubaid/baardskeerder">baardskeerder</a>
or LevelDB.</p>
<p><strong>Log files</strong>: David Sheets and Jeremy Yallop have a design for a logging library that
they are planning to write up soon.  This needs to be coalesced with the recent logging
work in the TCP/IP stack.  One of the backends could be Irmin/Xen, but optional of course.
Hannes notes that the Bitcoin pinata uses a different logging system with a dom0 proxy,
which works fine if you control the Xen host (not the case with EC2).</p>
<p><strong>Live stats</strong>: are <a href="https://mirage.io/stats/gc">now working</a> on the mirage-www website
thanks to Dave Scott and are very fancy!  Anil encourages everyone to not put functionality
directly into the mirage-www repo, but to create a small library with it instead.</p>
|js};
      };
      {
        updated = {js|2015-06-03 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2015-06-03|js};
        permalink = {js|weekly-2015-06-03|js};
        description =
          {js|3rd Jun 2015: TLS releases, TCP bug-squishing and best-practice docs|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Quality and Test
</li>
<li>TLS release status
</li>
<li>TCP debugging, profiling and stats
</li>
<li>Documentation best practice
</li>
</ul>
<p>Attendees: Amir Chaudhry (chair), Matthew Gray, David Kaloper, Masoud Koleini,
Thomas Leonard, Len Maxwell, Hannes Mehnert, Richard Mortier, Dave Scott,
Magnus Skjegstad and Mindy Preston</p>
<h3>Notes</h3>
<h4>Quality and Test</h4>
<p><strong>mirge-skeleton</strong> — A few people have commented on the list that
<a href="https://github.com/mirage/mirage-skeleton">mirage-skeleton</a> has been broken for them.  In addition, there's
occasionally confusion about what they should or could do with the content of
the repo. Whether what they see there is considered 'best practice', just
happens to be there for testing or are snippets for people to use elsewhere.</p>
<p>We believe some of these issues have been fixed via the list but it's worth
highlighting when/why this happens.  It seems we've set up the <code>master</code> branch
of mirage-skeleton to work when using the <a href="https://github.com/mirage/mirage-dev">mirage-dev</a> remote (an
<a href="https://opam.ocaml.org/doc/Usage.html#opamrepo">opam repository</a> where we stage our releases and work in progress).
That means the examples are currently meant to be working with the upcoming
releases rather than the packages available in the official repository.
Anyone who doesn't expect this is liable to see breakages and probably be
confused as to why.</p>
<p>One approach to mitigate this would be to maintain two branches, <code>master</code> and
<code>mirage-dev</code>, which would track with the packages in the main opam repo and
mirage-dev repo, respectively.  This would add a step to the release process,
which would involve merging relevant changes from one branch to the other
Another approach was suggested, which involves clarifying what it means to
have a 'version' of MirageOS (a particular set of libraries).</p>
<p>Regarding the question of what mirage-skeleton is for, we suggested that
adding some more information to the repo's README would be helpful.</p>
<p>It was proposed that we continue this discussion either on the mailing list or
on an issue on the mirage-skeleton repository.  That would allow anyone else
to get involved and comment before we make any firm decisions.</p>
<h4>TLS release planning</h4>
<p>We're gearing up to a release of MirageOS v2.5, which includes support for TLS.
While working on this, we uncovered some bugs elsewhere in the stack (TCP) and
have been working to resolve them (now being tracked in
<a href="https://github.com/mirage/mirage/issues/409">mirage/mirage#409</a>).</p>
<p>We originally had a fixed date for the news release — to go with the software
release — but because of the remaining issues, we're not comfortable making
announcements until we're sure the code-base is ready. To relieve some of time
pressure and assure a high-quality release, we decided to decouple the
different elements as much as possible. Practically speaking, this means we
will first get the issues resolved (releasing libraries as usual), then get
associated blog posts written, and finally have a news announcement (there's
more info in Amir's <a href="https://github.com/mirage/mirage/issues/409#issuecomment-108438612">comment on #409</a>).</p>
<p>A point was raised that we should try and avoid this occurring again, whether
that means more testing, or a different process.  We asked one of the people
present on the call (who shall remain nameless), how his very large and well
established company handles things to avoids such release issues ... after a
brief pause, the response was &quot;No comment!&quot;.  So it seems we're no worse than
elsewhere but it would be nice to be better.</p>
<h4>TCP debugging, profiling and stats</h4>
<p>Lots of people have been trying to debug the TCP stack. ThomasG put together a
stats branch with extra debug output, which was very useful.  However, it
slows things down enough that it hides one of the race conditions that ThomasL
had uncovered — ThomasL has as issue with TLS on the Cubieboard where it
doesn't serve a file.</p>
<p>ThomasL has continued to make improvements to debugging tools and Mindy was
very happy about that!  These tools will go into the Lwt tracing branch.</p>
<p>It was suggested that one of the effort towards a 3.0 should be improvement of
the developer tools around MirageOS, including tracing. This is already one of
the elements we've been thinking of while discussing logging but it's worth
calling out explicitly.  It seems our approach is already a few steps ahead of
what other systems provide so it's worth drawing attention to.  Our friend in
the BigCo did confirm that they're better than the tools he currently uses.</p>
<p>In addition to the above work, Hannes has been working on recoding pcap
traces, which is based on Mindy's earlier work. Did point out that TCP needs
more hooks to enable this.</p>
<h4>Documentation best practice</h4>
<p>Dave has been looking at libraries he's been in invovled with and noticed that
the documentation could be much improved.  Dave was hoping that we could come
up with 'best practice' information for how to do docs for code — whether that
includes ocamldoc, gh-pages or whatever else. There are also thoughts for how
to create tutorials for users, which he'd like to do for certain libs e.g.
how-tos for vchan, client/server etc.  <a href="https://github.com/andrewray/iocaml">IOCaml notebooks</a> seem ideal
for this and people who've used them rave about them.</p>
<p>After some discussion, we thought it might be good to put together a wiki page
with pointers to examples of good practice.  We could use this as a guide to
raise the quality bar on all libs.  Examples to point to could be vchan for
the code coverage, cmdliner for docs, etc.</p>
<p>Amir points out that OCaml Labs is looking at improving documentation
generation and that there should be some useful tooling out soon (cf.
<a href="https://opam.ocaml.org/blog/codoc-0-2-0-released/">codoc</a>).  It would be good to move this discussion to the mailing list so
that others can comment and highlight approaches (edit: see the thread on
&quot;<a href="http://lists.xenproject.org/archives/html/mirageos-devel/2015-06/msg00017.html">API documentation best practices</a>&quot;).</p>
<p>There were even thoughts that we could construct unikernels, running entirely
in the browser and that you can interact with via automatically generated
IOCaml notebooks, which would allow people to experiment with the API and talk
across browser tabs ... but perhaps not just yet.</p>
<p>--</p>
<h4>AoB</h4>
<ul>
<li>The next call is scheduled for <strong>Wednesday, 17th June</strong>. Please add any
<a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">agenda items</a> you wish to discuss in advance and refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.
</li>
</ul>
|js};
      };
      {
        updated = {js|2015-05-20 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2015-05-20|js};
        permalink = {js|weekly-2015-05-20|js};
        description =
          {js|20th May 2015: TLS release progress, Mirage.io, Jitsu and Irmin|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Quality and Test
</li>
<li>TLS release planning
</li>
<li>Mirage.io status
</li>
<li>Jitsu status update
</li>
<li>Irmin sync from browser
</li>
<li>Docs on XenProject
</li>
<li>3.0 Planning
</li>
</ul>
<p>Attendees: Reynir Björnsson, Amir Chaudhry (chair), Thomas Gazagnaire,
David Kaloper, Masoud Koleini, Thomas Leonard, Hannes Mehnert,
Richard Mortier, Dave Scott, Balraj Singh, Anil Madhavapeddy, Jon Ludlum,
Jeremy Yallop and Mindy Preston</p>
<h3>Notes</h3>
<h4>Quality and Test</h4>
<p>Mindy has written some tests for networking and they're passing. A point was
made that they could be functorised.  Other tests that force error loops would
also be useful. For example, the 'while true curl' route?  There's also the
desire to be able to run tests on live sites (e.g. mirage-www).  For example,
something like http-perf when a new kernel is booted? Mindy suggested
something that Anil would look into.</p>
<p>We've also noticed an issue with <a href="https://mirage.io">https://mirage.io</a> as it goes unresponsive
after few days.  We're not really sure what the issue is but it's not strictly
within the the TLS stack (Piñata and handshake server have been fine).  If
anyone else can stress test what's going on, that would be very useful.</p>
<h4>TLS release planning</h4>
<p>We'll soon be doing a set of releases that are related to native TLS support.
We do need more tests and deployments of the combined stack because right now
there are only two deployments that are providing feedback.  We really need
more people to try this out and report feedback.</p>
<p>Some of the releases will involve fixing <code>conduit</code> patches and changing the
<code>mirage</code> tool to adapt to new the API.  There was also one person on the opam
repository who complained about issues around zarith. Hannes has a PR to fix
this and it also works on his Cubieboard. The other big thing to deal with is
<code>mirage-entropy-xen</code>.</p>
<p>Anil had some ideas on how to fix the launchpad PPA for <code>binutils</code> and <code>gcc</code>.
The workaround is ok for now but the main thing is to make sure it doesn't
affect other packages in opam.</p>
<p>A TLS tunnel unix binary is also in production to replace <code>stunnel</code>. It's
<em>almost</em> a slot-in replacement but has a slightly different CLI. It's worth
trying out now and Dave said he'd take a look.</p>
<p>The TLS stack has been deployed on <a href="https://realworldocaml.org">https://realworldocaml.org</a> and Anil has
found that it's been rock solid for weeks. Balraj couldn't get it to work from
Chrome from a hotel connection from his laptop. This was probably a transient
issue or due to odd middle-box behaviour.</p>
<!-- Not sure if this was a transient issue or we should blame the NSA. -->  
<p>The <a href="https://weakdh.org">Logjam</a> attack was also announced in the morning and the team is
checking over things to understand how it affects us (if at all, since we
don't support 'export'). You can follow the discussions at
<a href="https://github.com/mirleft/ocaml-tls/issues/271">mirleft/ocaml-tls#271</a>.</p>
<h4>Mirage.io status</h4>
<p>This is running a unikernel with the TLS stack.  Also running its own DNS
servers again, which means it's back to being <em>fully</em> self-hosted (hasn't been
that way for 6 months). There are patches to submit to TCP/IP.</p>
<h4>Jitsu status update</h4>
<p>Jitsu itself seems to be working well - Magnus has been running a public,
low-traffic DNS server ever since NSDI. A few minor bugs have been discovered
but nothing major so far.  We questioned whether there was a way to to use
Jitsu on XenServer. This might be possible on the development version but
probably not on the currently released version.</p>
<h4>Irmin sync from browser</h4>
<p>Irmin sync in the browser is now working!  It's going to a memory store on
Unix using Irmin native. ThomasL had to patch <code>bin_prot</code> as apparently it
didn't like being turned into JavaScript. Everyone should be able to check it
out and test it.</p>
<p>There are some serialisation issues though. When you serialise a value in
Irmin it doesn't include length so you can't compose them. This is fixable and
ThomasG will go and check it. We should make sure to upstream the various
patches too.</p>
<h4>Docs on XenProject</h4>
<p>It's important that we put some content on the
<a href="http://wiki.xenproject.org/wiki/Category:Mirage_Devel">Xen Project wiki pages</a> about MirageOS. A number of newcomers find
out about MirageOS via Xen Project, yet the content on the wiki there is quite
limited and also out of date.  The best approach is probably to put some
stable content there and point people to the docs page on our own site at:
<a href="https://mirage.io/docs">https://mirage.io/docs</a> — Amir will look at this over the coming weeks.</p>
<h4>3.0 Planning</h4>
<p>We have more tests and more quality libraries. Continuing the efforts around
test would be great and we should think of this as being the
'production-ready' release.</p>
<p>Beyond 3.0, it would be great to be in a position to support multiple backends.
We'll be able to think about this once all the details of compatibility become
clearer.  OCamlJava would be one of the things to think about but this is
necessarily a longer term effort.</p>
<p>--</p>
<h4>AoB</h4>
<ul>
<li>
<p>Regarding some of the (TCP) patches, we note that <code>libvirt</code> doesn't support
command line arguments. Perhaps we can ask Dave about this. Might even be
worth getting in touch to see if they can add this.</p>
</li>
<li>
<p>Security mailing list — We've internally discussed the need for a
lightweight security advisory process, so this should be added to list of
items before release.</p>
</li>
<li>
<p>Cross-compilation: This is going well. Question about when we drop 4.01
support. Not clear that anyone is tied to 4.01 for production code. May well
be that MirageOS 3.0 will be the one to drop 4.01 support but will need to
define a cut off date. Must also comprehensively replace camlp4, which is
necessary to improve the situation on ARM. The cutoff should be defined when
all our libs are released using <code>ppx</code> instead, with the same functionality —
cf. typeconv from JaneStreet.</p>
</li>
<li>
<p>The next call is scheduled for <strong>Wednesday, 3rd June</strong>. Please add any
<a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">agenda items</a> you wish to discuss in advance and refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2015-05-06 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2015-05-06|js};
        permalink = {js|weekly-2015-05-06|js};
        description =
          {js|6th May 2015: TLS integration, Irmin-in-browser and MirageOS Hangout|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Quality and Test
</li>
<li>TLS support
</li>
<li>IndexedDB / Irmin-in-the-browser
</li>
<li>MirageOS Q&amp;A hangout?
</li>
</ul>
<p>Attendees: Reynir Björnsson, Amir Chaudhry (chair), Justin Cormack,
Thomas Gazagnaire, Masoud Koleini, Thomas Leonard, Hannes Mehnert,
Richard Mortier, Mindy Preston and Jeremy Yallop</p>
<h3>Notes</h3>
<h4>Quality and Test</h4>
<p>Been provisioning a number of backends on one of our machines (punk), which is
serving <a href="https://mirage.io">https://mirage.io</a>, including tuntap and unix. Would also like to
have an ARM backend running but that's blocked on Scaleway as they haven't
finished looking into the Xen support
(<a href="https://github.com/scaleway/kernel-tools/issues/14">scaleway/kernel-tools#14</a>). We will also need a logging
interface for unikernels but that can wait until the other work is done.</p>
<p>Ultimately, we'd like to use Mirage.io as the main site and load-balance the
incoming connections across all our supported backends (x86/ARM, Unix/Xen).
Would also like this to work across multiple providers, including AWS. We'd
need a method to inform the visitor which version of the site they're looking
at in order to triage and fix incoming bug reports.</p>
<h4>TLS support</h4>
<p>This is working but we need to fix a memory leak in Entropy and maybe also
resurrect <code>xentropyd</code>. Anil mentioned that he'd write up instructions on how
to go from getting certificates, all the way to a deployed https website —
likely based on his experience with certs from Gandi.net</p>
<p>Amir will coordinate a set of blog posts for the TLS related releases and we
should publish things when we're all back. For the moment we should focus on
testing things with the new stack.</p>
<h4>IndexedDB / Irmin-in-the-browser</h4>
<p>ThomasL mentioned that he announced Cuekeeper and published a blog post about
it and today he also got it working with Safari! It turns out that Safari's
database implementation can't cope with concurrent reads, so when it throws an
exception, Cuekeeper has to back off and try again.</p>
<p>Anil will be speaking at an OCaml user group meeting
(<a href="http://www.meetup.com/sv-ocaml/events/222052290/">Silicon Valley OCaml Meetup</a>) and will be showing the crowd an
Irmin demo and Cuekeeper.</p>
<p>ThomasG is putting together docs on how to run some of our existing demos and
it should be almost a step by step, repeatable guide. Would appreciate
feedback on this.</p>
<p>It turns out that lots of people have been trying out MirageOS and have found
their way to Amir's <a href="http://amirchaudhry.com/from-jekyll-to-unikernel-in-fifty-lines">Jekyll to Unikernel</a> post and Mindy's
post on <a href="http://www.somerandomidiot.com/blog/2014/08/19/i-am-unikernel/">deploying unikernels to EC2</a>. Getting deployments up
to EC2 is still quite tricky and a nicer way to do this would be very welcome.
Lots of people seem to have scripts for this including Anil, Mindy and
Jyostna, and it would be good to publicise or consolidate these. We'd also
have to ensure they work when we have SSL support.</p>
<h4>MirageOS Q&amp;A hangout</h4>
<p>This was discussed in a <a href="https://mirage.io/wiki/weekly-2015-04-09/#MirageOSPublicHangoutFAQsession">previous call</a> and was meant to be brought
up this time.  Given how busy we're likely to be this summer, we'll probably
put this off until later in the year.</p>
<p>--</p>
<h4>AoB</h4>
<ul>
<li>
<p>Jitsu/NSDI - We should consider how we can improve our release management
process. At the moment we have no good way to do this as it requires the
ability to manage issues across repos.  Most of our releases involve
cross-cutting changes and we have many libraries. We could possibly put
something together ourselves using the GitHub API but this would be a project
in its own right.  Perhaps David Sheets can look at this once he's back.</p>
</li>
<li>
<p>UROP/Pioneer Projects. We have two summer students taking part, with one
project on a DHCP server and another on an NTP server. If anyone has written a
DHCP server before, please let us know.</p>
</li>
<li>
<p>The next call is scheduled for <strong>Wednesday, 20th May</strong>. Please add any
<a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">agenda items</a> you wish to discuss in advance and refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2015-04-23 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2015-04-23|js};
        permalink = {js|weekly-2015-04-23|js};
        description =
          {js|23rd Apr 2015: Release of 2.4.0, Irmin updates, TLS and Jitsu|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Mirage 2.4.0 released
</li>
<li>Irmin updates
</li>
<li>TLS status
</li>
<li>Quality and Test
</li>
<li>Jitsu/NSDI
</li>
<li>Mirage.io
</li>
<li>3.0 Planning
</li>
</ul>
<p>Attendees: Amir Chaudhry (chair), Thomas Gazagnaire, David Kaloper,
Thomas Leonard, Jon Ludlum, Anil Madhavapeddy, Hannes Mehnert,
Richard Mortier, Dave Scott, Magnus Skjegstad and Jeremy Yallop</p>
<h3>Notes</h3>
<h4>Mirage 2.4.0 released</h4>
<p>ThomasG released <code>mirage.2.4.0</code>, along with <code>conduit.0.8.0</code>,
<code>mirage-conduit.2.1.0</code>, <code>tcpip.2.4.0</code> and <code>mirage-http.2.2.0</code>. These releases
improve the TLS support, fix ARP issues, make the mirage HTTP server signature
only depend on V1.FLOW and fix some usability issues with the mirage
command-line tool. 2.4.0 is an intermediate release to help unblock some of
the interface changes required, but is not the 'supported' SSL release yet.
We can prepare a release properly when DavidK finishes the entropy support</p>
<p>See the thread on the mailing list: &quot;<a href="http://lists.xenproject.org/archives/html/mirageos-devel/2015-04/msg00048.html">Release of Mirage 2.4.0</a>&quot;</p>
<p>Anil is planning to do a blog post on 2.4.0 and is cherry picking some things
to unblock something else.</p>
<h4>Irmin updates</h4>
<!-- **Custom Merges** - Defining custom merges should be done. -->
<p><strong>Watch API</strong> - Is done but the tests are not done and they're not working.
It's a matter of fixing the tests not bugs in this case.</p>
<p><a href="https://github.com/talex5/cuekeeper">CueKeeper</a> is now using the new API.  Sync support can sync between two
branches but not sever sync. Next step is to achieve remote sync. Should be ok
but cannot use git-format yet. Transcoding may be possible but not just yet.
Cannot quite use git-format everywhere as there are other things we need to
think about (zlib etc). Basically ocaml-git needs to work from JavaScript.</p>
<h4>TLS status</h4>
<p><strong>Entropy</strong> - There's an issue that is tracking all the remaining pieces for
Entropy support (<a href="https://github.com/mirleft/ocaml-nocrypto/issues/55">mirleft/ocaml-nocrypto#55</a>).</p>
<p>DavidK wrote up the current state of things on the issue and it's almost there.
He just needs to finish the discussions with ThomasL about ARM support. Anil
has been reviewing the code for nocrypto and it looks good. AsyncSSL is hard
to use correctly - certificate validation was working only a month ago.</p>
<p>First user of the TLS (outside those who developed it) is
<a href="https://realworldocaml.org">https://realworldocaml.org</a>. There's not been a single crash or issue and
it's not on a loop so if it did go down, we would know about it fairly quickly.
We currently have an 'A' from the <a href="https://www.ssllabs.com/ssltest/analyze.html?d=realworldocaml.org&amp;latest">SSL tests</a> but we'd really like
to get an A+. It seems that may have more to do with browsers at this stage
than anything to do with TLS.</p>
<p>In terms of releases, we first need ASN1 to go out and then nocrypto after
it's been cleaned up, then some modifications to TLS to remove some deprecated
code. At that point, we should have out of the box support for MirageOS!</p>
<p>There are also things that need to be fixed in <code>xentropyd</code>. DavidK will remove
the entropy signature from nocrypto and at some point will also work on a
Piñata summary post.</p>
<h4>Quality and test</h4>
<p>There are now bulk build results available at <a href="http://opam.ocaml.org/builds">http://opam.ocaml.org/builds</a>.
These is are lists of what works, is just broken and highlights where
something may have changed.  This is a <em>very</em> experimental script (it's a bit
messy at the moment).  We can make a MirageOS specific version which should be
quicker to run — this one takes a day and a half to run.</p>
<p>We should also be keeping an eye on <a href="https://github.com/mirage/is-mirage-broken/blob/master/logs/README.md">is-mirage-broken</a>, as we need to keep
that fixed. ThomasL is in town and is thinking of doing some UI and
Irmin-based stuff which could be cool.</p>
<p>We're also looking at adding <a href="https://www.scaleway.com">Scaleway's ARM cloud</a> as a place to
run tests and services.  If people want access to ARM machines there we can
likely arrange for that — however we don't want them to go unused. It would be
neat to use them as build bots (i.e. doing the build in the cloud but
deploying to Cubieboards). They're currently trying to get Xen booted
(<a href="https://github.com/scaleway/kernel-tools/issues/14">scaleway/kernel-tools#14</a>).  In the meantime, if anyone wants
to try them out, they have a one month free trial.</p>
<h4>Jitsu/NSDI</h4>
<p>Working on getting the release of Jitsu into the mirage-dev repo. ThomasG is
working on TCP/IP code and may be able to merge that into main stack soon.
Is also cleaning up the Jitsu code-base and adding ARP support too. Anil has
an ancient patch but is not confident about merging it yet.</p>
<p>Magnus is also working on a blog post about Jitsu, which will hopefully be
ready soon.</p>
<p>We want to get Jitsu running on one of our machines and Anil will set that up
soon (without the synjitsu component for now). Once Dave has set up XenServer
on the relevant machine and we'll take it from there.</p>
<h4>Mirage.io</h4>
<p>Getting this up and running depends on the state of the Monk machine.
We'll have to come back to this when it's ready.</p>
<h4>3.0 planning</h4>
<p>Only had a brief amount of time to discuss this but the feeling is tha
quality and test will be key. We need to improve our workflows to have better
processes such that things break less often. When things are reported as
broken, we need to move to fix them.</p>
<p>--</p>
<h4>AoB</h4>
<ul>
<li>
<p>Handling constraints in the mirage tool - Discussed <a href="https://mirage.io/wiki/weekly-2015-04-09/#Handlingconstraintsinthemiragetool">last week</a>
but nothing further to add this time around.</p>
</li>
<li>
<p>Tests for <code>js_of_ocaml</code>? This would be cool but we also need to be careful
with stack overflows (cf. tail recursion).</p>
</li>
<li>
<p>The next call is scheduled for <strong>Wednesday, 6th May</strong>. Please add any
<a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">agenda items</a> you wish to discuss in advance and refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2015-04-09 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2015-04-09|js};
        permalink = {js|weekly-2015-04-09|js};
        description =
          {js|9th Apr 2015: Decoupling the mirage tool and libs, Public Q&A session|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Quality and Test
</li>
<li>Irmin update
</li>
<li>Handling constraints in the Mirage tool
</li>
<li>MirageOS Public Hangout/FAQ session
</li>
</ul>
<p>Attendees:
Amir Chaudhry (chair), Thomas Gazagnaire, Heidi Howard, David Kaloper,
Masoud Koleini, Thomas Leonard, Hannes Mehnert, Richard Mortier,
Nicolas Ojeda Bar, Mindy Preston and Magnus Skjegstad</p>
<h3>Notes</h3>
<h4>Quality and test</h4>
<p>There was a meeting of the test breakout squad, which included Mort, Mindy,
David Scott, Magnus and ThomasG. There was a long discussion last week and
they covered a variety of items, such as reproduction of issues, component
tests and other things. There's room for improvement everywhere!</p>
<p>There are some useful things to get started with, for example simply
documenting assumptions in stack would a step forward (e.g. blocking vs
non-blocking, etc).  It would also be helpful to define best practise and we
can look to certain libraries for this (cf. Dave and Vchan).</p>
<p>There are several actions that arose from the test meeting and Mort has notes
that he'll write up when he gets a chance.</p>
<p>ThomasL also noted that Travis has a new build cluster on Amazon, as long as
<code>sudo</code> is not needed. It would speed things up if we can we get PPA added to
that.</p>
<h4>Irmin update</h4>
<p>ThomasG is reworking the the watch API.  Added two functions and is adding
unit tests too.  The API is still not settled as ThomasL has posed questions
that need to be addressed. The new LCA code is much faster though.</p>
<p>Although ThomasG is currently focused on Watch, merge is the big thing missing
at the moment. ThomasL is specifically waiting for for support for this and
it's the main thing he needs before he can 'release' <a href="https://github.com/talex5/cuekeeper">CueKeeper</a> to others.</p>
<h4>Jitsu update</h4>
<p>Jitsu will be <a href="https://www.usenix.org/conference/nsdi15/technical-sessions/presentation/madhavapeddy">presented at NSDI</a> in less than a month.  There
haven't been many updates since last time, though work is taking place to add
libxl support (and keep support for both libvirt and libxl).  The code that
exists in the main branch can can be used and is the version we used for the
experiments in the upcoming paper.  It's stable but currently a bit difficult
to use. Should try and improve this before the presentation itself, so Magnus
needs to make some releases.  Amir is preparing a news release to coincide
with the NSDI talk and will circulate off-list for feedback.</p>
<h4>Handling constraints in the mirage tool</h4>
<p>We had a brief discussion about trying to decouple the releases of libraries
from the <code>mirage</code> tool itself.</p>
<p>We're not in a good place at the moment as we can't release a number of
libraries without also having to update and release a new version of <code>mirage</code>
too.  Currently there is no way to set constraints in the Mirage tool itself,
which leads to a situation where a number of new libraries may be available in
OPAM but the Mirage tool cannot use them — i.e. there are packages that are
more recent than <code>mirage</code> knows about. Therefore the Mirage tool becomes a
bottleneck.  There are many libraries that are in this situation, so this is
not an isolated case. The opinion at the moment seems to be to push the onus
of updating <code>mirage</code> onto the maintainer of the respective repos, but this has
it's own issues (and failure modes).</p>
<p>This is something that we will need to discuss further so we should bring it
up on the next call.</p>
<h4>TLS entropy story</h4>
<p>DavidK still working on this! Ask again in two weeks.</p>
<h4>MirageOS Public Hangout/FAQ session</h4>
<p>A question came in by email about hosting a public hangout for people who may
be interested in learning more about unikernels and MirageOS. One of the
points that occurred to us was whether this is a repeat of the written
information we already have, a Q&amp;A with the developers, or a wider-ranging
discussion about where MirageOS and unikernels are going.  All are valid areas
but serve different audiences and require different attendees/prep.</p>
<p>In general, it was felt that this would be A Good Thing, as long everyone can
get something out of it. For example, it would be great for us to hear of
use-cases and we could record the session and post it to the website as
further material.  It would also allow us to correct any misconceptions about
unikernels and our approach.  There were a few comments that although we have
quite an open process, we could do a better job of communicating the project.</p>
<p>In terms of format, we seemed to settle on something with a partial
presentation (less than 30mins) followed by open Q&amp;A.  Sourcing questions
would also allow us to put together an FAQ and become more aware of — and deal
with — the common issues that crop up.  It might even be worth asking around
directly for what people would like to get out of the session and go from
there.  Amir will look into this and will bring up some ideas in about a month
(i.e. in the call after the next one).</p>
<p>--</p>
<h4>AoB</h4>
<ul>
<li>
<p>Amir apologises for the recurring delays in getting the call notes up.</p>
</li>
<li>
<p>Hannes has more thoughts to share on security things. Will post to the list.</p>
</li>
<li>
<p>The next call is scheduled for <strong>Wednesday, 22nd April</strong>, though we may
have to shift to the Thursday again. Please add any
<a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">agenda items</a> you wish to discuss in advance and refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2015-03-25 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2015-03-25|js};
        permalink = {js|weekly-2015-03-25|js};
        description =
          {js|25th Mar 2015: Security advisory processes, TLS update and requests|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Security advisory process
</li>
<li>TLS status
</li>
<li>Quality and Test
</li>
<li>Mirage.io status
</li>
<li>3.0 Planning
</li>
</ul>
<p>Attendees:
Amir Chaudhry (chair), Thomas Gazagnaire, Matthew Gray, Sean Grove,
David Kaloper, Thomas Leonard, Hannes Mehnert, Nicolas Ojeda Bar,
Mindy Preston and Magnus Skjegstad</p>
<h3>Notes</h3>
<h4>Security advisory process</h4>
<p>Hannes brought up that at the moment, the project doesn't have a method for
dealing with security advisories or incoming reports of security issues.  We
should set up some form of advisory system.  This would likely include a
website that lists known security vulnerabilities and might also include a
mailing list for people to report critical issues.  This would be more general
than just for TLS and should cover anything MirageOS-related.</p>
<p>Amir mentioned that Xen Project already has such a process so it's worth
looking at that and seeing what we can adopt from it, rather than having to
invent everything from scratch.  In order to keep this moving, Amir suggested
that Hannes submit a page to the site as an RFC on the procedure we should
follow.</p>
<!-- TG excalims that there are no critical bugs.  -->
<h4>TLS status</h4>
<p>Still thinking about entropy in the security stack. We're currently using the
internal APIs of <code>nocrypto</code>, which is not ideal and we'd like to adjust this
to have a better abstraction. The original idea was that the RNG would extract
ambient entropy and use that for crypto purposes but it seems but it seems
that no-one else really needs/uses entropy. It appears that for most other
users, a pseudo-random stream is sufficient for their purposes.</p>
<p>We need to think about this carefully and it will involve more in-person
discussion. It's a hairball as things are not necessarily in the right places
currently) and there's the risk of confusion as people add their own entropy
sources for specific purposes — poor changes propagate through people's code
bases. It's not just consumers of entropy but also providers of entropy that
need to be addressed.  This leads to several structural issues and we need to
figure out what to do.  An open question is how many people expect to write
code that needs an entropy interface.</p>
<p>Getting the entropy story figured out will likely delay the next point-release
of Mirage (2.4.0) — if it isn't fixed.  DavidK will send an email to the
mailing list to continue this discussion.
<em>[Edit: The thread is <a href="http://lists.xenproject.org/archives/html/mirageos-devel/2015-03/msg00117.html">&quot;Update on entropy&quot;</a>.]</em></p>
<h4>Quality and test</h4>
<p>There's work towards a virtual network interface, which can run TCP and iperf
tests at the moment.  The goal is to be able to test the network stack but
without needing an <em>actual</em> network (test between unikernels). At the moment,
it's just been tested with two unikernels and we've reported issues with <code>Lwt</code>.
If (and only if) you add a delay on write, then it works ok (this was
discussed on the mailing list).  Will stick with two unikernels for now and
later on, we can add support for more.  Also done some work on netfront and
pcap and used them to do some simple tests for now.  In time, we should be
able to write some meaningful tests</p>
<p>At the moment, not many people have had a chance to look at coveralls and
bisect on Dave's repos — Mindy's had a look but ThomasG hasn't yet.</p>
<h4>Mirage.io status</h4>
<p>Last status was that the second Bytemark machine was being reinstalled to run
a version of Xenserver (with xapi).  The idea is that this would then host the
Mirage website. We need Anil present to discuss this so this item is moved to
the next call.</p>
<h4>3.0 Planning</h4>
<p>Following on from the <a href="https://mirage.io/wiki/weekly-2015-02-25#30Planning">previous discussion</a> a month ago, it's
becoming clear that there's an emphasis on improving quality of the libs.
which means better tests.  Amir will summarise where things are with the
thoughts around the 3.0 release and send to the list before the next time we
discuss this.</p>
<p>--</p>
<h4>AoB</h4>
<ul>
<li>
<p><strong>Irmin update</strong>: ThomasG is still working on getting feedback upstreamed
and improving the API. The big thing missing is having a garbage collector.
Over the weekend ThomasL transferred all his items to the browser and changed
to using IndexDB which does not have a quota limit. ThomasL will write a blog
post about this for others to follow. Noted that a JS backend for Irmin as
separate lib might be good.</p>
</li>
<li>
<p><strong>State of Docs</strong>: A new user commented that they had a tricky time with
documentation and that figuring out how to use our existing libs has been more
difficult than necessary (specifically with Irmin). There's a pretty
significant learning curve even if you know OCaml. In the case of Irmin, it
would be much better if the examples themselves actually worked. In general,
it would be good to be able to test such examples on an ongoing basis
automatically).</p>
</li>
<li>
<p>The next call is scheduled for <strong>Wednesday, 8th April</strong>, but there are
indications that we may need to delay it by a day - Please add any
<a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">agenda items</a> you wish to discuss in advance and refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2015-03-11 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2015-03-11|js};
        permalink = {js|weekly-2015-03-11|js};
        description =
          {js|11th Mar 2015: More racing, Testing, Networking, Large merges and Cleanups|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Race issues
</li>
<li>Quality and Test
</li>
<li>Networking stack
</li>
<li>Outstanding Merges (TLS and DEVICE)
</li>
<li>Improve onboarding
<ul>
<li>GitHub Org cleanup
</li>
<li>Better documentation
</li>
</ul>
</li>
</ul>
<p>Attendees:
Amir Chaudhry (chair), Thomas Gazagnaire, David Kaloper, Thomas Leonard,
Jon Ludlam, Anil Madhavapeddy, Hannes Mehnert, Richard Mortier and Dave Scott</p>
<h3>Notes</h3>
<h4>Race issues</h4>
<p>The startOfDay race issue between netback and netfront — discussed on the
<a href="https://mirage.io/wiki/weekly-2015-02-25#miragenetxenraceissue">last call</a> — is still unresolved. It's still difficult to
reproduce but we do have a <a href="https://github.com/mirage/mirage-net-xen/issues/20#issuecomment-78264578">minimal example</a> of this problem, which
should help greatly. It only seems to surface when it's on a live Xen host
which is why it's a tricky one to deal with.  It would be very useful if
anyone can provide other examples of this problem, especially to see if the
issue exists on x86 and it hasn't surfaced yet.</p>
<p>In the meantime, we might need to put a 'sleep' into <code>mirage-net-xen</code> to get
it to work for the time being. Ironically, this whole issue didn't occur until
ThomasL's optimisations, which in a way, means they were good enough to
surface this issue (in other words, this is still progress!).</p>
<h4>Quality and test</h4>
<p>The testing breakout squad <a href="https://mirage.io/wiki/weekly-2015-02-25#Qualityandtestinfrastructure">we proposed</a> didn't quite convene but
things around test are still getting better. Anil has been fixing breakages
reported via <a href="https://github.com/mirage/is-mirage-broken/blob/master/logs/README.md">is-mirage-broken</a> and things look good as mirage-skeleton
is now successfully building across all platforms. cohttp and TLS are also
part of those tests and some of them are in a known-broken state (due to other
outstanding work). We need to get this up to 100% pass rate before we do much
more. There are still some more tweaks to commit but things look much better
than they did before.</p>
<p>Magnus has been working on a Mirage net front end (including pcap), so we don't
need a real network to test. There is also the testing repo from Masoud, which
Mort will try out.  We need a Xen machine to do this so will have to
discuss where this can take place.</p>
<p>Amir noticed a <a href="http://opam.ocaml.org/packages/quickcheck/quickcheck.1.0.2/">QuickCheck</a> library in OPAM so perhaps we could
use it. However, Anil pointed our that there is likely to be a fair amount of
plumbing and scaffolding involved in order to get to something useful (which
still needs someone to put in the effort). Dave has been using BISECT and
coveralls, which he's been happy with (and slightly addicted to).  You can see
examples of this in the <a href="https://github.com/mirage/shared-block-ring">shared-block-ring</a> repo (which is at 81% coverage
and <a href="https://coveralls.io/r/mirage/shared-block-ring?branch=master">climbing!</a>).  It would be good to get some notes written
down and sent out to the list about this process and hooking together with
Travis.</p>
<h4>Networking stack</h4>
<p>So far you'll notice that we've mainly discussed issues relating to the
network stack.  It's obvious that this is a critical piece of infrastructure so
we need continue the improvements we've been making.  However, we also need to
be <em>charting</em> this progress, which means gathering base-line numbers before
doing releases. We'll be able to do much more functional testing when Magnus'
work is complete and Anil will also talk to Mindy about her work. Overall,
things are going well, we're continually improving and it would be good to
monitor that progress.</p>
<h4>Outstanding Merges (DEVICE and TLS)</h4>
<p>There are a couple of wide-ranging changes that are being tracked and releases
of various libraries need to be co-ordinated appropriately.</p>
<p><strong>Removing DEVICE.connect</strong> (<a href="https://github.com/mirage/mirage/pull/350">mirage/mirage#350</a>) — As of yesterday, all the
relevant libraries have been updated and released so the <code>DEVICE.connect</code>
changes have now been merged. This involved coordinated changes and releases
of at least 15 libraries.  This also allowed us to update the old repos with
new Travis scripts and improvements to OPAM metadata.  As a result of this and
other activity, we <a href="https://mirage.io/releases#miragev230Interfacecleanupsandentropysupport">released Mirage 2.3.0</a> into the upstream OPAM
repository yesterday.</p>
<p><strong>TLS Support</strong> (<a href="https://github.com/mirage/mirage-dev/pull/52">mirage/mirage-dev#52</a>) — This is still awaiting a few
patch reviews/merges of a number of different libraries, which is nearly
complete. Just awaiting changes to Conduit, OCaml-TLS and also a release of
Ctypes 0.4.0. Once TLS support is complete, we will be able to release
Mirage 2.4.0</p>
<h4>Improve onboarding</h4>
<p>Some informal feedback from a few people has been that MirageOS is still an
intimidating project to get involved with. To some extent this is unavoidable
as certain aspects require experience of systems/protocols before diving in
(or the will and patience to acquire that experience), and we're still
building out our set of simpler Pioneer Projects. However, there are certain
things we can do to help make it easier for people who may be looking around
but are still reluctant to email the list. For example, we could work on the
following over the next few months:</p>
<p><strong>GitHub Org cleanup</strong> — We have a large number of repos accumulating on the
Mirage GitHub Org and a number of them are no longer relevant (cf. <code>mirari</code>).
We could identify these libraries and move them out into a separate Org
(say, mirage-attic) so that only current repos remain in the primary
organisation — we'd have to also update any OPAM-repo metadata as part of this
(it's highly unlikely that anyone is using these libs — it's just so that we do
this properly).  Doing this would allow a newcomer to be sure that any of the
libraries in the GitHub org are worth looking at. In addition to this, we
should also clean up stale issues across all the remaining repos so that they
reflect current reality.</p>
<p><strong>Improve documentation</strong> — Due to separate efforts towards an
<a href="http://www.cl.cam.ac.uk/projects/ocamllabs/tasks/index.html#platform">OCaml Platform</a>, we now have
<a href="http://opam.ocaml.org/blog/codoc-0-2-0-released/">new documentation generation tools</a> available to us. These are still
in alpha but they go some way to improving the docs we can produce for
collections of libraries (CSS notwithstanding). We'd encourage people to begin
using these tools (and submitting patches if possible). In addition, there
have been a lot of blog posts about how to do things with Mirage and it's time
we turned those into actual documentation on the website. In other words,
sweep through the material we've created and backport it onto the site. This
makes it significantly easier to maintain as the underlying tools progress.</p>
<p>Neither of the above activities is particularly challenging, but it's more
about setting aside the time to complete them.  In the past we've proposed
having a 'doc-day' of our own (similar to Xen's document days), so that we can
get together and just tick things off.  We may need to schedule a few days
like that to get these things done.</p>
<p>--</p>
<h4>AoB</h4>
<ul>
<li>
<p>Would like to move the <strong>Mirage site to be HTTPS</strong> only, which needs TLS.
Hannes is keen to do this and Anil has all the necessary certificates.  Will
need TLS conduit. Running the website this way will test the whole stack. Amir
notes that website is still the canary as when end-to-end thing break, that's
the first place we notice. We need to fix things quickly when they do go down.</p>
</li>
<li>
<p><strong>Irmin feedback</strong>: Some discussions on the mailing list about the API and
some feedback from early users (ThomasL and KC). Turns our that some aspects
of Dave's work on shared-block-ring can help with some of ThomasG's activities.</p>
</li>
<li>
<p>The next call is scheduled for <strong>Wednesday, 25th March</strong> - Please add any
<a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">agenda items</a> you wish to discuss in advance and refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2015-02-25 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2015-02-25|js};
        permalink = {js|weekly-2015-02-25|js};
        description =
          {js|25th Feb 2015: Races, Testing, Deployment, Pioneers and Roadmapping|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li><code>mirage-net-xen</code> race issue
</li>
<li>Quality and test infrastructure
</li>
<li>Deployment automation
</li>
<li>Irmin progress
</li>
<li>Steps to Mirage.io
</li>
<li>Pioneer Projects
</li>
<li>3.0 Planning
</li>
</ul>
<p>Attendees: Amir Chaudhry (chair), Thomas Gazagnaire, Heidi Howard,
David Kaloper, Thomas Leonard, Anil Madhavapeddy, Hannes Mehnert,
Richard Mortier, Dave Scott, Mindy Preston, Nicolas Ojeda Bar
and Magnus Skjegstad</p>
<h3>Notes</h3>
<h4>mirage-net-xen race issue</h4>
<p>There seems to be a dead-lock/race issue somewhere in the <a href="https://github.com/mirage/mirage-net-xen">mirage-net-xen</a>
1.3.0 release (<a href="https://github.com/mirage/mirage-net-xen/issues/20">mirage/mirage-net-xen#20</a>). We originally thought this might
be something to do with one of Dave's patches but it's not clear that's really
the case. Currently, we're not even sure if it's <em>definitely</em> a v1.3 issue but
things do seem to work under v1.2.  It's even possible that it could be a dom0
problem.  A reproduction of the issue from others would be quite helpful and
Magnus mentioned he would give this a shot. Either way, this tells us we need
more unit tests, as we've <a href="https://mirage.io/wiki/weekly-2015-02-11#ImprovingQuality">previously discussed</a>.</p>
<h4>Quality and test infrastructure</h4>
<p><a href="https://mirage.io/wiki/weekly-2015-02-11#ImprovingQuality">Last time</a>, we discussed whether we may be able to do certain things
with OPAM remotes (e.g like splicing between remotes).  After a chat with
Louis, the lead maintainer of OPAM, it seems this would not be a
straightforward thing to do — which means it's not an avenue we can explore
for now.</p>
<p>What we can realistically do in the short term is improve our own practices.
We have all the pieces in place so it's a matter of using them and getting
into the habit of incorporating them into our normal process. Something that
would really help is a QuickCheck style library. [<em>It seems <a href="http://opam.ocaml.org/packages/quickcheck/quickcheck.1.0.2/">QuickCheck</a>
is in OPAM but code maintenance is quite unclear - Amir</em>]</p>
<p>It was raised that we have a nice modular network stack which is abstracted
away from things underneath. There may be a way to use this approach to
benefit more systematic testing. This is relevant to the trace-checking work
that DavidK is working on and in addition, trying to get <code>pcap</code> input would be
good. Many of these things are tied to the performance framework and getting
to something that would let us run <code>Iperf</code> everyday would be great.</p>
<p>Anil proposed forming a breakout squad with himself, DavidK and Mindy who would
think about testing and performance issues — Hannes was also suggested but
he declined, stating dryly that he doesn't really care about performance
(resulting in laughter from everyone else). Someone else who's done things in
this area is Luke Dunstan (another contributor), so it's worth being aware of
those efforts.</p>
<p>In general, the approach should be that we should work on the simple things
before the more complicated things.  However, it's not always clear what is
meant by 'simple'.  To help clarify this, we should constrain it to things
within a single unikernel — no aspects of dom0 or anything else.</p>
<p>Since testing and quality is such an important issue, Amir will keep it on the
agenda for each call.</p>
<h4>Deployment automation</h4>
<p>Amir's interested to see what solutions/scripts people have created around how
we <em>deploy</em> unikernels.  He's particularly interested in automated processes
that pick up from where his previous <a href="http://amirchaudhry.com/from-jekyll-to-unikernel-in-fifty-lines">Jekyll to Unikernel post</a>
left off (i.e. with a unikernel committed into a deployment repo).</p>
<p>After a quick poll of attendees, it seems that the deployment processes people
use is quite diverse.  Mindy has a set of scripts for EC2, Anil uses a cronjob
and Dave has used XAPI.  Each of these seems bespoke and it's unlikely
anything is shared between them (compare with the TravisCI set up, which has
become quite consistent across projects).</p>
<p>Amir will look over these to see where things stand and will likely write up a
blog post about his ideal deployment workflow. Ultimately, his desire is to
set up an end-to-end system such that a git push to a repo will finish with a
newly built unikernel being started on one of our Bytemark machines.</p>
<h4>Irmin progress</h4>
<p>ThomasL is making a browser-based ToDo app that uses Irmin with local HTML5
storage.  This is to replace his current task management system (also
browser-based).  At present, it's not talking to any server (so no backup), is
fully in the browser and commits on every change. It's not too difficult to do
sync but it is difficult to use any git tools (due to lack of support) —
ThomasL is not using the Git backend yet. One very useful thing would be
getting the SHA-1 code implemented elsewhere. We can either expose it from
where it is currently or put the code elsewhere.  The next step for ThomasG is
to compile zlib library to Xen.</p>
<p>When this system works it would be really useful for Real World OCaml
commenting system.  It would allow the comment to be stored locally first and
<em>then</em> synced to the GitHub 'back-end' — thus solving a problem some users
have reported about comments being lost in transit.</p>
<p>The repository with ThomasL's app is <a href="https://github.com/talex5/cuekeeper">cuekeeper</a> — though be aware that it
doesn't do anything yet!  There's also a useful thread on the mailing list,
which has both Thomas' involved, where questions about the library and API
have been discussed. That thread is likely useful for anyone wanting to
explore Irmin, with the caveat that it's alpha/beta stage and there have
almost certainly been changes pushed during the discussions (email thread is:
&quot;<a href="http://lists.xenproject.org/archives/html/mirageos-devel/2015-02/msg00049.html">Irmin API newbie questions</a>&quot;).</p>
<h4>Steps to Mirage.io</h4>
<p>Amir would like to switch to using <a href="http://mirage.io">mirage.io</a> as the primary domain
(it currently redirects to openmirage.org - so he's using it already).  This
is more than just a straightforward record change as we'll begin to use more
of our other tools as part of the underlying site infrastructure (e.g. DNS
zone). To this end, Anil has been reinstalling the second Bytemark machine in
order to run a version of Xenserver. We will also need to sort out
certificates as we should be running HTTPS for the site.</p>
<h4>Pioneer Projects</h4>
<p>It seems there's been caution from new users about taking on Pioneer Projects
as the meaning of the difficulty levels is a little vague.  This partly
relates to expected knowledge of OCaml and also domain-specific expertise (e.g
networking, security, storage, etc.).  Our thoughts are that trying to learn
<em>both</em> OCaml <em>and</em> a new area as part of a Pioneer Project will be quite
challenging. Hence the suggestion is for a newcomer to pick an area that
they're familiar with so that they have some grounding and can learn how we've
implemented things.  If the projects listed do not overlap with someone's
existing area of knowledge then that person should mention their experience on
the <a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> so we can consider new categories of projects.</p>
<p>If someone only has limited experience from elsewhere to draw on, and is
completely new to OCaml, then we should point to existing resources so that
they can get up speed (e.g. <a href="https://realworldocaml.org">Real World OCaml</a>, etc).</p>
<p>We must take care with the difficulty levels as what we consider to be a
2-star project from our perspective may be perceived as quite challenging by
the person undertaking the project.  This could have a detrimental effect if
people think everything is actually harder than advertised.</p>
<p>Having said this, we really do need more 1-star projects. There are likely
many things we've thought about doing that we haven't quite got around to.
Please look through your issue trackers in case it helps you come up with
something. One suggestion was that writing a CLI client front-end for
something like the <a href="https://opam.ocaml.org/packages/imaplet-lwt/imaplet-lwt.0.1.9/">IMAP server</a>, would be useful and straightforward.
Indeed, CLIs for many other libraries would be valuable, including TLS,
Syndic etc.</p>
<p>Anil will put together a simple cohttp project, ThomasG already added a 2-star
project and Amir will write an explanatory page to go alongside the current
Pioneer Projects page to describe the thoughts above.</p>
<h4>3.0 Planning</h4>
<p>Amir's put together a <a href="https://github.com/mirage/mirage-www/wiki/Roadmap">Roadmap</a> page on the wiki, where we can (1) collect
thoughts about what we might like to see in future versions of MirageOS and
(2) filter that list into an agreed set of efforts for the next major release.
Note that these are two <em>separate</em> processes and we should take care not to
conflate them.  Essentially, one is about ideation/creativity and the other is
about decisive filtering and prioritisation.  Hopefully, it's self-evident as
to why it can be difficult to do both in one step (especially with large
groups of people).</p>
<p>It's worth pointing out that the roadmap is <em>not</em> a feature-list. It's meant
to be a description of the <em>areas</em> where we think we should focus efforts.
This lends itself to defining clearer goals which we can collectively commit
to — knowing that our efforts will be in aligned with everyone else's.  It may
help to think of specific scenarios if the above description feels too broad.</p>
<p>Some thoughts from the attendees included:</p>
<ul>
<li>Quality/Testing is a feature
</li>
<li>Treat 3.0 as the deployment release — i.e. will run in 'production' for a long time so act accordingly
</li>
<li>Could think of this as the one that ties up all the loose ends
</li>
<li>Improve the docs and onboarding process
</li>
<li>Better integration between components (&quot;end up back in n-squared space&quot;)
</li>
<li>Javascript
</li>
</ul>
<p>This agenda item will be brought up once a month and we will converge on the
efforts we want to focus on for the 3.0 release. This may happen very quickly
or it may take more discussion but either way, it will be recorded in these
notes.</p>
<p>--</p>
<h4>AoB</h4>
<ul>
<li>
<p>Amir is mentoring the <strong>Static Site Pioneer Project</strong> with David Sheets and
someone has stepped forward to work on this (yay!) — will report back as
things progress</p>
</li>
<li>
<p><strong>OPAM testing</strong>: <a href="https://github.com/ocaml/opam/releases/tag/1.2.1-beta3">Beta 3</a> is now out and <em>should</em> be stable so
please do try it out!</p>
</li>
<li>
<p>The next call is scheduled for <strong>Wednesday, 11th March</strong> - Please add any
<a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">agenda items</a> you wish to discuss in advance and refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2015-02-11 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2015-02-11|js};
        permalink = {js|weekly-2015-02-11|js};
        description =
          {js|11th Feb 2015: Improving quality, error handling, TLS merge and GSoC|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Improving Quality
</li>
<li>Error Handling RFC
</li>
<li>TLS merge progress
</li>
<li>OPAM 1.2 only
</li>
<li>GSoC Projects
</li>
<li>FOSDEM demo
</li>
<li>Bitcoin Piñata
</li>
</ul>
<p>Attendees: Amir Chaudhry (chair), Thomas Gazagnaire, David Kaloper,
Thomas Leonard, Jon Ludlam, Anil Madhavapeddy, Hannes Mehnert, Richard
Mortier, Dave Scott, Mindy Preston and Nicolas Ojeda Bar</p>
<h3>Notes</h3>
<h4>Improving Quality</h4>
<p>We need to improve this in a more general and automated way. So far, we've done
quite well with local library testing but we don't really have the ability to
test things in coordinated way for unikernels.  Specifically, we don't really
have much end-to-end testing that looks at the complete toolchain. The only
place where this surfaces for us is still mirage-www (this website!), as bugs
tend to appear there whenever a wider issue occurs (cf. the recent crash on
boot - <a href="https://github.com/mirage/mirage/issues/357">mirage/mirage#375</a>). Finding bugs in an automated way and reporting
them is important as the project grows.</p>
<p>Some options include providing a manifest of specific versions and running
tests that way.  It would allow us to take different libraries and bisect
issues.  We would have to build this ourselves as we still have very few
automated tests e.g <a href="https://github.com/mirage/is-mirage-broken/blob/master/logs/README.md">is-mirage-broken</a> (and it's not enough to just have
tests — we also have to fix things that they show as broken).</p>
<p>Another thought is that instead of merging directly into the upstream OPAM
repository (which is when we realise things aren't quite right), maybe we can
merge into a staging repo and ensure they pass a bunch of additional tests.
Provided tests pass, then the libraries can be merged upstream en-masse — in a
known-working state. However, we must take care to balance things between
staging and releases — we don't want to end up with a large backlog of
'unreleased' software and then do infrequent 'big-bang' releases.  We need to
test and release upstream often and no-one should have to add the staging
remote just to use up to date software (that would merely shift the current
problem from the main OPAM repo to our staging repo).</p>
<p>Related to the above, the ability to splice from an OPAM remote might be good
(currently have to take <em>everything</em> on a remote).  Perhaps ThomasG, Anil and
Louis Gesbert can discuss at this. At the moment, trying to add test cases
into libraries will make a big difference as an interim workflow.  For
example, Magnus has been patching TCP/IP to have some functional testing on
Travis and we could do this for other libraries too, e.g DNS, Cohttp, etc and
the approach would be useful elsewhere too.  Getting some kind of Xen testing
into <a href="https://github.com/mirage/mirage-skeleton">mirage-skeleton</a> would also be great.</p>
<h4>Error Handling RFC</h4>
<p>Thomas Leonard <a href="http://lists.xenproject.org/archives/html/mirageos-devel/2015-01/msg00143.html">began a discussion</a> on Error handling in Mirage and
<a href="https://github.com/mirage/mirage-www/pull/274">submitted a page</a> to the website as an RFC. Since then, he's tried to
document what people advocating for polymorphic variants were describing but,
it would be better if other people can read it and advocate for their opinion
(DavidK would take a look). There are also things from 4.02 that we might want
to consider. In general, one of the themes that emerged from the discussions
so far is the difference of Error-handling 'in the large' and 'in the small'.</p>
<h4>OPAM 1.2 support only</h4>
<p>The <a href="https://github.com/mirage/mirage/pull/353">patch to the mirage tool</a> has been made but not merged yet.
ThomasG needs to get around to this and will do in due course.</p>
<h4>TLS Merge progress</h4>
<p>We are almost there with this and there are number of patches that need to be
reviewed and merged (<a href="https://github.com/mirage/mirage-dev/pull/52">mirage/mirage-dev#52</a>). The largest blockers are the
blobs of C code and getting them to run on Mirage. The last mile still hasn't
been covered as the entropy story is not yet complete — we need to get
<code>xentropyd</code> out first. Currently it's not reliable enough as things start
hanging. Once that's out of the way we're looking good.  DavidK is working on
it.</p>
<h4>GSoC Projects</h4>
<p>As part of Xen, we will be submitting projects as part of Google Summer of
Code (GSoC). We've been curating a set of <a href="https://github.com/mirage/mirage-www/wiki/Pioneer-Projects">Pioneer Projects</a> and we
can definitely add to this list. A quick call for ideas resulted in several
potential projects being proposed and these will be added to the projects page.
Very briefly, we discussed:</p>
<ul>
<li>A router VM, which can route traffic and be a DHCP server.
</li>
<li>A syslog unikernel
</li>
<li>A Firewall
</li>
<li>OCaml SSH
</li>
</ul>
<p>Please see the <a href="https://github.com/mirage/mirage-www/wiki/Pioneer-Projects">Pioneer Projects page</a> for more details.</p>
<h4>FOSDEM Demo</h4>
<p>Amir gave a demo at FOSDEM of a unikernel running on a Cubieboard2, that would
serve the 2048 game when people connected to its Wifi access point.  Mindy,
Magnus and DavidK helped to get the Wifi bridge working and the demo was quite
successful. There's a <a href="http://amirchaudhry.com/unikernel-arm-demo-fosdem">blog post</a> describing the event and the <a href="https://github.com/amirmc/fosdemo">repo</a>
is available with instructions on what to do. Several people expressed an
interest in summer projects so they were directed to the Pioneer Projects page.</p>
<h4>Bitcoin Piñata</h4>
<p>Yesterday, saw the release of the <a href="http://ownme.ipredator.se/">Bitcoin Piñata</a>, which is designed
to draw more attention to the OCaml TLS stack and unikernels. Amir wrote a
<a href="http://amirchaudhry.com/bitcoin-pinata">background post</a> to provide some context around it and both of these
appear to have spread very quickly over social media.  The challenge is to
break into a unikernel and recover the private key to a bitcoin address (and
then make off with the bitcoins) — Hence the name, Piñata.  If someone does
manage to take the coins, we should see the transaction in the <a href="https://blockchain.info/address/183XuXTTgnfYfKcHbJ4sZeF46a49Fnihdh">blockchain</a>.
Somewhat ironically, it seems that people have <em>added</em> some coins to the
address (albeit only a small amount). The Piñata is due to be up for about a
month, or until the coins are gone — the only reason for the time limit is due
to the maintenance burden of keeping the site up and dealing with issues (cf.
the site was subjected to a <a href="http://en.wikipedia.org/wiki/SYN_flood">SYN flood</a> the evening after it went
live.).</p>
<p>--</p>
<h4>AoB</h4>
<ul>
<li>The next call is scheduled for <strong>Wednesday, 25th February</strong> - Please add any
<a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">agenda items</a> you wish to discuss in advance and refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.
</li>
</ul>
|js};
      };
      {
        updated = {js|2015-01-28 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2015-01-28|js};
        permalink = {js|weekly-2015-01-28|js};
        description =
          {js|28th Jan 2014: OPAM 1.2, FOSDEM, new URL and 3.0 meta-planning|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Move to only OPAM 1.2
</li>
<li>FOSDEM demo
</li>
<li>TLS merge progress
</li>
<li>Turning on mirage.io?
</li>
<li>Planning for 3.0
</li>
</ul>
<p>Attendees:
Amir Chaudhry (chair), David Kaloper, Thomas Leonard, Jon Ludlam,
Hannes Mehnert, Richard Mortier, Dave Scott and Mindy Preston</p>
<h3>Notes</h3>
<h4>OPAM 1.2 support only</h4>
<p>ThomasG submitted a patch for the <code>mirage</code> tool to enable the switch to
OPAM 1.2 only. The patch should report an error and ask users to upgrade
OPAM 1.2. This matters as the upstream distros are still on OPAM 1.1 (e.g
Ubuntu).  we still need to decide what we want and it would be good to make
the patch user controlled (e.g user can override it if they want).</p>
<h4>FOSDEM demo</h4>
<p>Amir is heading to FOSDEM this coming weekend and has planned a demo around
serving a game from the cubieboard (via setting up a wifi access point).
Having issues with the wifi bridge but not sure what the problem really is.
Will need to get this working if there's to be a demo.</p>
<h4>TLS Merge progress</h4>
<p>This is waiting on DavidK, who has to review and merge TLS patches. Recently
been playing with a TLS unikernel on Xen and working towards a paper. Will
also be inviting people to break it soon.</p>
<p>Still have the entropy story to communicate and are starting with xentropyd.
Should be done in a few days with patch reviews.</p>
<p>ThomasL has a few other changes to the FLOW interface that need to be dealt
with (Error messages in a few places). There's an issue on mirage-dev before
there can be releases (<a href="https://github.com/mirage/mirage-dev/pull/52">mirage/mirage-dev#52</a>). Most components can be
released with the updates, but some need to be done together (e.g. TLS both
provides and uses the new interface). It would be possible to make all the
updates decoupled if preferred (e.g. first updating TLS to provide the new
interface, then releasing the new interface, then updating tls a second time
to use the new API).
There might also be more changes to libs/interfaces
that might be breaking so better to do this now. For example, there is the
<code>DEVICE.connect</code> change (<a href="https://github.com/mirage/mirage/pull/350">mirage/mirage#350</a>). Hannes mentioned that it not
yet 1.0 so shouldn't be too worried about breaking interfaces. no-crypto could
also use a release and TLS release will have to wait for things like error
reporting.</p>
<h4>Turning on mirage.io?</h4>
<p>Anil didn't make it to the call. Will need to wait until he's present before
this can be discussed.</p>
<h4>Planning for 3.0</h4>
<p>Amir proposed putting together a wiki page to collect all the issues and
thoughts for the next major release. The intent is to put together a stable
and visible plan so that we can better track progress, and make clearer
decisions. At the moment, we have relevant issues scattered everywhere but no
clear location by which we can chart progress.  Too much is inside people's
heads. Amir's happy to curate this page by bringing it up once a month on the
calls.</p>
<p>--</p>
<h4>AoB</h4>
<ul>
<li>
<p>ThomasL joining the Mirage core team and will be responsible for review and
patches merging across libraries (he's been doing this already).</p>
</li>
<li>
<p>The next call is scheduled for <strong>Wednesday, 11th February</strong> - Please add any
<a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">agenda items</a> you wish to discuss in advance and refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2015-01-14 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2015-01-14|js};
        permalink = {js|weekly-2015-01-14|js};
        description =
          {js|14th Jan 2014: Project name, 4.02.1 support, TLS on Xen and Error handling|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>&quot;Mirage OS&quot; or &quot;MirageOS&quot;?
</li>
<li>Pull OCaml runtime/bindings into packages / OCaml 4.02.1 support
</li>
<li>TLS on Xen
</li>
<li>Error handling in Mirage
</li>
<li>Planning for 3.0
</li>
</ul>
<p>Attendees: Amir Chaudhry (chair), Thomas Gazagnaire, David Kaloper,
Thomas Leonard, Jon Ludlam, Anil Madhavapeddy, Hannes Mehnert,
Richard Mortier, Dave Scott and Magnus Skjegstad</p>
<h3>Notes</h3>
<h4>&quot;Mirage OS&quot; or &quot;MirageOS&quot;?</h4>
<p>We need to settle on how we refer to the project and then be consistent in its
use. In the early days it was referred to variously as 'Mirage', 'Open
Mirage', 'Mirage OS' and 'MirageOS'.  When we became a
<a href="http://lists.xenproject.org/archives/html/mirageos-devel/2013-01/msg00081.html">Xen Incubated project</a>, we had a brief discussion about the
'official' name (for press releases etc) and we settled on 'Mirage OS'.
However, we haven't always been consistent with the way we use the term.  So
far all the official materials such as new releases, have referred to
&quot;Mirage OS&quot; (with a space), whereas on Twitter and our slides we see 'MirageOS'
(without a space) being used. We should stick to only one of these.</p>
<p><strong>Why does this matter?</strong> - As we attract more users and raise more awareness,
being consistent in how we represent ourselves will begin to matter more. The
name is just one of these aspects and even though it may seem trivial, it <em>is</em>
the name of the project we're discussing here. At this stage, there should be
no confusion about how it's written.</p>
<p>After a brief discussion, it's clear that most of the team are less concerned
about the exact choice rather than being consistent. Only Amir and Anil had
opinions to share and they both proposed that we use 'MirageOS' from now on.
The reasons are that users have independently used this form in tweets and
posts, it is easier to search for, and it's better to go with the flow as we
still can.</p>
<p>Overall, we unanimously decided on two things: (1) to move forward with
'<strong>MirageOS</strong>' as the official name of the project and (2) be much more
consistent in using it on our written material.</p>
<p>In terms of practical steps, Amir will update things as he sees them on the
website and written materials. Anil suggested that we may start using a
different domain for the site too (<a href="http://mirage.io">mirage.io</a>).</p>
<h4>OCaml 4.02.1 support</h4>
<p>Anil's working on this (<a href="https://github.com/mirage/mirage-platform/pull/115">mirage/mirage-platform#115</a>) and thanks ThomasL
for his patches. Hasn't had time to merge yet but will do soon. Might not
rebase it and hopes that won't be too much of a problem for anyone.  In
general we shouldn't do that but this one would take a while to rebase and
would prefer to merge quickly.  The upcoming functor inline patch will a have
big performance boost but we should clearly state that we're not dropping
support for 4.01 though. The patch applies cleanly on trunk (it's currently in
a branch) and the work already done to port Mirage to 4.02.1 should mean that
any additional changes we need to make are trivial.</p>
<p>In addition, we should be careful to maintain support for OPAM 1.1 or at the
very least, warn the user if something won't work with v1.1. Many of the
upstream distros are still on this version and silent failures result in
confusion and frustration. There are also an increasing number of libraries
going for 4.02.1 support only, but it would be better to try and maintain
support for 4.01 as long as possible (for the same reasons as above).</p>
<h4>TLS on Xen</h4>
<p>ThomasL started an <a href="http://lists.xenproject.org/archives/html/mirageos-devel/2015-01/msg00066.html">email thread</a> about getting the TLS stack
working on Xen.  He's submitted a number of patches for review to different
libraries and the changes needed are:</p>
<ol>
<li>Add generic error handling for FLOWs, so we can propagate errors reliably.
</li>
<li>Fix the page alignment requirements for Netif.
</li>
<li>Add TLS support to conduit.
</li>
</ol>
<p>TLS now works if you apply lots of patches and works pretty well (half the
speed of not using TLS — which is good!).
Issue now is how to merge without breaking things as
certain module signatures change.  There was some discussion of functorising
and the knock-on effect this would have but overall it seems like we can keep
this as an interface-level problem.</p>
<p>There's still the question of getting entropy in Xen. We need several ways to
do this and <a href="https://github.com/mirage/xentropyd">xentropyd</a> is the one way we currently have if dom0 cooperates.
This is fine for our infrastructure as we control dom0 (on cubieboards and
x86).  However, we also need to be able to gather entropy in other ways for
deployments to third-party infrastructure. The actual code for getting entropy
is straightforward but how it is then composed needs to be considered.</p>
<p>In general, there's reluctance to release the TLS stuff until there's an
entropy story so DavidK may take a look at the options.  In the meantime,
we're happy to have an intermediate patch that <em>only</em> uses xentropyd and we
can then use it for websites hosted on our own infrastructure.</p>
<h4>Error handling in Mirage</h4>
<p>ThomasL has been working on this. To make conduit <code>FLOW</code> wrap the TLS flows we
need a way to propagate the errors sensibly, so has added a type to <code>FLOW</code>
that can do this. It might be nice to have an algebraic data type to describe
an error type, or if we wait a few months until we switch to 4.02.1, then we
can just use <a href="https://sites.google.com/site/ocamlopen/">Open Types</a>
(see additional comment from ThomasL below).
The nice thing with current patch is
that you don't lose the error type. It works well but there's an issue
regarding merge order, e.g. TLS and conduit, where they use it but also
provide it. Easiest way would be to adjust the dependencies and push things to
<a href="https://github.com/mirage/mirage-dev">mirage dev</a> and then co-ordinate the releases.  It then becomes
straightforward to get things merged into the main OPAM repository.</p>
<p>Another comment was that it might make sense to have the err handling in
<code>DEVICE</code> and have it everywhere but that would touch about 20 repos, so not
likely to do that just yet.</p>
<p>[Thomas Leonard additionally sent the following comment:]</p>
<p>&quot;We already have algebraic data types for errors, which is good if you want to
match on a particular error from a particular concrete implementation (e.g.
<code>FAT_index_corrupted</code> or something). In theory, this is slightly more correct
than using exceptions because error returns don't propagate automatically. e.g.
if you get <code>Refused</code> from TCP then you know it was the TCP connection itself
that was refused, not some other refusal from another function TCP called that
happened to throw the same exception. In practice, this doesn't seem to be a
problem except when using very generic exceptions like <code>Not_found</code>.</p>
<p>I guess using open types means we can list some common errors in the
interfaces but have implementations provide more, which may be useful but
doesn't solve my problem: when you <em>don't</em> want to handle specific exceptions
we need a way to get a human-readable string for display (and this is the
common case).</p>
<p>So:</p>
<ul>
<li>
<p>Replacing error codes with exceptions (which I proposed originally) would
work most of the time and would simplify the code greatly, although it's
slightly less strict than the current system. On the other hand, the current
system encourages people to throw away errors (look at any <code>main.ml</code> for
examples!) so I'm sure it would be an overall improvement. It would require
API changes everywhere, however.</p>
</li>
<li>
<p>Adding an <code>error_message</code> function (which my current patches do) means that
people can still handle errors as before when needed, but can also always get
a human-readable string too, so there's never any excuse for throwing away
diagnostic information. You do still need to write error handling code
everywhere when you just want to propagate exceptions, though, which clutters
the code, and old code will continue to discard useful information for some
time to come.&quot;</p>
</li>
</ul>
<h4>Planning for 3.0</h4>
<p>Amir would like to start putting together a plans for a 3.0 release but there
wasn't time to begin discussions on this call. Will schedule it for next time
and keep it as a recurring item once every other call (i.e once a month).</p>
<p>--</p>
<h4>AoB</h4>
<ul>
<li>
<p>Need to get <strong><a href="https://github.com/MagnusS/jitsu">Jitsu</a></strong> ready in next couple of weeks. Need libxl patches
from DavidS/JonL and they're probably ok (will submit as an RFC). There's also
a desire to calculate timings from HTTP req to serving the response so shared
some ideas about how best to do this. Amir also has a use-case he wants to
deploy and write about.</p>
</li>
<li>
<p>The next call is scheduled for <strong>Wednesday, 28th January</strong> - Please add any
<a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">agenda items</a> you wish to discuss in advance and refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2014-12-10 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2014-12-10|js};
        permalink = {js|weekly-2014-12-10|js};
        description =
          {js|10th Dec 2014: Entropy, Tracing docs, OSX backend, IPv6 and Projects|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Entropy progress
</li>
<li>Tracing progress
</li>
<li>Xen C stub compilation progress
</li>
<li>MacOSX vmnet support
</li>
<li>IPv6 Merging
</li>
<li>Pioneer Projects
</li>
</ul>
<p>Attendees: Amir Chaudhry (chair), Thomas Gazagnaire, Masoud Koleini,
Thomas Leonard, Anil Madhavapeddy, Hannes Mehnert, Dave Scott,
Magnus Skjegstad and Carlos</p>
<h3>Notes</h3>
<h4>Entropy for Mirage/TLS</h4>
<p>Dave has been working on this. Essentially we need a daemon on dom0 to provide
a small amount of entropy. This is at the top of his list and it will be done
before Hannes gives a talk on the 27th (at <a href="https://events.ccc.de/congress/2014/Fahrplan/events/6443.html">CCC</a>).</p>
<p>Once we have entropy device in Mirage, it is fed into the Fortuna part of
<code>nocrypto</code> and then we get random numbers. What it doesn't expose is the
random device. We also have possibility to get entropy from multiple sources.
Things are in place for that already so perhaps we should deal with each of
these as separate issues.</p>
<p>On a related note, Anil merged Hannes patches and cohttp on Unix and it all
works without a hitch. Doesn't do server certificate verification. Is
implementing trust on first use for the XMPP client. There are issues related
to both these points on the <a href="https://github.com/mirage/ocaml-conduit/issues">conduit library repo</a>.</p>
<h4>Xen C stub compilation</h4>
<p>Mirage will now only link C-stubs on Xen if you explicitly mark it in OCaml
meta file. A number of releases have happened and we're now ready to package
up the TLS things.</p>
<p>Need to fork zarith and gmp libraries and thinking that we'll need to install
dummy ocamlfind packages for TLS libraries to use. That might involve adding
depext things to the mirage tool. Will have to feel our way through this to
figure out the best approach.</p>
<h4>Tracing Progress</h4>
<p>Lots of things have been merged. A number of libraries now depend on
<code>mirage-profile</code>, so it can be used in code without having to add an
additional dependency. This way you can get profiling from libraries out of
the box. Will soon be working on documentation for the website to explain how
to use it all. In the meantime we should work work on getting the lwt patched
upstreamed.</p>
<h4>MacOSX vmnet support</h4>
<p>Anil was working on using the vmnet support that's available (but undocumented)
on Mac OSX Yosemite (see the <a href="http://lists.xenproject.org/archives/html/mirageos-devel/2014-12/msg00004.html">mailing list thread</a>). Anil is
still poking thorough traces to find various interfaces. We also think it does
IPv6 but not quite sure.  As a result, two new libraries have been released,
<a href="https://github.com/mirage/ocaml-vmnet">ocaml-vmnet</a> and <a href="https://github.com/mirage/mirage-net-macosx">mirage-net-macosx</a>.  It would be good to get feedback
from others on their use of this and there have been no reported problems at
all so far.  Recently released Mirage 2.1.1 will default to Unix network stack
on Macs prior to Yosemite.</p>
<h4>Merging IPv6</h4>
<p>Nic is currently in Argentina but would like to merge this asap.  Will
probably see some breakages can fix them up as things change. These will be a
sequence of small changes but hopefully wouldn't affect too many people. Anil
will look at these and may be able to merge this in the next couple of weeks.</p>
<p>If anyone has access to IPv6 networks it would be great to hear feedback and
reports.</p>
<h4>Pioneer Projects</h4>
<p>We could do with expanding the number of <a href="https://github.com/mirage/mirage-www/wiki/Pioneer-Projects">Pioneer Projects</a> we have
listed. Even if people have simple ideas, it would be useful to get them added
to the wiki page.  We especially need the '1-star' projects, which can help
onboard newcomers. Amir may add some tasks that cross over from ocaml.org
(such as a pure OCaml implementation of Planet). Please do add what you can!</p>
<p>--</p>
<h4>AoB</h4>
<ul>
<li>
<p>Masoud and Carlos joined the call and they're working on an <strong>Openflow</strong>
implementation (1.3 and 1.4). Currently fixing things before adding more
functionality.  At the moment there's an openflow switch but would also like
an openflow controller.</p>
</li>
<li>
<p>The next call is scheduled for <strong>Wednesday, 14th January</strong> - Please add any
<a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">agenda items</a> you wish to discuss in advance and refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
<li>
<p><strong>Happy Holidays to all!</strong></p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2014-11-26 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2014-11-26|js};
        permalink = {js|weekly-2014-11-26|js};
        description =
          {js|26th Nov 2014: Entropy, Config modularity, IPv6 stack and Pioneer projects|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Configuration Modularity
</li>
<li>Entropy for Mirage/TLS
</li>
<li>Merging IPv6 and STACKV4
</li>
<li>Conduit lives!
</li>
<li>Pioneer projects
</li>
<li>Irmin update
</li>
</ul>
<p>Attendees: Amir Chaudhry (chair), Thomas Gazagnaire, Thomas Leonard,
Anil Madhavapeddy, Richard Mortier, Hannes Mehnert, Nicolas Ojeda Bar,
Dave Scott and Magnus Skjegstad</p>
<h3>Notes</h3>
<h4>Configuration Modularity</h4>
<p>There's been a <a href="http://lists.xenproject.org/archives/html/mirageos-devel/2014-11/msg00094.html">discussion about configuration modularity</a> on
the mailing list and ThomasG will be looking at this for the medium term. This
isn't particularly urgent but we do need to have an idea of what to do. As a
first step, ThomasG will discuss this with Mort when he's next in Cambridge,
with the aim of getting some thoughts written down for further discussion.</p>
<h4>Entropy for Mirage/TLS</h4>
<p>Hannes <a href="http://lists.xenproject.org/archives/html/mirageos-devel/2014-11/msg00146.html">summarised the discussions</a> on the email thread so far.
There are several scenarios depending on whether we have any control of dom0
or not. For the cases where we don't, we'll have to come up with another way
of getting entropy into the unikernel.  We could get entropy in via Xenstore
or by using vchan. These are of equivalent difficulty to implement and Dave
has been looking at them. Dave's currently tidying up Xenstore library so it's
easier to write and is adding unit tests too. Will also be looking at the ring
code too. Could use these libraries to make a Xen randomd. In general, there's
reluctance to use Xenstore as the solution since we're not comfortable putting
secret entropy through it — much better to use vchan.</p>
<p>ThomasL did get TLS working on the cubieboard recently (as did Hannes at ICFP).</p>
<h4>Merging IPv6 and STACKV4</h4>
<p><em>See also the <a href="https://mirage.io/wiki/weekly-2014-11-12#IPv6patchset">notes from the last call</a>.</em></p>
<p>Anil has been merging some of <a href="https://github.com/mirage/mirage/pull/319">Nic's changes</a> into his trees.
There has been a fair amount of renaming but for the most part, it shouldn't
be that difficult to update other code that uses the stack — things may simply
need to be recompiled (and conduit makes parts of this easier).</p>
<p>Would really like to be able to test the stack from Mac OSX. Anil is adding
bridging support to tuntap (which is available in Yosemite). There's no
documentation to follow so it's taken some hacking but it is now attaching to
an interface and seems to work. Is wondering about building a Mirage fetcher
over IPv6.</p>
<p>In terms of next steps, we should be able to merge what Anil is doing now and
then deploy on the mirage-www site!  Mort reminded everyone that we would also
need to update Mirage skeleton to remove the STACK example and update any
others (and perhaps a few pages on the website too).</p>
<h4>Conduit lives!</h4>
<p>Conduit was released and Anil assures us that it's awesome. People have been
using it and are reporting issues that Anil is looking into. These seem to be
related to SSL and he'll deal with them.</p>
<h4>Pioneer Projects</h4>
<p><em>See also the <a href="https://mirage.io/wiki/weekly-2014-10-28#Miragetaskslistfornewcomers">notes from an earlier call</a>.</em></p>
<p>We previously discussed the idea of a list of possible jobs/projects for
newcomers to Mirage. Amir came up with a name for these (Pioneer Projects) and
Anil started putting together a list, which you can see on the
<a href="https://github.com/mirage/mirage-www/wiki/Pioneer-Projects">mirage-www wiki page</a>. If you've worked on an aspect of Mirage and
can recognise a project that could go on this list, please do add it. Don't
worry about defining difficulty levels as we can examine that after we have a
collection of things for people to browse through.</p>
<p>--</p>
<h4>AoB</h4>
<ul>
<li>
<p><strong>Irmin Update</strong> - If anyone has feedback on the new API, ThomasG would
grateful to hear it. He's now thinking of encryption for Irmin so thoughts on
that are also welcome. Encrypting the backend is of interest and should be
easier with new API. It may be easier to evaluate the new API after trying to
build a few command line tools (e.g. logging).</p>
</li>
<li>
<p>Using <strong>Irmin instead of crunch</strong> - Mort heard rumours that Irmin could be
ready to use instead of Crunch.  Mort's website is quite heavy as it contains
a lot of PDFs he needs to serve. Using Irmin may be possible but ThomasG wants
to get to a point where Irmin should just be able to clone a repo that
contains the assets. Irmin could even watch the repo and if there are new
events, then pull them in. There are a number of other things to complete
before we can get to this point though. Those things are (1) clibs support in
OPAM, (2) the git smart http protocol in <code>ocaml-git</code> and (3) TLS in
<code>mirage-cohttp</code>.</p>
</li>
<li>
<p>Anil was going to <strong>modify crunch</strong> to get it to do git-clone if the
directory doesn't already exist. There weren't any objections to this.</p>
</li>
<li>
<p>The next call is scheduled for <strong>Wednesday, 10th December</strong> - Please refer
to the <a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2014-11-12 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2014-11-12|js};
        permalink = {js|weekly-2014-11-12|js};
        description =
          {js|12th Nov 2014: TLS, IPv6, OCaml 4.02.1, Library requests and Xenstore|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Review previous notes
</li>
<li>mirage-dev releases (and future thereof)
</li>
<li>TLS integration into conduit
</li>
<li>IPv6 patchset
</li>
<li>Xenstore TNG
</li>
<li>4.02 support
</li>
<li>mirage-vagrant-vms
</li>
<li>mirage-profile status
</li>
<li>Preliminary thoughts for 3.0
</li>
</ul>
<p>Attendees: Amir Chaudhry (chair), Thomas Gazagnaire, Thomas Leonard,
Jon Ludlam, Anil Madhavapeddy, Hannes Mehnert, Richard Mortier,
Nicolas Ojeda Bar, Mindy Preston, Dave Scott, Magnus Skjegstad and Nik Sultana</p>
<h3>Notes</h3>
<h4>Future of mirage-dev</h4>
<p>Releases are done! Yay!</p>
<p>Have yet to update the website to remove the refs to <code>mirage-dev</code> in the
installation instructions. It would be great if someone could do this.</p>
<h4>TLS integration into conduit</h4>
<p>Not keen to fix <code>lwt-ssl</code> bindings. Would be keen to get people to use TLS
stack and it would be good to have environment variable to switch between
stacks. Perhaps import it in now but not as the default and later make it the
default.</p>
<p>We should begin serving the site over https using the unix backend (Mirage
doesn't serve https yet). Actually, we should merge in the
<a href="https://github.com/mirage/mirage/pull/319">IPv6 stack</a> and then serve that.  For example we could start
doing this with one of our live deployments and then roll it out elsewhere e.g
start with blobs.openmirage.org</p>
<p>Can continue the <a href="https://github.com/mirage/ocaml-conduit/pull/23">thread on the conduit repo</a> and Hannes is
welcome to add more debugging etc to conduit.</p>
<h4>IPv6 patchset</h4>
<p>Nicolas been working on this and it touches many different parts of Mirage.
There's an <a href="https://github.com/mirage/mirage/pull/319">RFC and discussion thread</a> for those who wish to keep
up.</p>
<p>Nicolas is current modifying the V2 types of Mirage and Dave says we could use
both but have to pick one from within. It's not clear to people how we use V1
and V2.  V1 became stable with the Mirage 2.0.0 release so V2 is now the
development version. In other words, for stable users we want V1 to be used
and for developers we want to use the V2 interface.  This will need some
clarification to avoid confusion.</p>
<p>Want to fix networking in the next release and are thinking of getting rid of
the StackV4 interface entirely.</p>
<p>For now, Nicolas can sync V1 and V2 in Mirage and get a release and anything
modified is in V2, then we can set a flag for dev versions. It's worth noting
that in OPAM 1.2 we can select specific versions of packages with constraints
on the command line (e.g opam install mirage &gt; 2.0.0).</p>
<h4>Xenstore TNG</h4>
<p><em>[TNG → The Next Generation -- in case you were as confused
as I was. AC]</em></p>
<p>New version of Xenstore is coming that includes the work James Bielman did on
adding Mandatory Access Control (MAC).  Also want to improve the client
interface and version control using Irmin. Some of the changes will be
disruptive but we can take care over this.</p>
<p>It would be useful to have a functor to xenstore (i.e an abstract way to
read/write, which we can use in conduit and Jitsu etc). In addition, the UI
needs improvement as using it feels like ping pong.</p>
<h4>4.02.1 support</h4>
<p>Mirage currently only works on 4.01.0 but the latest OCaml compiler version is
4.02.1, (<a href="http://ocaml.org/releases/4.02.html">released in October</a>). There are a number of
improvements we can benefit from so we should work on this.</p>
<p>Anil has already made a start on it but may want to hold off due to the number
of outstanding patch reviews. Supporting 4.02.1 means porting the OCaml
runtime out as a separate C-lib. This can then benefit from opam constraints
(i.e pull down the appropriate runtime based on the compiler). We've done this
well for miniOS and the ocaml-dev team would also be interested in this
approach.</p>
<p>This is probably about a week's worth of work and if anyone has time to look
at it, please do email the list. It would also be good to be benchmarking this
at some point.</p>
<h4>mirage-vagrant-vms</h4>
<p>This has worked worked for Dave and Mort. The plan is to have it running for
testing and then also be able to add other IDEs etc. If anyone wants to look
at vagrant clouds and go from code to binaries, that would be quite useful. We
would have to host the binaries, which is fine as we do that currently. We
just need to provide a URL, description and some metadata and can point back
to blobs. Can advertise the vagrant thing at an upcoming conference
(<a href="http://operatingsystems.io">operatingsystems.io</a>).  The repo is at
<a href="https://github.com/mirage/mirage-vagrant-vms">mirage/mirage-vagrant-vms</a>.</p>
<p>Jon uses the vagrant cloud a lot but has not looked at Mirage yet. Has boxes
of XenServer if anyone wants to try those. Also has scripts that automatically
update version numbers and can share this with Nik.</p>
<h4>mirage-profile status</h4>
<p>ThomasL sent a message to list with a <a href="http://lists.xenproject.org/archives/html/mirageos-devel/2014-11/msg00044.html">status update</a>. It's
now in <code>mirage-dev</code> but there is nothing depending on it. Will send PRs to
platform, TCPIP and so on.  Mindy is trying out some tracing at the moment.
Also looking at GC and there may be some stuff to upstream as it may be
helpful to know when GC starts and how long it lasts. At the moment just
checks with registered callback so doesn't change OCaml interface.</p>
<h4>Preliminary thoughts for 3.0</h4>
<p>Amir is keen that we start getting ideas down for what Mirage 3.0 will look
like and start working our way towards it. Would prefer that we time things
well so that libs can be upstreamed to opam proper at the same time we
announce (i.e not have things in dev or that require pins).</p>
<p>Thoughts include a working Javascript backend, can have things working with
iOS and Android at that point. Could consider this the 'multiscale release' as
we're setting ourselves up to be able to work with multiple backends. Amir
will bring up this agenda point every few calls to see where thoughts are.</p>
<p>--</p>
<h4>AoB</h4>
<ul>
<li>
<p><strong>Library request!</strong> ThomasG and Anil have built <code>ez</code> versions of Daniel
Bunzli's libs, such as <a href="http://opam.ocaml.org/packages/ezxmlm/ezxmlm.1.0.1/">ezxmlm</a> and <a href="http://opam.ocaml.org/packages/ezjsonm/ezjsonm.0.3.0/">ezjsonm</a>, which are less flexible but
provide more convenient functions. They'd like to have an <code>ezcmdliner</code>, which
takes notions of terms and does <code>unix.get-env</code>. It would let them replace
adhoc environment parsing in configuration and let them assemble an
environment.  One of the interpretations would be a dialog-based interface and
could do bash-shell completion. This way, <code>mirage configure</code> can drop you into
a UI to select the things you wanted. It should be a simple library and only a
couple of days work as it's just a front end to <code>cmdliner</code> itself. After some
discussion, it seems that Dave might have pieces of this so he'll dig it out
and have a look but others are very welcome to dive in.</p>
</li>
<li>
<p>Change of call day: After some brief discussion, it seems that <strong>Wednesday</strong>
is actually better for most people so we'll switch the call day accordingly.
Same time, different day.</p>
</li>
<li>
<p>With the above change of day in mind, the next call is scheduled for
<strong>Wednesday, 10th December</strong> - Please refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2014-10-28 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2014-10-28|js};
        permalink = {js|weekly-2014-10-28|js};
        description =
          {js|28th Oct 2014: Docker tests, mirage-dev, tracing and onboarding newcomers|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Review notes from last time
</li>
<li><code>is-mirage-broken</code> and Docker
</li>
<li><code>mirage-dev</code> releases
</li>
<li>Tracing
</li>
<li><code>mirage-tc</code> release
</li>
<li>(good?) use of custom configure and make scripts
</li>
<li>Mirage task list for newcomers
</li>
</ul>
<p>Attendees: Amir Chaudhry (chair), Thomas Gazagnaire, Thomas Leonard,
Anil Madhavapeddy, Hannes Mehnert, Mindy Preston, Dave Scott,
Magnus Skjegstad and Nik Sultana</p>
<h3>Notes</h3>
<h4>is-mirage-broken and Docker</h4>
<p>Nik Sultana working on a new tool aims to make builds of Mirage applications
on various operating systems, using the Docker images (see the
<a href="https://github.com/mirage/is-mirage-broken/">repo</a>). This is a continuation of looking at Bash scripts.
It just runs a cron job everyday and lets us know if we've broken any
interfaces. Currently trying to make it colourful or use images (suggestions
welcome!).</p>
<p>At the moment we only have two repos being tested this way so it would be good
if people added their own.  For example, the TLS stack would be useful —
Hannes can do this (and may also add the XMPP stuff).</p>
<p>The logs are in a <a href="https://github.com/mirage/is-mirage-broken/blob/master/logs/README.md">README file</a> and you can see (at time of the call)
that mirage-skeleton and mirage-www both build on Ubunty Trusty (with OCaml
4.01.0) but not the others, as yet.</p>
<p>The aim is to merge the output to <code>mirage-www</code> at some point but we should
also close the loop somehow by notifying people (maybe send emails).
This is sort of like TravisCI but instead the builds happen on a fixed
schedule (via cron), rather than on each pull request.  This helps to surface a
different set of issues. Should look at how to close the loop over the next
few weeks (perhaps getting emails working first).</p>
<h4>mirage-dev releases</h4>
<p>Dave was going do these releases but found more bugs, which got in the way. On
the positive side, <code>mirage-dev</code> is getting better and better and now the TLS
work is added too.</p>
<p>Packaging metadata is the most awkward stuff which affects the build.
Thomas is adding OPAM files to the projects he's making and using the pin and
publish workflow, which is an improvement (NB: OPAM 1.2 is released now, which
makes this available to everyone).</p>
<p>We should switch all things over to OPAM 1.2 workflows but should take note of
any blog posts/docs that need to be updated (brief segue into blog aggregation
— see AOB).</p>
<h4>Tracing</h4>
<p>ThomasL wrote a <a href="http://roscidus.com/blog/blog/2014/10/27/visualising-an-asynchronous-monad/">blog post about Mirage tracing</a>. Everyone was in
awe. When the work is finished, we should have a post on the Mirage website.</p>
<p>Some questions about when people can start using it. Would be great to get
more feedback from others trying it out. At the moment it requires lots of
pins and there was a thought about adding it to <code>mirage-dev</code> but we really
should flush the queue of releases before adding more things.</p>
<p>If anyone wants to use it to explore the TCP stack, that would be very useful
ThomasL already looked at UDP). Maybe Nik can think about this, for example
looking at the behaviour of our stack during ping flood (currently we crash!).
In general, looking at the network stack is a good way forward.</p>
<p>Mindy will try out the tracing if she can reproduce the memory leaks she's had
on her unikernel blog (it does reboot fine). It's not clear if that issue is
related to the network stack or the K/V store (crunch). In any case, Mindy
will write up what she finds (and we should be surprised if it turns out that
crunch does <em>not</em> have problems). In addition, it'll be interesting to see
what issues crop up if traces last more than a few seconds. Let's see what
happens.</p>
<h4>mirage-tc release</h4>
<p>ThomasG has pulled out <code>mirage-tc</code> from Irmin.  Mirage Type-classes is a set
of functors and combinators to pretty-print (using sexplib), to convert to and
from and JSON and Cstruct buffers. There are some examples in the Readme on
the <a href="https://github.com/mirage/mirage-tc">mirage-tc repo</a>.</p>
<p>It's already released in OPAM and could imagine it being useful for the TLS
stuff (but that may introduce a dependency on <code>mirage-tc</code>).
Feedback is welcome!</p>
<h4>custom configure and make scripts</h4>
<p>ThomasG debugged a bunch of stuff and found that make and config scripts are
doing far too much magic. It would be good to have some consistent way to do
this ... perhaps something like a tool for consistently describing a project!
<em>(sidenote: For the uninitiated this was a reference to <a href="https://github.com/samoht/assemblage">Assemblage</a>, which
ThomasG and Daniel Bünzli have been working on but is not yet ready for
users)</em>. Unfortunately, this means dealing with build systems which is usually
complicated.</p>
<p>In general, config is a substantive and unsolved problem. Lots of breakages
and issues because of optional dependencies (depopts). To try and help with
this this, we've been removing depopts and replacing with virtual packages.
These issues are cropping up just because the amount of code and number of
libraries is growing. We do need a more consistent DSL for this.</p>
<p>There's a particular problem with <code>pkg-config</code> being a is bit broken on Mac
OSX but it's better to try and fix that than do anything else (already been
pushing fixes). Anil will fix GMP and pkg-config and notes that Yosemite
latest release of OSX) has bridging support, which means not needing tuntap
modules any more. This is very handy.</p>
<h4>Mirage tasks list for newcomers</h4>
<p>Lots of people have been asking about 'junior jobs' — we really don't
like this term so if you have a better one please do
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">suggest it on the list</a>.</p>
<p>This came up again in the OPW rounds and Mirage is now an even bigger (more
daunting?) project. There are actually lots of tasks like this available so
Anil will collate them and make them visible to others.  Suggestion of a wiki
page like the kind the <a href="https://ocamllabs.github.io/compiler-hacking/">Compiler Hacking sessions</a> maintain
could be good(<a href="https://github.com/ocamllabs/compiler-hacking/wiki">link</a>). This works very well for them, and they
have expertise and time ratings for each task, but it does take regular
maintenance.</p>
<p>Whether people are familiar with OCaml also makes a difference as there may be
multiple learning curves involved so a straight-forward rating system is
unlikely to work. Mindy mentioned that when she was looking at the project,
she picked an area that she knew something about (networking), which made it
easier to pick up what was going on.</p>
<p>This led to the idea that we should split out the possible tasks/subprojects
by some kind of functional area so that newcomers can pick something they're
already familiar with e.g networking stack, file systems, hypervisor etc. This
seems like a sensible structure to present and neatly points people to
specific sets of libraries so they don't have to be overwhelmed with the
project as a whole. Anil will put something together along these lines. Mort
really wants to work on the training material over the next months so this
will be useful. Mindy also suggested adding things to <a href="https://openhatch.org">OpenHatch</a>, which is
one mechanism people search for FOSS projects to contribute to.</p>
<p>Amir raised the prospect of what we want from Mirage 3.0 and that we should
plan this with enough time. One interesting suggestion is having a fully
working Javascript backend. Will raise this next time to capture people's
thoughts. Of course, we do still need to get all the things for 2.0 finished
first, including the TLS stack and deciding on C library handling.</p>
<p>--</p>
<h4>AoB</h4>
<ul>
<li>
<p>TLS on Xen: Trying to upstream things to zarith but could just patch in OPAM
repo instead? Separate package for things is sometimes better as it helps with
debugging.</p>
</li>
<li>
<p>Thoughts on folding content into the openmirage.org site. Could run syndic
in unix and commit the results. Could run this on the same place as the cron
job. Amir to try a manual run of syndic with people's blogs posts, taking the
code from OCaml.org.</p>
</li>
<li>
<p>Next call is scheduled for <strong>12th November</strong> - Please refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2014-10-14 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2014-10-14|js};
        permalink = {js|weekly-2014-10-14|js};
        description =
          {js|14th Oct 2014: Vchan, Conduit, library release plans and funky graphs.|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Vchan/Conduit code review
</li>
<li><code>mirage-dev</code> releases
</li>
<li>SSL/XMPP
</li>
<li>TLS on Xen <a href="http://lists.xenproject.org/archives/html/mirageos-devel/2014-10/msg00001.html">post on mailing list</a>
</li>
<li>Irmin Update
</li>
<li>Tracing
</li>
</ul>
<p>Attendees: Amir Chaudhry (chair), Thomas Gazagnaire, David Kaloper,
Thomas Leonard, Anil Madhavapeddy, Hannes Mehnert, Richard Mortier, Dave Scott
and Gregory Tsipenyuk</p>
<h3>Notes</h3>
<h4>Vchan/Conduit code review</h4>
<p>Conduit stuff is fairly complex but works in all combinations, (OSX, Linux
Unix and on Xen). Some of the code is a bit awkward but the messiness is
contained (i.e. it doesn't extend outside conduit). Can establish conduits
across domains (some things are untested).</p>
<p>There happens to be an annoying dependency problem. ThomasG notices that you
need a tcp stack with vchan but there's a dummy stack in place for this (dummy
functors). For now it's easier to functorise over the stack but maybe we don't
need a dummy stack, just a dummy ethernet device.</p>
<p>Both ThomasG and Anil aren't happy with current design but it's good to have
something (as opposed to nothing)!</p>
<h4>mirage-dev releases</h4>
<p>The v2 release will freeze v1 (so it will not change) and v2 is the (stable)
development release.  All the vchan things are in now and stable. Overall, we
still need to clean up odds and ends and start cutting releases.</p>
<p>Need someone to set up a cubieboard that will do builds of everything (via
cron jobs). Suggestions that we can publish the output to doesmiragework.com
so that it's obvious when things are not working properly.</p>
<p>Anil can only test once back but in the meantime Dave can cut releases — but
would like to have a list somewhere to see what should be worked on. Anil
mentioned that <code>opam list --depends-on --rec</code> will show what's broken.</p>
<p>Dave will do versioning and checksums on the mirage-dev repo — i.e cut
releases on our opam remote to begin with, but not push to the upstream opam
remote just yet.</p>
<h4>SSL/XMPP</h4>
<p>Hannes did the port for <code>no-crypto</code> and TLS and it works on Unix. There are
things in XMPP that can be pulled out into separate library and Conduit should
be able to help with this.</p>
<p>Also implemented client authentication in TLS which will be useful for
startTLS for IMAP (if server supports it). Now have IMAP for Android and maybe
on iOS (but that one still has some bugs). Anil has some outstanding
change sets to remove certain dependencies (e.g batteries).</p>
<p>repo: <a href="https://github.com/hannesm/xmpp">https://github.com/hannesm/xmpp</a></p>
<h4>TLS on Xen</h4>
<p>Hannes recently <a href="http://lists.xenproject.org/archives/html/mirageos-devel/2014-10/msg00001.html">wrote to Mirage list</a> on where to put the C code
(libgp etc) and other small symbols we need. Suggestion from others is perhaps
get it working end-to-end without stack protection first. What we don't have
is a sense of where to package things up and it's a good idea to have one
switch for everything.  Concurrent installation keep us honest and reduces the
likelihood of errors. This does raises an issue as we share the object files
so if we drop stack protection on xen we have to drop it on unix.</p>
<p>Maybe make <code>no-crypto-unix</code> and <code>no-crypto-xen</code>? This was suggested on the
list but leads to question of packaging. There will need to be packages for
<code>xen</code> and <code>-unix</code> for the whole dependency chain (cross-compilation would be
better solution). This might have effects on ctypes.</p>
<!--
Hannes, wants to take a shot at ocamlfind [and I missed the rest of this]
-->
<h4>Irmin Update</h4>
<p>ThomasG still removing the dependency on <code>core_kernel</code>. Currently looking at
<code>ogit</code> to simply dependencies and then in Irmin. This is fairly
straightforward but rather dull and it should be done by the next call
(two weeks).</p>
<h4>Tracing</h4>
<p>There's been some <a href="http://lists.xenproject.org/archives/html/mirageos-devel/2014-10/msg00023.html">extensive discussion on the list</a> about tracing
(see the <a href="https://github.com/talex5/mirage-tracing">repo</a>). Can trace interaction between Lwt threads. Can race
unikernels and create graphs. There's a link in the thread and where
exceptions have been thrown. At the moment it just numbers threads 1, 2, 3.
ThomasG has played with it and it seems very useful.</p>
<p><img src="http://test.roscidus.com/static/block-read-mirage-x86.png" alt="block read tracing" /></p>
<p>Mort mentioned that it might be useful to relate mapping between IO and
threads as that would help us understand things across unikernels. This is one
of the things that Magpis did and he'll will <a href="http://lists.xenproject.org/archives/html/mirageos-devel/2014-10/msg00045.html">email the list</a> with
links to relevant work.</p>
<p>Some questions were raised about the visualisation itself (e.g the white line!)
Green line is when one thread resolves and raises another, blue line is when
one thread reads value from another. Almost want to see this by module.</p>
<p>ThomasL will write a blog post to help people interpret these diagrams and the
next step is to make the whole thing easier to use and make it a separate
library. Also pointed out that it was surprisingly difficult to get it to go
fast in HTML canvas as changing colours is slow.  Ended up having to render
this colour by colour.</p>
<p>Links:</p>
<ul>
<li>trace: <a href="http://test.roscidus.com/static/html_viewer.html?t_min=8249.530963&amp;t_max=8249.534574">http://test.roscidus.com/static/html_viewer.html?t_min=8249.530963&amp;t_max=8249.534574</a>
</li>
<li>trace file: <a href="http://test.roscidus.com/static/log-x86.sexp">http://test.roscidus.com/static/log-x86.sexp</a>
</li>
</ul>
<p>--</p>
<h4>AoB</h4>
<ul>
<li>
<p>TLS and conduit discussion - Worth looking at TLS/Conduit stuff and Hannes can take a look once Anil has pushed his code.</p>
</li>
<li>
<p>Amir will add a regular agenda item to review the previous call's notes.
Depending on the content of each call, he may also keep a list of actions for
reviewing next time.</p>
</li>
<li>
<p>Next call is scheduled for <strong>28th October</strong> - Please refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2014-09-30 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2014-09-30|js};
        permalink = {js|weekly-2014-09-30|js};
        description =
          {js|30th Sep 2014: Mirage 2.0 libs, Calendar and some Jitsu|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Mirage 2.0 libs status
</li>
<li>Unix dependencies in Calendar package
</li>
</ul>
<p>Attendees: Amir Chaudhry (chair), Thomas Leonard, Anil Madhavapeddy,
Mindy Preston, Dave Scott and Magnus Skjegstad</p>
<h3>Notes</h3>
<h4>Mirage 2.0 libs</h4>
<p>There's a meta problem where Travis keeps failing and this is making it quite
difficult to triage issues. Not had time to deal with this yet.</p>
<p><strong>cohttp</strong> - Still want to cut package but there's a backlog of 15 outstanding
PRSs on OPAM. Spent some time cleaning up PRs from last few weeks and aiming
to get these pushed through in the next few weeks.</p>
<p><strong>mirage-dev</strong> - Decision to cut a bunch of releases based on <code>mirage-dev</code> as
it's stable and working. That will make it easier to do the next round of
releases but care should be taken to deal with any incoming issues as a result
of these releases.  Intent is to stop changing 'v1' at this point.  Another
benefit of these releases is that we'll no longer need all the pinned repos to
get ARM working. Incidentally, all known ARM bugs are fixed and ThomasL has
reviewed Dave Scott's patches, so will release miniOS as well.</p>
<p>Fixes are coming in for the TLS stack. We really need to figure out how to get
entropy into TLS and there are some thoughts on using vchan to do this.</p>
<p>Also discussed the need for more unit tests, specifically for grant tables etc.</p>
<p>Anil, Dave and Thomas will come up with a plan before end of week as to what
to do regarding all the pending releases.  Thankfully we've avoided breakages
by avoiding partial releases. Question about only supporting 4.02.0 because of
conduit.  It would benefit a lot from 4.02.0 features and make a number of
things much easier.</p>
<h4>Unix dependencies in Calendar package</h4>
<p>There was a brief discussion on the mailing list regarding blockers for
getting a blog feed on the Mirage website.  Essentially, this necessitates
date parsing, which someone will need to implement and may be non-trivial.</p>
<p>There's an issue on an external library tracking this if anyone would like to
get involved (see <a href="https://github.com/Cumulus/Syndic/issues/23#issuecomment-56914187">Cumulus/Syndic#23</a>).</p>
<!-- 
http://lists.xenproject.org/archives/html/mirageos-devel/2014-09/msg00118.html
https://github.com/mirage/mirage-www/pull/208
-->
<h4>AoB</h4>
<ul>
<li>
<p>Removing Xenstore from <code>mirage-platform</code>. Jon Ludlam still looking at this
and it needs some refactoring. Suspend/resume might also be glitchy.</p>
</li>
<li>
<p>Xen/ARM hosting: Could be interesting for community to host Unikernels on
ARM boards. Could then use that platform to do power measurements and
regression tests etc. These could be deployed in people's homes but would
require further thought.</p>
</li>
<li>
<p>Need an Irmin free of <code>core_kernel</code>. Can then use it for logging layers.
Thomas still working on this.</p>
</li>
<li>
<p>Next call is scheduled for <strong>14th October</strong> - Please refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2014-09-16 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2014-09-16|js};
        permalink = {js|weekly-2014-09-16|js};
        description =
          {js|16th Sep 2014: Mirage 2.0 lib releases, Cohttp, Doc day and ARM dev|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Mirage 2.0 libs
<ul>
<li><code>cohttp</code> point release
</li>
<li>other library releases
</li>
</ul>
</li>
<li>OCaml 4.02.0: adding support
</li>
<li>Reminder: Xen doc day on the 24th!
</li>
<li>Xen/ARM development environment
</li>
</ul>
<p>Attendees: Marlon Brasil, Marco Cesare, Amir Chaudhry (chair),
Thomas Gazagnaire, David John, Vicky Khan, Jon Ludlam, Anil Madhavapeddy,
Mindy Preston, Dave Scott and Magnus Skjegstad (with guest appearances from
Wanda and Bella).</p>
<h3>Notes</h3>
<h4>Mirage 2.0 libs</h4>
<p><strong>cohttp point release</strong> - <a href="https://github.com/mirage/ocaml-cohttp">cohttp</a> has external users and there have been
bug-fixes waiting for months. Ideally, would like to cut a release based on
<code>master</code> but can't do that without also doing all of the Mirage 2.0 and related
libraries (e.g <a href="https://github.com/mirage/ocaml-conduit">conduit</a>). In order to support the current users, the plan is
to roll back and do a point release (e.g 0.11.3 or 0.12.0) that includes these
fixes so that others are unblocked.</p>
<p><strong>Mirage 2.0 library releases</strong></p>
<p>This is still primarily driven by <a href="https://github.com/mirage/ocaml-conduit">conduit</a>, which requires a set of
simultaneous releases (tracked in <a href="https://github.com/mirage/mirage/issues/287">mirage/mirage#287</a>).</p>
<p>Once these releases are done, we should be able to remove the reliance on the
Mirage opam remote.  There are about 12 dev repos in there now and since
they're working, it would be good to get them properly tagged and released.
That would simply a lot of other work as we'd all have fewer things to pin and
keep track of and we'd also have to refresh the tutorials. There was some
discussion on <code>V1</code> and <code>V2</code>, FLOWs and vchan, as well as the conventions we
might want to follow for such interfaces going forward.</p>
<p>All of this should be written down and various aspects considered and discussed
on the mailing list.  The issue linked above should be updated and expanded (or
a new one created) to keep track of things (including which instructions need
updating).</p>
<p>Mindy has a cubieboard and can take a look at the ARM instructions again.  So
far, got it to boot using the images from <a href="http://blobs.openmirage.org">blobs.openmirage.org</a>. Once
there are releases it would be good to get more eyes on this.</p>
<h4>OCaml 4.02.0: adding support</h4>
<p><a href="http://ocaml.org/releases/4.02.0.html">OCaml 4.02.0</a> was released a couple of weeks ago and there are some
useful features that Mirage might benefit from. We should consider when and how
we add support for 4.02.0 but first we should ensure that we have proper
support for 4.01.0!</p>
<p>There may even be issues with the current 4.02.0 release that may necessitate a
4.02.1. If that's the case, we may decide to not support 4.02.0 at all.  We'll
see how things stand in due course.</p>
<h4>Xen Doc Day</h4>
<p>There is an outstanding request to get more information up on the
<a href="http://wiki.xen.org/wiki/Category:Mirage_Devel">Xen.org wiki</a> and it would be useful for us to refresh some of our
material.  We can do this during the Xen Doc Day (24th Sep). Amir may be able
to spend some time on this in advance.</p>
<h4>Xen/ARM dev setup</h4>
<p>A question was posed on the list about development environment for Xen+ARM
work (specifically Chromebooks, see <a href="http://lists.xenproject.org/archives/html/mirageos-devel/2014-09/msg00068.html">the thread</a>). This was raised
during the call as this kind of set up may be a useful way of working.
Apparently, it's actually quite difficult to work with these devices where Xen
is concerned. The easiest way is still to use a cubieboard and work directly
from there. We should expand xen-arm-builder to make it easier for people to
get going.</p>
<h4>AoB</h4>
<ul>
<li>
<p>Hannes is back from travels and will be working on <a href="https://mirage.io/blog/introducing-ocaml-tls">TLS</a> integration.</p>
</li>
<li>
<p>Would be good to remove Xenstore from <code>mirage-platform</code>. This might break
things. It's the core coordination in Xen but doesn't work well with Unix.
Although, Xenstore is now Xen independent, so maybe we should call it
IrminStore instead?</p>
</li>
<li>
<p>Next call is scheduled for <strong>30th September</strong> - Please refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2014-08-20 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2014-08-20|js};
        permalink = {js|weekly-2014-08-20|js};
        description =
          {js|20th Aug 2014: XenSummit feedback, Conduit patches and ARM profiling|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>XenSummit Talk
</li>
<li>Conduit merge
</li>
<li>Irmin status update
</li>
<li>Profiling ARM
</li>
<li>Xen-ARM vs Xen-x86
</li>
</ul>
<p>Attendees: Amir Chaudhry (chair), Thomas Gazagnaire, Thomas Leonard,
Jon Ludlam, Anil Madhavapeddy, Richard Mortier and Dave Scott.</p>
<h3>Notes</h3>
<h4>XenSummit Talk</h4>
<p>Anil is in Chicago at the annual <a href="http://events.linuxfoundation.org/events/xen-project-developer-summit">Xen Developer Summit</a> speaking
about Mirage 2.0 and branch consistency for Xen Stub Domains (<a href="http://sched.co/1nhbdHE">abstract</a>).
Some feedback from the talk was emailed to the list and is summarised here
(see the <a href="http://lists.xenproject.org/archives/html/mirageos-devel/2014-08/msg00100.html">thread for discussion</a>).</p>
<ul>
<li>
<p>Git workflow very popular. Lots of people twigged onto the maintainability
benefits of <code>git bisect</code> automation in particular.</p>
</li>
<li>
<p>Questions about why Xenstore transactions are still necessary in the modern
world.  Can replace with consensus protocols instead?  Maybe time for an ABI
bump to deprecate the ancient xenstore protocol.</p>
</li>
<li>
<p>Space usage is a concern — building an RRD-style constant size library to
maintain progressive history would be a big win.</p>
</li>
<li>
<p><em>Excellent</em> talk from Felipe Huici from NEC about building much denser  VM
workloads, and he observed that Xenstored/xenconsoled are a big bottleneck  at
~10000 VMs (<a href="http://www0.cs.ucl.ac.uk/staff/f.huici/presentations/clickos-xendevsummit14.pdf">slides</a>).  Some sub notes:</p>
<ul>
<li>We could write a mirage xenconsoled to log to irmin and drain guest
console rings much faster.
</li>
<li>A distributed xenstored+irmin would allow significantly more scalability
than attempting to build a serially fast version.
</li>
<li>Felipe has the beginning of a simple c++ xenstored that doesn't implement
the full semantics, but is enough for MiniOS.
</li>
<li>It may be useful to negotiate a xenstore v2 protocol and use that for new
guests.  It could use a simple fixed-length binary protocol
(protobuf-style?), and eliminate the need for transactions perhaps.
</li>
</ul>
</li>
</ul>
<p>In general, it was very positive and there was lots of interest in Irmin. Some
feedback from attendees is that some more structure around Mirage would help
people who want to contribute. Right now there are libraries everywhere and
it's difficult to see where you can get involved without having to understand
everything. Making a framework around the upcoming headline features would be
especially useful. This would be something like a roadmap for Mirage 3.0.
Overall, we should be aiming to get better at this kind of thing with every
release (and for the most part, we seem to be —
<a href="https://mirage.io/community/">feedback is always welcome</a>!).</p>
<h4>Conduit merge</h4>
<p>Got HTTP request working through Mirage. Requires DNS and TCP set up and the
like. It's quite a big patch set, which touches a number of libraries and a
number of things are not backward compatible.  Hence these need to be
co-ordinated and there's an issue to track this (<a href="https://github.com/mirage/mirage/issues/287">mirage/mirage#287</a>).
Dave will add vchan support when ready. This is an important set of patches
and we will get a working transport layer.  The updates to mirage-skeleton are
minor and also tracked in the issue.</p>
<h4>Irmin status update</h4>
<p>ThomasG investigating how he could remove the <code>core_kernel</code> dependency
and is also cleaning up
Benjamin Farinier's <code>queues</code> and <code>ropes</code> work to port that in.
<a href="https://github.com/mirage/irmin/issues">Bug reports</a> are coming in from early users and one of the
main points is that we should improve the user side of things.</p>
<h4>Profiling ARM</h4>
<p>ThomasL trying to get profiling data out of ARM, with the intent of producing
some fun and useful graphs to share.</p>
<p>Anil previously mentioned getting ethernet at 100MB. Seems we can get 18MB over
UDP at the moment and Linux only manages 13MB. TCP on Mirage is 11MB and Linux
gets 40MB. Not really clear what these difference are due to. Also tried to
dump from console but turned out to be Xen that was rate limiting things. Anil
suggested that Thomas check that the free slots in rings are being fully
utilised.</p>
<p>It would be really useful if opam can make the profiling process easier. A
compiler switch could help with this and ThomasG can look into that (for
native, not bytecode).</p>
<p>When this is done, ThomasL will write it all up with lots of pretty graphs.</p>
<h4>Xen-ARM vs Xen-x86</h4>
<p>Amir has some fairly basic questions about Xen, Mirage and ARM.  Specifically,
what the differences are between Xen on the cloud (x86) and embedded devices
(ARM). Others tell him this mainly relates to Mini-OS and it's relation to
Mirage (and ClickOS and HaLVM etc). There are several posts that might help
explain things, for example ThomasL's <a href="https://mirage.io/blog/introducing-xen-minios-arm">blog post on ARM</a> and wiki
pages on <a href="https://mirage.io/wiki/xen-events">Xen events</a> and <a href="https://mirage.io/wiki/xen-on-cubieboard2">setting up a Cubieboard2</a>.
Amir will start with those and if anything isn't clear, he'll ask ThomasG
about it. Amir might write this up for the website if it'll help explain to
others too.</p>
<p><em>[edit: This is proof that there's no such thing as a stupid question - AC]</em></p>
<h4>AoB</h4>
<ul>
<li>
<p><strong>ARM features</strong>: New stuff coming. Next version of Xen might take advantage
of this so we should think about this in time.</p>
</li>
<li>
<p>Some of the packages in the <a href="https://github.com/xapi-project/opam-repo-dev">Xapi opam remote</a> are ready to go
upstream. Largely because Dave got them in shape recently.</p>
</li>
<li>
<p>We had another hiccup with the call today and we need to fix this. Proposal
is that we sort out a GoToMeeting account such that more than one person can
start the call. GTM is better than Google Hangouts as it allows for people to
dial in by phone (very useful when travelling or on poor wifi).</p>
</li>
<li>
<p>Next call is scheduled for <strong>2nd September</strong> - Please refer to the
<a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a> for actual details a day or so in advance.</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2014-08-07 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2014-08-07|js};
        permalink = {js|weekly-2014-08-07|js};
        description =
          {js|7th Aug 2014: 2.0 release review, Docs Day and ARM updates|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>2.0 release summary
<ul>
<li>Blog posts
</li>
<li>ARM integration
</li>
</ul>
</li>
<li>0Install distribution
<ul>
<li>Wrapper for deploying Unikernels
</li>
</ul>
</li>
<li>Mirage Docs day (sync w Xen Docs Day)
</li>
<li>Carried over
<ul>
<li>zeroing out cstruct/memory
</li>
<li>duplicated code in mirage platform
</li>
</ul>
</li>
</ul>
<p>Attendees: Amir Chaudhry (chair), Thomas Gazagnaire, Thomas Leonard,
Anil Madhavapeddy, Russell Pavlicek, Mindy Preston and Nick.</p>
<h3>Notes</h3>
<h4>2.0 release summary</h4>
<p><strong>Blog posts complete</strong> - The run of blog posts went very well and found
their way onto social aggregators too.   You can find the the links to these
discussions and other news stories about Mirage (in many different
languages!) at <a href="https://mirage.io/links">openmirage.org/links</a>.  There's an outstanding
issue to raise the visibility of this link log. Anil reports lots of
interest at OSCON (<a href="http://www.oscon.com/oscon2014/public/schedule/detail/35024">5 star talk!</a>) and there was high-attendance
at the workshop in Sweden.</p>
<p><strong>2.0 release</strong> - It's been a couple of weeks since the release and there's
been much more activity on the mailing list. Mirage is waiting on a bunch of
patches to be merged, adding a lot of support for ARM stuff. The upcoming
<code>mirage</code> 2.0 binary will mean that people can remove the pins from the
instructions.</p>
<p>At OSCON, Mort gave Russ the tour who then said there's a nice story about
Docker. Would be good to get as much of this stuff up front so we can get
good story together. Anil noted that we do most of this by building this
stuff and seeing how things work. It's easier to quantitatively evaluate
things.</p>
<p><strong>ARM Integration</strong> - <em>Thomas L</em>: Held up by physical pages bug which
upstream are fixing. Has updated instructions to use a patched stuff.
All the PRs could probably be merged. Has released MiniOS 3 which has a
larger stack. This has an extra MB and will detect stack overflow.
Will be looking at performance next.</p>
<p>Mindy offered to try things out on a BeagleBone but need to have an A20
processor so wouldn't work (it's an A9). We're planning to keep things
focused on Cubieboard and Cubietruck for now and both are quite popular.
Turns out that xen-arm-builder is the easiest way to get stuff on ARM.
If anyone can explain how the Linux configuration works, it would be very
useful to have any writeups about that. We have a bunch of new users who are
finding all it difficult to navigate many different pieces in order to get
up and running.</p>
<p>Question on power management came up a few times at OSCON and ThomasL will
have a look at this in due course.</p>
<h4>0Install distribution</h4>
<p>Thomas L talked about a 0Install wrapper around Xen's xl for deploying
Unikernels. Previously demoed this in April in the Lab but was somewhat
hacky with a poor security story.  Would like to revisit this and is curious
how it would it be wrapped. XenServer takes over the whole host and is a bit
heavyweight. Libvirt might be an optin and should have OCaml bindings.
'Buzz heavyyear' on the mailing list might have useful input. Xapi might
also be useful to look at, so talking to Jon Ludlam too.</p>
<p>Plan should be to start a thread on the Mirage List and try to get
information from others.</p>
<h4>Mirage Docs day</h4>
<p>Russell Pavlicek (Xen Project Evangelist) joins us and encourages us to
organise a doc day and improve the various information available about
Mirage OS on the Xen Project site. Currently on Wiki.XenProject.org there
isn't much and we should really have answers for the basics, such as What is
Mirage?, What's in v2? and Why should I care?. Much of this content does
live elsewhere but representation on Xen Project is important. Items can
(and should) still link back to the Mirage OS site.</p>
<p>Anil and others note that we should take care not to give ourselves the
burden of maintaining duplicate content, especially if it's fast moving
(cf. tutorials). We should aim for a set of stand-alone content and link
appropriately.</p>
<p>Xen Project normally have docs days at the end of month and we are welcome
to join one of those or organise our own independently. Just let Russ know
so that he can add it to the event calendar. Currently thinking of
scheduling a Mirage Doc Day for end of September.</p>
<p>Also, worth sending Russ any PDFs of slides so that they can go up on Xen
Project. Slides there tend to get many views so it's a great way to get more
exposure. Anil notes that it would be better to embed them as we run our
slides as unikernels (dog-fooding all the way!).</p>
<h4>Zeroing out memory/cstruct</h4>
<p>David Kaloper as done a full review and submitted a PR. There might be a
performance hit but it's important due to <code>cstruct</code>'s use in TLS stack and
security-related code.</p>
<h4>Code duplication in Mirage Platform</h4>
<p>The new <code>mirage</code> allows us to move code into libs. The checksum PR will mean
we can then get rid of the duplicates in <code>mirage-platform</code>. In other words,
this is fixed, but not yet merged.</p>
<h4>AoB</h4>
<ul>
<li>
<p>Demonstrated <strong>Irmin</strong> but it needs applications/users. Need to make
sure Irmin links into Xen properly.  One use-case is the Mirage website.
Once we have Irmin logging, we can turn off Google Analytics. Avoids the
privacy leakage and will be interesting to see how this works in general.</p>
</li>
<li>
<p>Lots of good things coming in <strong>OCaml 4.02.0</strong> release and we get a lot of
benefits for free. We should work on this once it's actually released, mostly
likely in late September.</p>
</li>
<li>
<p>Next call is scheduled for <strong>19th August</strong> but Dave and Anil are due to be
at XenSummit. Amir would like avoid the confusion of the last two calls :)</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2014-07-08 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2014-07-08|js};
        permalink = {js|weekly-2014-07-08|js};
        description =
          {js|8th July 2014: More releases, ARM, Blog posts and OSCON prep|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Mirage 1.2 release
</li>
<li>ARM integration
</li>
<li>Blog post progress
</li>
<li>OSCON prep
<ul>
<li>Comments on news release
</li>
<li>Coordinated stories?
</li>
</ul>
</li>
</ul>
<p>Attendees: Amir Chaudhry (chair), Thomas Leonard, Anil Madhavapeddy,
Richard Mortier, Mindy Preston and David Scott</p>
<h3>Notes</h3>
<h4>Mirage 1.2 release</h4>
<p>Mirage 1.2 was released on Monday, as well as <code>ocaml-tls</code>. Anil's been
fixing up deployment scripts (turns out they're a useful reminder of where
all the unikernels are being deployed). Also set up a pool of TLS servers to
deal with traffic.</p>
<p>Merged in Thomas Leonard's changes and will be cutting 2.0 releases slowly
over time. Aim is to put them out there and in place for the announcement.</p>
<p>Thomas L's changes are easy to deal with and they clean up a lot stuff (as
long as you don't depend on c libraries. There may be possible regressions
but these might only affect one external user.</p>
<p>This was followed by some discussion about cstruct and memory (see AoB).
This will be on the agenda for the next call so it's captured properly.</p>
<p><strong>TROVE</strong> - Amir asked about the <a href="https://github.com/mirage/mirage-www/blob/master/TROVE">TROVE file</a> and whether we've
captured all the libraries. Anil has been maintaining it but others should
also take a look and help out if they spot anything. Dave mentioned that
work on the <code>ocaml-xenstore</code> repo is underway and he's tidying it up and
moving pieces around.</p>
<h4>ARM update</h4>
<p>ARM is merged now and you can run the console stuff with what's in the
<code>master</code> branch now. Thomas L is working on getting Mirage to work with
c-stubs. Everything seems to be working from what Thomas L can tell and is
trying to move all the checksum code out of <code>mirage-platform</code>. He noticed
there are some c-libraries that get used and it appears that code is
duplicated. There was some discussion about this (Amir decided to make this
an Agenda item for the next call).</p>
<p>Anil pointed out that a people have asked how they can try out the ARM work.
and we should make this as easy for them as possible. Anil will go through
the existing information and tidy things up.  Specifically, will need to
updated the scripts that produce an SD card image aimed at the Cubieboard
(no-one else has had a chance to try this yet).</p>
<p>There was a question for Thomas L about Hard Float to Soft Float, and
whether this would be complicated to do.</p>
<h4>Blog posts pre-OSCON</h4>
<p>We have an <a href="https://github.com/mirage/mirage/issues/257">issue</a> that's tracking the progress of the blog posts and the
first two have now gone live. One is about the <a href="https://mirage.io/blog/mirage-1.2-released">Mirage 1.2 release</a> and
the other <a href="https://mirage.io/blog/introducing-ocaml-tls">introduces ocaml-tls</a>.  The remaining posts are on
track and all is looking good so far.</p>
<p>Mort did point out that some of the posts are quite long and were
substantive enough to be broken if to shorter posts if we wanted. Amir would
rather stick with the current schedule as he'd like to get everything out
before the main 2.0 announcements. Everyone agrees that in principle there
isn't anything wrong with long posts and since these also serve as
documentation, it's useful to have in one place.</p>
<p>It would be great if people could review each other's posts before they go
live so that we catch any issues early. Otherwise we might have to edit a
live post, which is a bit tedious.</p>
<h4>OSCON prep</h4>
<p>A quick run through of the work needed before the OSCON talk. Mort is
planning to create IOCaml notebooks for each demo and will be working on
this from tomorrow. There's also the somewhat crude version of using GitHub
pushes to update infrastructure. i.e have a simple website unikernel-website
running on EC2 and when a new push is made to the repository, a new image is
built and pushed out, and then the DNS server is pointed at the <em>new</em>
unikernel.</p>
<p>After some brief discussion, Anil said he'd make the code work for this
(webserver, DNS, etc) so Mort will focus on the IOCaml notebooks. We'd also
like the mirage-www site to be a pool of different sites running on
different backends (e.g ARM, UNIX, Xen). This would be very useful for
testing and also help with load-balancing. Anil is also dealing with this.</p>
<h4>AoB</h4>
<ul>
<li>
<p><strong>Irmin</strong> and FAT - Really want to get rid of the FAT layer in Irmin. Amir
notes that there's a joke in here about 'one weird old tip'.</p>
</li>
<li>
<p>Everyone should keep an eye out for <strong>unusual cstruct bugs</strong>. We had a
<a href="https://github.com/mirage/mirage-tcpip/issues/56">subtle one recently</a> and it wasn't a type-safety issue but a
bounds issue. Whenever you see anything, please just file an issue.
Thanks to Mindy for catching this.</p>
</li>
<li>
<p><strong>cstruct/memory</strong> - Need to get cstruct/memory zeroed out. Some discussion
about dealing with this and where it should happen and what, specifically,
we're protecting against. Would be interesting to re-run benchmarks but this
is a long-standing thing about having performance testing to see regressions.
Amir proposes we discuss this next time (add to agenda).</p>
</li>
<li>
<p><strong>Articles and blog roll</strong> - If you notice or write articles on other
sites, please add them to the link log on mirage-www. Alternatively,
just create an issue with the link and someone (prob Amir) will make sure
they get merged into the site. We also need mirage-www to support multiple
authors for blog posts and add a blog roll of contributors. Should also also
make the link log visible on the main site. Amir will file some issues about
these. Anil also mentioned including Thomas Leonard's posts on 0Install as
these are a great mechanism to distribute unikernels.</p>
</li>
<li>
<p><strong>News release</strong> - Amir needs feedback on this to ensure accuracy.
Thanks to those who responded but others need to get back to him soon.</p>
</li>
<li>
<p>Next call will take place on the 22nd, but be aware that Anil and Mort
will be at OSCON in Portland, Oregon.</p>
</li>
<li>
<p>Mort and Mindy will be on the <a href="http://sched.co/1nnPP3B">GSoC/OPW panel at Xen Summit</a>.
<a href="http://www.youtube.com/watch?v=EbEBErvW-Uc">Nanoo-nanoo!</a> <em>[I couldn't resist - AC :)]</em></p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2014-06-24 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2014-06-24|js};
        permalink = {js|weekly-2014-06-24|js};
        description = {js|24th June 2014: Releases, ARM, TLS and Repos|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Mirage 1.2 release
<ul>
<li>repo liveness
</li>
</ul>
</li>
<li>ARM update
</li>
<li>Blog posts pre-OSCON
</li>
<li>Bytemark machines
</li>
</ul>
<p>Attendees: Amir Chaudhry (chair), Thomas Gazagnaire, Thomas Leonard,
Anil Madhavapeddy, Hannes Mehnert and David Scott</p>
<h3>Notes</h3>
<h4>Mirage 1.2 release</h4>
<p>Looks in pretty good shape for a release soon. Just makefiles and SSL,
Should be one last change. Hannes will send patch to add entropy type in v1.
Need 16 bytes. Could generate a fixed amount of entropy in kernel but have
to be careful not to use same unikernel twice (not great).</p>
<p>Xen doesn't provide anything but Dave just added frontend and backend things
for Xen that might help. Should have something better by next Xen release
Overall, won't block on this for 1.2.0.</p>
<p>For makefiles, may need to go back through tutorials and add relevant bits.</p>
<p><strong>Repos</strong> -  Balraj did a lot of work to pull together the libs and you can
see them in the <a href="https://github.com/mirage/mirage-www/blob/master/TROVE">TROVE file</a> so if there are others please add
them there (also see the <a href="http://lists.xenproject.org/archives/html/mirageos-devel/2014-06/msg00133.html">email to the list</a>. This is partly
about increasing visibility so people know what is available. For example,
could add 0install there.</p>
<h4>ARM update</h4>
<p>Testing on Xen unstable branch where addresses are changed. Means rewriting
early boot stuff to do fancy virtual memory mapping stuff (collective groan).</p>
<p>Others should try external minios. Just try to getting it compiling and that
will be useful.</p>
<h4>Blog posts pre-OSCON</h4>
<p>The TLS library is getting ready for a public alpha and they are writing
blog posts for each of the new libs. There are other libs too, which we
should write about before OSCON.</p>
<ul>
<li>TLS (Hannes/David): overview of TLS, Post on API, TLS attacks/mitigations, Mirage integration, asn1 lib, x509 lib, nocrypto lib.
</li>
<li>Vchan (Jon L)
</li>
<li>Ctypes (Jeremy): Useful for inter-VM lib linking
</li>
<li>Minios/ARM (Thomas L)
</li>
<li>Irmin (Thomas G)
</li>
<li>Conduit (Anil)
</li>
</ul>
<p>These posts should be written in advance and reviewed by others before going
up on the site. Amir will help coordinate this.</p>
<h4>Bytemark machines</h4>
<p>Amir still hasn't sorted out his access in order to deploy his dusty
unikernels. He'll keep mentioning it until he actually get around to sorting
out an SSH key with Anil/Dave.</p>
<h4>AoB</h4>
<ul>
<li>
<p>We should get a clear list of new libraries since the 1.0 release. Trove
helps with this</p>
</li>
<li>
<p>Discussion of Conduit</p>
</li>
</ul>
|js};
      };
      {
        updated = {js|2014-06-10 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2014-06-10|js};
        permalink = {js|weekly-2014-06-10|js};
        description =
          {js|10th June 2014: Irmin, Conduit, Deployment and Fist pumping|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Xen Hackathon summary
</li>
<li>Irmin update
</li>
<li>OCaml conduit progress
</li>
<li>Networking fuzz testing
</li>
<li>Unikernel deployment
</li>
<li>Call schedule and organisation
</li>
</ul>
<p>Attendees: Amir Chaudhry (chair), Thomas Gazagnaire, Thomas Leonard,
Anil Madhavapeddy, Richard Mortier, Mindy Preston and David Scott</p>
<h3>Notes</h3>
<h4>Xen Hackathon</h4>
<p>The <a href="http://wiki.xenproject.org/wiki/Hackathon/May2014">Xen Developer Hackathon</a> took place a couple of weeks ago and
Anil, ThomasL, Dave, Jon and Nik all attended.  Apparently it did turn into
a chatathon as <a href="https://mirage.io/wiki/weekly-2014-05-27#XenHackathon">previously predicted</a>.</p>
<p>A group of people went through Amir's <a href="http://amirchaudhry.com/from-jekyll-to-unikernel-in-fifty-lines">Jekyll to Unikernel post</a> to
get their sites building using TravisCI. They did get this working but the
post was written based on a Mac workflow and some parts didn't work well on
other machines, specifically involving tap interfaces (e.g. <code>sudo mirage run</code>
didn't work as expected). In general, Amir mentioned that the blog post
isn't going to get updated but it should point to somewhere that current
information is available for people to follow (that can account for any
quirks on different systems). The Mirage website would be good but updating
this isn't as easy as a wiki.</p>
<p>Other than the above, there were lots of conversations with others people
including those trying lots guests on Xen and seeing lots of latency.
Important for us as we want to be able to run lots of unikernels on top of a
single Xen instance.</p>
<h4>Irmin</h4>
<p><a href="https://github.com/mirage/irmin">Irmin</a> 0.8.1 was <a href="https://github.com/mirage/irmin/releases/tag/0.8.1">released</a>. ThomasG has been
working on an filesystem backend implementation. You can take a normal
filesystem and write at the block level. Next step is to expose Irmin as a
filesystem. So you can use the filesystem and connect somewhere else to get
the history back.  Practically speaking, you build an Irmin filesystem on
top of an existing filesystem (e.g FAT). It'll be a combinator that takes
the FAT implementation and make a new one that's used/exposed (so the file
system is like staging). <em>[If these notes are confusing, it's because I
couldn't keep up - AC :)]</em></p>
<p>ThomasG also learned that the DOS protocol doesn't let you have two letter
directories. Also had some discussion on FAT, blockstore and key value
stores.</p>
<h4>Conduit</h4>
<p>The network stack has become a chimney, where the underlying choices are
affecting things further up the stack. Anil has been thinking about
different approaches and discussing things with people. One thought was
around using functors but that leads to having a functorised stack and then the
applications also have to deal with things this way and whole universe becomes
functorised. This becomes difficult to use.  Another approach is to use
objects (or at least partially) and this seems like it would work much
better. In any case, this is blocking other people's cohttp fixes but looks
like there is a workable solution to this. Anil will have to write this
down to clarify it and the details are quite involved (but are to do with
existential types -- in case anyone feels like diving into it).</p>
<p>In general conduit will permit people to use either openSSL bindings or the
new <a href="https://github.com/mirleft/ocaml-tls">TLS library</a> and doesn't impose those choices on anyone.</p>
<h4>Network fuzz testing</h4>
<p>Mindy is in a cycle of finding bugs and fixing them. Been thinking about
the platform question and doing research today. Also saw
<a href="http://lists.xenproject.org/archives/html/mirageos-devel/2014-06/msg00031.html">Balraj's email</a>, who has been bisecting to figure out where/when
the problems arose in the stack. It turns out that it's a set of commits
over Christmas/New Year by Anil.</p>
<p>Overall, it's a great sign that we're able to go back and pin down which set
of commits introduced the problems but it does show that we need to improve
the type safety in the stack and add unit tests. Any thoughts on unit test
frameworks for networking protocols would be useful so please do send them to
the <a href="http://lists.xenproject.org/cgi-bin/mailman/listinfo/mirageos-devel">mailing list</a>.</p>
<h4>Unikernel deployment</h4>
<p>We currently have two machines, configured with Xen that we could deploy our
unikernels to. Amir would like to put his unikernels there and (when stable)
start moving more of the static sites we have to those machines. It should
be possible to get an account for Anil and at the moment users would need to
write their own config file. There is the question of DNS servers.</p>
<p>In the long term the idea is that we each have our own unikernel DNS servers
but in the short term to have a separate DNS server that would know about
the mapping between the names and the IP addresses. We have a set of IP
addresses on a wiki and can grab one of those and run with it. For example
Mort has one but has not deployed yet as he's blocked on filesystem issues.
Essentially, his site is large enough (papers, media, etc) that he needs two
FAT images, which isn't handled very well.  Can achieve it locally but it
requires tweaking by hand and shell scripts, so not really appropriate for
deployment. Is thinking of patching the Mirage tool but has not time to get
to that. Should create an issue to track this as others are likely to follow
in his wake as their sites grow (e.g Amir switched from Crunch to FAT some
time ago). An issue might help surface others who are having similar kinds
of problems.</p>
<h4>Call schedule and organisation</h4>
<p>Amir points out that we should improve the call organisation. Announcement
of the call was sent about an hour beforehand and we should be giving others
more time. Proposed that a notice is sent on the Monday beforehand to the
list to collect <a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">Agenda items</a>, and then the call is confirmed the
following day.  Regular people on the call can help by adding their agenda
items in advance and Amir will structure them and help keep the call focused
(which it usually is anyway).</p>
<h4>AoB</h4>
<p>Mindy and ThomasL have written some <strong>awesome blog posts</strong> recently. The
posts made it to the front pages of news aggregators and generated a lot of
interesting discussion. The posts were
<a href="http://roscidus.com/blog/blog/2014/06/06/python-to-ocaml-retrospective/">Python to OCaml: Retrospective</a> (<a href="https://news.ycombinator.com/item?id=7858276">HN</a>, <a href="http://www.reddit.com/r/programming/comments/27h2q5/python_to_ocaml_retrospective/">Reddit</a>)
and <a href="http://www.somerandomidiot.com/blog/2014/06/03/the-minnesota-goodbye/">The Minnesota Goodbye</a> (<a href="https://news.ycombinator.com/item?id=7844307">HN</a>).</p>
<p><strong>OCaml-TLS</strong> is is gearing up to an alpha release and we will point people
to the Mirage mailing list for communications.</p>
<p>Some <strong>discussion about Mirage 2.0</strong> release and what the requirements would
be for it. Would need ARM support, Irmin and a story on distributed
computing. This all seems achievable but really would like to have this by
the time of <a href="http://www.oscon.com/oscon2014/public/schedule/detail/35024">OSCON</a>.</p>
<p><strong>Carmack</strong> thinks we're &quot;really interesting&quot;. Cue lots of fist pumping.</p>
<p><a href="https://twitter.com/ID_AA_Carmack/status/476046680698003458"><img src="/graphics/carmack-unikernel.jpg" alt="Carmack on Unikernels" /></a></p>
<p>Next call will be <strong>24th June</strong>. Amir will send an email to the list for
<a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">Agenda items</a> on the 23rd.</p>
|js};
      };
      {
        updated = {js|2014-05-27 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2014-05-27|js};
        permalink = {js|weekly-2014-05-27|js};
        description =
          {js|27th May 2014: Mirage on ARM, Irmin and Xen Hackathon|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Mirage on ARM
</li>
<li>OCaml-Conduit/Ctypes
</li>
<li>Vchan
</li>
<li>Irmin/Xenstore
</li>
<li>Xen Hackathon
</li>
<li>GSoC/OPW
</li>
</ul>
<p>Attendees: Amir Chaudhry (chair), Thomas Gazagnaire, Thomas Leonard,
Anil Madhavapeddy, Mindy Preston and David Scott</p>
<h3>Notes</h3>
<h4>Mirage on ARM</h4>
<p>Managed to run mir-console on ARM! Sent patches to <code>libm</code> to enable package
support and they've been merged so should be in next release. They were very
responsive to patches.</p>
<p>ThomasL is currently getting everything working with packages and scripts
and other stuff. when ready will send PR to Mirage. Not tried any device
drivers yet, just console. Anil is curious if block device works yet - it's
straight-forward to debug in the post-mortem. <code>mirage-net-xen</code> might be good
to try next. Thomas will have a look. Could get something working by the Xen
Hackathon (or at the Hackathon).</p>
<h4>Conduit/Ctypes</h4>
<p>Ctypes 0.3.0 was <a href="https://github.com/ocamllabs/ocaml-ctypes/releases/tag/ocaml-ctypes-0.3">released</a>, with stub generation, which
unlocks a bunch of other work that was waiting on it. Anil did a quick
release of <a href="https://opam.ocaml.org/packages/conduit/conduit.0.5.0/">ocaml-conduit</a> last month and has spent time since then
refactoring and improving interfaces. Hoping to get a new release out by the
end of the week, which will then unlock a bunch of others e.g. the <a href="https://github.com/mirleft/ocaml-tls">TLS</a>
work, <a href="http://opam.ocaml.org/packages/cohttp/cohttp.0.11.2/">cohttp</a> and a number of others.  Anil will update the list when
things are settled.</p>
<h4>vchan</h4>
<p>The linking problem mentioned last time was fixed and Dave believes it's all
working and Jon can do more at the Hackathon.</p>
<h4>Irmin/Xenstore</h4>
<p>Note: Irminsule has been renamed to to <strong>Irmin</strong> and the <a href="https://github.com/mirage/irmin">repo</a>
moved into the Mirage GitHub organisation.</p>
<p>Update on Xenstore and Irmin (Anil wants to call it 'Xirminstore' - no-one
else seems keen). Dave, wants to make it fault-tolerant. Will focus on
making the interface better and get to a demo for the Xen Hackathon and
using Irmin to keep all the logs for debugging.</p>
<p>ThomasG is working on improving the Irmin API so there are some changes
coming (Dave has now been warned).  A release due very soon and Thomas will
be giving a talk on the 6th of June in France.  Benjamin Farinier, who's
<a href="/blog/welcome-to-our-summer-hackers">joined for the summer</a>, is also making good progress.</p>
<h4>Xen Hackathon</h4>
<p>The <a href="http://wiki.xenproject.org/wiki/Hackathon/May2014">Xen Developer Hackathon</a> is taking place this week. The
schedule is up and there are several topics of interest to us including
Docker. You can see the full list on the <a href="http://wiki.xenproject.org/wiki/Hackathon/May2014#Topics_to_Discuss.2C_Code.2C_Work_on.2C_..._at_the_Hackathon">Xen wiki page</a>.</p>
<p>Anil, ThomasL, Dave and Jon are all registered to go with Nik Sultana on the
wait list.  There are others who we should talk to at the event including
Joao and Filipe about ClickOS and Hwanju about PVH. Could possibly ask the
organisers for a Unikernel table. Our aims for the hackathon should be:</p>
<ul>
<li>Get vchan working and Mirage ARM pinging
</li>
<li>Work on fault-tolerant Xenstore/Irmin
</li>
<li>Upstream miniOS patches/packages and discuss how best to do this
</li>
<li>Talk to people about PVH, ARM, suspend/resume and MAC.
</li>
</ul>
<p>Anil notes that we're at risk of turning the hackathon into a chatathon.</p>
<h4>GSoC/OPW</h4>
<p>Anil wrote a <a href="/blog/welcome-to-our-summer-hackers">blog post</a> about this summer's Mirage hackers,
including those from GSoC and OPW. Intros have been made on the mailing list
and they're off to a flying start!</p>
<p><a href="http://somerandomidiot.com/">Mindy</a> joined the call this week and she's run through some tests of
cohttp. Came up against a roadblock until there's more differentiation of
results between invalid requests and invalid pipes.  Submitted an issue
about this but is aware that there are releases coming soon.  Instead she
switched over to looking at more client side things. Anil suggested looking
at the TCP stack as it's only been tested for the common case and there are
probably a lot of issues that could be surfaced. Can't really use Travis for
this as it needs a network, which you don't get in a container. Mindy
already has a working Xen box so this shouldn't be an issue.
You can also read Mindy's recent post on
<a href="http://somerandomidiot.com/blog/2014/05/22/throwing-some-fuzzy-dice/">throwing some fuzzy dice</a> to see what she's been up to.</p>
<h4>AoB</h4>
<p>Anil mentioned that it would be fun to get people who are running unikernels
(e.g their websites) to automatically be listed on the Mirage site or get
some kind of shiny badge for their own.  This could be automatic once the
TLS libs are usable as it can simply be part of the configuration. Amir
laments that his unikernel site is languishing in a Git repo until he can
deploy them to the Bytemark machines. Will put this on the agenda for the
next call.</p>
<p>Next call will be 10th June and items can be added to the <a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">Agenda</a>.</p>
|js};
      };
      {
        updated = {js|2014-04-29 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2014-04-29|js};
        permalink = {js|weekly-2014-04-29|js};
        description =
          {js|29th April 2014: GSoC, Irminsule and Mirage Tutorial|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>GSoC/OPW
</li>
<li>OCaml-Conduit
</li>
<li>Vchan
</li>
<li>Irminsule status
</li>
<li>ARM
</li>
<li>Trove and Libraries
</li>
<li>Releases workflow
</li>
<li>Mirage tutorial day
<ul>
<li>Using Codio
</li>
</ul>
</li>
</ul>
<p>Attendees: Amir Chaudhry (chair), Thomas Gazagnaire, Jonathan Ludlam,
Anil Madhavapeddy, Richard Mortier, David Scott</p>
<h3>Notes</h3>
<h4>GSoC/OPW</h4>
<p>Dave is mentor for the <a href="http://www.google-melange.com/gsoc/project/details/google/gsoc2014/moonlightdrive/5741031244955648">Mirage Cloud API project</a> stuff and working
with <a href="http://1000hippos.wordpress.com">Jyotsna Prakash</a>. The project is to develop Mirage OCaml bindings
for the EC2 and Rackspace cloud APIs and an example Mirage application that
uses the API.  Mort is mentor for the <a href="https://wiki.gnome.org/OutreachProgramForWomen/2014/MayAugust#Xen_Project">OPW project</a> and working with
<a href="http://www.somerandomidiot.com">Mindy Preston</a> on improvements to Mirage, such as (1) support for
booting unikernels easily on EC2, Rackspace and OpenStack Clouds; (2)
protocol bisimulations against existing Mirage protocol implementations; and
(3) adding IPv6 support into mirage-net and a few others.</p>
<p>Dave and Mort will make intros about these new people to the list and Anil
is writing a blog post about all the new people who'll be working on Mirage
over the the summer.</p>
<h4>Conduit</h4>
<p><a href="https://opam.ocaml.org/packages/conduit/conduit.0.5.0/">ocaml-conduit</a> seems to be working well enough but until ctypes is
released we won't have stub generation and SSL won't work reliably.</p>
<h4>vchan</h4>
<p>Jon is working on it and at the moment it doesn't quite link. Some
discussion over what the problems may be.  Jon will look over this and try
again. Actually sent a <a href="https://github.com/mirage/ocaml-vchan/pull/8">pull request</a> while still on the call.</p>
<h4>Irminsule</h4>
<p>Added support for views. These are temporary stores with lazy reads and
in-memory writes; they can be used to convert back and forth an OCaml value
into a store, or to have a fast staging area without the need to commit
every operation to the store. Values can be blobs or subtrees.</p>
<p>Lots of improvements to reading/writing and also worked on server and client
side integration. Sometimes you want to give more control to user. Trying to
implement transactions too.</p>
<p>Irminsule is getting ready for more users now. Dave can use Thomas' new code
to replace some of his own and deal with some of the obvious problems in
xenstore. Anil will try it with his IRC plans.</p>
<p>Should also move the Irminsule repo to Mirage org on GitHub.</p>
<h4>ARM</h4>
<p>Lots of discussion have taken place on the mailing list. Anil is stuck with
image generation and get things on/off the devices. Impressive that ping
works though!  Anil will make a FAT SD-card script.</p>
<p>Mort mentioned that Chris (in Nottingham) has 3 <a href="http://cubieboard.org/2013/10/30/cubieboard3-cubietruck-is-all-ready/">Cubietrucks</a> on their way
to him (these have wifi built in) and will need new uboot thing.</p>
<h4>Trove and Libraries</h4>
<p>Trove is currently a bit rough but nice to have it there. It's a half
finished as there are a lot of things that are not included. Whoever is next
to release, please take notes as you go. Can use these to help document the
process.</p>
<p>Need to sort out licensing for the libraries. Utility libraries that make
sense for Mirage could be 'upstreamed' to Mirage. Benefits would be that any
Mirage testing would include these.</p>
<p>Licenses for Mirage libraries should be ISC/BSD. Reasons for this include
the need for static compilation and the way that unikernels may be deployed
(containing necessary keys). Should also be wary of potential concerns from
future collaborators (e.g license compatibility).</p>
<h4>Releases workflow</h4>
<p>Anil tried out Docker with Mirage and it worked very well. Experience is
very similar to Travis, where you point Docker at your repo, it detects the
Dockerfile and does the rest.</p>
<h4>Mirage Tutorial day</h4>
<p>Venue will be Computer Lab but figuring out a date is proving tricky. We
also need to consider the content.</p>
<p>Some discussion over how we expect this to be delivered, e.g slides and
talks along with code examples or purely online as documented tutorials.
Mort has suggestions and will defer to the mailing list for now to see what
people may be interested in.</p>
<p>NB: Earlier discussions about this took place on <a href="/wiki/weekly-2014-04-01#Mirage-tutorial-day">2014-04-01</a> and
<a href="/wiki/weekly-2014-03-18#Mirage-tutorial-day">2014-03-18</a>.</p>
<p><strong>Using Codio</strong></p>
<p>Amir tried <a href="https://codio.com">Codio</a> today and hit an issue related to aspcud (see the
<a href="http://lists.xenproject.org/archives/html/mirageos-devel/2014-04/msg00095.html">mailing list thread</a>). There are now two issues open on the Codio bug
tracker about including aspcud as part of the opam install (<a href="https://github.com/codio/boxparts/pull/83#issuecomment-41681329">#83</a>) and
also to update their opam packages (<a href="https://github.com/codio/boxparts/issues/105">#105</a>). These should be fixed by
Friday. In the meantime a manual upgrade process and installing a few
libraries piecemeal (e.g optcomp first) should work. It does take a while
though.</p>
<h4>AoB</h4>
<p>Wiki page for collecting agenda items is now up. See it at:
<a href="https://github.com/mirage/mirage-www/wiki/Call-Agenda">https://github.com/mirage/mirage-www/wiki</a></p>
|js};
      };
      {
        updated = {js|2014-04-15 16:00|js};
        author =
          {
            name = {js|Dave Scott|js};
            uri = Some {js|http://dave.recoil.org/|js};
            email = Some {js|dave@recoil.org|js};
          };
        subject = {js|Weekly Meeting: 2014-04-15|js};
        permalink = {js|weekly-2014-04-15|js};
        description =
          {js|15th April 2014: GSoC, vchan, Mini-OS/ARM and Irminsule|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>GSoC/OPW
</li>
<li>OCaml-Conduit
</li>
<li>Vchan
</li>
<li>Irminsule status
</li>
<li>ARM
</li>
<li>Mirage tutorial day
<ul>
<li>Using Codio
</li>
</ul>
</li>
</ul>
<p>Attendees: Amir Chaudhry (chair), Jonathan Ludlam, Anil Madhavapeddy,
David Scott, Thomas Leonard, Thomas Gazagnaire</p>
<h3>Notes</h3>
<h4>GSoC</h4>
<p>We have 2: (a) and (b). For (a): shall we do IPv6 or fuzz testing? Thomas
points out that IPv6 is good marketing. JonL described his
<a href="https://github.com/jonludlam/xen-testvm">xen-testvm</a> which can be used to
emit packets, read and write block etc. (b) will probably work on the cloud
API bindings (mainly mentored by Dave). Claims were made about Dave being the God of clouds.s</p>
<h4>Conduit</h4>
<p>Anil wrote <a href="https://opam.ocaml.org/packages/conduit/conduit.0.5.0/">ocaml-conduit</a> (<a href="https://github.com/mirage/ocaml-conduit/">source</a>), which is a nice API to open SSL connections. Abstracts a layer and allows us to swap
something else in the back. In future it will support other types of
connections and clean-slate SSL stacks (e.g <a href="https://github.com/mirleft/ocaml-tls">OCamlTLS</a>). It was quite a
big rewrite. We should use it everywhere were we want to open connections
(e.g. SSL clients). David Sheets is back soon so will resume some of his
SSL work too.</p>
<h4>vchan</h4>
<p>Currently only used by xen-testvm, which isn't currently building because
it's pre-Mirage 1.0. Anil points out that the magic conduit library can
could also have vchan support but needs someone to look at this. JonL has
agreed to this and will add vchan support to ocaml-conduit.</p>
<h4>Irminsule</h4>
<p>Thomas reports that merging is working (more or less). He's started to work
on a dispatcher, where you can assemble together different backends (memory,
disk, ...). You will be able to decide which backend to use based on the
key, provided first class modules are up to the task.</p>
<p>This means we can (almost?) do logging now. Can run a VM with a collector
for this. Anil is keen to try putting together an IRC bouncer. Dave has
tried Irminsule on Xenstore. Git push is still outstanding although
Irminsule push somewhat works. Just need to get core_kernel compiling with
it. Everyone is invited to <a href="https://github.com/samoht/irminsule/wiki/Getting-Started">try it out</a> and please submit
feedback via the <a href="https://github.com/samoht/irminsule/issues">bug tracker</a>.</p>
<h4>ARM</h4>
<p>Thomas Leonard has been getting Anil's stuff to
<a href="/wiki/xen-on-cubieboard2">work on the Cubieboard</a>. Hit a bug in Xen causing the
hypervisor to crash. Now that's fixed, the miniOS VM is running and printing
stuff on the screen; it could be replaced with Mirage. ThomasL has started
looking at FreeBSD.</p>
<p>Anil suggests hooking up the console ring to MiniOS to log on the regular
console rather the debug console. Anil suggested that it might be a good
time to re-integrate the OCaml runtime with miniOS, since the current
integration is a little bit hacky. Perhaps after FreeBSD it would be good to
figure out the easiest strategy.</p>
<h4>Mirage Tutorial day</h4>
<p>Amir says: We need to discuss a date.<br />
Anil: We don't have a location!<br />
Anil says: Why not just say Jun 11?</p>
<p>The date needs to be discussed and confirmed so this is not final. Venue is
likely to be the Computer Laboratory and previous discussions regarding the
content and target audience can be found in earlier notes
(i.e <a href="/wiki/weekly-2014-04-01#Mirage-tutorial-day">2014-04-01</a> and <a href="/wiki/weekly-2014-03-18#Mirage-tutorial-day">2014-03-18</a>).</p>
<p><strong>Using Codio</strong></p>
<p>Amir was due to try out <a href="https://codio.com">Codio</a> for this meeting but hasn't had time yet.
It seems to work well enough for the RWO guided tour so he's not
anticipating any issues. Will try and work through a complete example for
next time (e.g building the mirage website).</p>
<h4>AoB</h4>
<p>Amir proposed using the <a href="https://github.com/mirage/mirage-www/wiki">Mirage-www repo wiki</a> to keep track of
upcoming agenda items. Will save Dave from having to dig through his email
between calls and thus avoid agenda items being forgotten. Amir will
set this up and then hand over to Dave to maintain.</p>
|js};
      };
      {
        updated = {js|2014-04-01 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2014-04-01|js};
        permalink = {js|weekly-2014-04-01|js};
        description = {js|1st April 2014: Mini-OS, IOCaml and Xenstore|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>GSoC/OPW update (Anil)
</li>
<li>Core_kernel (Anil)
</li>
<li>Iocaml update (Anil)
</li>
<li>Irminsule xenstore (Dave)
</li>
<li>Mirage tutorial day (Amir)
</li>
</ul>
<p>Attendees: Amir Chaudhry (chair), Jonathan Ludlam, Anil Madhavapeddy,
David Scott, David Kaloper, Hannes Mehnert, Thomas Leonard</p>
<h3>Notes</h3>
<h4>Google Summer of Code / Outreach Program for Women</h4>
<p>We've got three candidates.  Need to arrange mentors and need to keep
pushing this to make sure things go through. Had some more people asking
about Mirage during this process.</p>
<h4>Core_kernel/Mini-OS</h4>
<p>Should push for getting support as it's needed for Irminsule and other stuff.
In longer term want nice set of header files to help with cross-compilation.
For now can copy stubs in but keep an eye on them. Only one set of c files
we need (big array).</p>
<p>Possibly need port of MiniOS to use new features of Xen.  Anil will figure
out what's needed. MiniOS in Xen tree has features that overlap so may need
to turn those off. Dave will look at this.</p>
<p>Problems with Core_kernel are around bin_io and sexp lib. Will report these
to JaneStreet.</p>
<h4>IOCaml update</h4>
<p>Code is at https://github.com/andrewray/iocaml.  There's also an
<a href="https://github.com/andrewray/opam">opam remote</a>. Can get a fully Javascript frontend. There are some issues
with C-bindings and it's in pre-release but people should play and report
issues. Could use this to construct tutorials.</p>
<h4>Irminsule xenstore</h4>
<p>Early version is kind of working.  Question about whether if can start a VM.
Fixing stuff up but may work on that next.</p>
<h4>Mirage tutorial day</h4>
<p>Considerations for the tutorial day:</p>
<ul>
<li>Leads
</li>
<li>Location
</li>
</ul>
<p>See <a href="/wiki/weekly-2014-03-18#Mirage-tutorial-day">previous notes</a> for a wider set of questions.</p>
<p><em>Leads</em> - Amir volunteered to lead the logistics, organisation etc for the
tutorial day.  Need someone to step up and think about the content, e.g the
sessions, technical needs (e.g pre-configured VMs, etc) and timing for the
day.</p>
<p><em>Location</em> - Amir is in touch with people at Citrix to see if they'd be
willing/able to host the day.  Relevant folks are on holiday so will have to
wait around a week before he hears back.</p>
<p>Worth noting that <a href="https://codio.com">Codio</a> is a web-based IDE that can provide a dev
environment ready to go. <a href="https://github.com/andrewray/iocaml">IOCaml</a> is also a nice framework to use too.
Suggestion to pick a date far enough away so that we can allow time to get
these right (and working).</p>
<h4>Other</h4>
<p>Switch Mirage calls to a fortnightly schedule (i.e every two weeks).</p>
<p>Async Pull Request - Jon will look over it.</p>
<p>Library updates - some review needed (e.g cohttp).</p>
<p>Incompatible change from Mirage v1.  Will only affect mirage-net and mirage.
if all people <code>opam upgrade</code>, then should be no issue as everything will
change at once.</p>
|js};
      };
      {
        updated = {js|2014-03-18 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2014-03-18|js};
        permalink = {js|weekly-2014-03-18|js};
        description =
          {js|18th March 2014: Crypto, GSoC and a Mirage tutorial day.|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>SSL + crypto
</li>
<li>GSoC / OPW
</li>
<li>Mirage tutorial day
</li>
</ul>
<p>Attendees: Amir Chaudhry (chair), Jonathan Ludlam,
Anil Madhavapeddy, Richard Mortier and David Scott</p>
<h3>Notes</h3>
<h4>TLS/SSL/crypto</h4>
<p>Anil managed to get the SSL stack working and wondered if anyone else has
been tried it. Has played around in Unix but not tried anything with Xen yet.
Seems there's still some work to to do as it's missing the ability to
synthesise a flow interface but don't have a first-class interface for this
yet.  Could take existing type and use that, which everyone thinks is the
best we got for now. Dependencies for TLS are ASN1 and TLS (pure ocaml) and
ocaml-nocrypto (has some C). Still waiting for ctypes stub-generation to be
released before we can do a big change. Should have more pairs of eyes
looking over this code.  If anyone can mess around with this and provide
feedback, it would be be appreciated.</p>
<p>Edit: Code is available at
<a href="https://github.com/mirleft/ocaml-tls">https://github.com/mirleft/ocaml-tls</a></p>
<h4>Google Summer of Code / Outreach Program for Women</h4>
<p><em>GSoC</em> - Student applications close on the 21st (3 days from now).  After
this, the mentoring organisations need to review and rank student proposals.
Mort has spoken to many students about GSoC from undergrads to Masters and
encouraged them to apply. Others have been in touch on the mailing list.
Anil will check the system to see how applications have been going. In
general, everyone should be encouraging applications.</p>
<p><em>OPW</em> - Xen has one slot for an <a href="https://gnome.org/opw/">OPW</a> project and has had couple of good
applicants, with some interest in Cloud API.  Mirage is also open to these
applicants as one of the <a href="http://wiki.xenproject.org/wiki/OutreachProgramForWomen/Round8#Community_Reviewed_Project_List">reviewed list of projects</a>.</p>
<h4>Mirage tutorial day</h4>
<p>Considerations for the tutorial day:</p>
<ul>
<li>Audience?
</li>
<li>Full day vs half-day?
</li>
<li>Break-down of sessions?
</li>
<li>Location?
</li>
<li>Proposed date?
</li>
</ul>
<p><strong>Audience</strong> - In general we want this to be accessible to a relatively wide
audience of programmers (i.e experience of OCaml is not assumed - but
programming experience is).  There are a number of people in the Lab who
would be interested and also from Citrix as well as others once a date is
announced (would be good to have Xen platform team involved).  Would
probably need to restrict numbers to around 30 to ensure we can give each
person individual attention. Should capture details of all people interested
so that if we run this again, we have a self-selected list of people to
reach out to.</p>
<p><strong>Full/Half day</strong> - This should be a full day to make sure that we can cover
enough of the details and take a hands-on approach to the sessions, rather
than lecture-style.</p>
<p><strong>Sessions</strong> - Will need to spend time on structuring this. Would be good if
each session had a tangible goal to reach (e.g get something running up on
Rackspace). Should cover networking, storage and a bunch of basic items.
Making reusable sessions would be extremely useful as they can become the
basis of more formal modules and expanded with more stuff about Xen or the
cloud. These could even become a nice undergraduate systems module with
Mirage as the basis.  Specific breakdown might be to have the first part of
the day be about OCaml basics (e.g Ch1-Ch7 of <a href="https://realworldocaml.org">RWO</a>), and then dive down
into Mirage and Xen.  There are already elements that could be reused from
much earlier tutorials (Japan?) but would need dusting off for the
(wonderful) new world of OPAM et al.</p>
<p><strong>Location</strong> - Will do first tutorial in Cambridge and could either do this
in the Lab or perhaps at Citrix.  Amir will contact Lars to see if Citrix is
a viable option.</p>
<p><strong>Date</strong> - From a brief poll it seems that sometime during the week of 19
May is a good one but this is <em>not</em> confirmed so we still need to pin down
the exact date. Should keep whatever date we select within the school
term-time (for obvious reasons).</p>
<h4>Other</h4>
<p>Irminsule is being used by Dominic in Nottingham and it does stuff related
to maildir. Mort has put Dominic in touch with Gregory (who's working on
IMAP).  Exciting stuff!</p>
|js};
      };
      {
        updated = {js|2014-03-04 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2014-03-04|js};
        permalink = {js|weekly-2014-03-04|js};
        description =
          {js|4th March 2014: racing bugs and unikernel deployment.|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>tcp arp bug -- race in network setup?
</li>
<li>homepage progress (dns deployment and homepages)
</li>
<li>pick a date for a mirage tutorial day
</li>
</ul>
<p>Attendees: Amir Chaudhry (chair), Julian Chesterfield, Jonathan Ludlam,
Anil Madhavapeddy, Mike McClurg, Richard Mortier, David Scott</p>
<h3>Notes</h3>
<h4>tcp arp bug -- race in network setup?</h4>
<p>There may be a possible race condition where an ARP request is sent before
TCP. This is related to Julian's problem of getting an IP address into the
VM (see <a href="https://github.com/mirage/mirage/issues/228">mirage/issues/228</a>).  We need somewhere to put IP address
retrieval mechanisms. Lots of options so where should all this logic go?</p>
<p>Has to be somewhere in Xenstore for guest to read it. Xenstore VIF
backend/frontend - but doesn't let you send gateway. Is this a bit hacky?</p>
<p>Julian points out that a lot people don't manage IP via DHCP.  Answer may be
to have multiple bootstrap mechanisms as behaviour on KVM, Amazon etc will
all be different. Dave also points out that in the future, Clouds might
become multi-hypervisor.</p>
<p>For the time-being Anil can give Julian a custom unikernel that only
compiles on Xen.  Will have to revisit this problem later on and maybe come
back to Cloud init later.  It's still not clear what the longer-term answer
is.</p>
<h4>Homepage progress</h4>
<p>Covering:</p>
<ul>
<li>dns deployment
</li>
<li>end-to-end deployment of jekyll-based site
</li>
</ul>
<p><strong>DNS deployment works</strong> -- An example has been committed to mirage-skeleton
(see <a href="https://github.com/mirage/mirage-skeleton/commit/5e29b793d3a423db4cfe5871bc0b443fa98e7ea8">commit 5e29b793d3</a> and <a href="https://github.com/mirage/mirage-skeleton/pull/34">PR #34</a>) but should be pulled out into a
library at some point. Mort mentioned two needs for the DNS right now. One
is the re-director and the other is one on punk that he can manage himself.
Anil also needs one for anil.recoil.org.</p>
<p><strong>End-to-end unikernels from Jekyll sites</strong> -- Amir got his website working
end-to-end from a Jekyll-based site, using Travis for the build and then
committing the Xen unikernel to a GitHub repo (see <a href="https://travis-ci.org/amirmc/amirmc.github.com">his Travis log</a>).
This is essentially the same workflow Anil and Mort have used and Amir is
writing a post to explain the process (as well as why certain things are
done).</p>
<p><strong>Build times</strong> - The build time on Travis seems to be around 14-19 minutes
with (roughly) about 3-5 minutes due to opam installation, 5-7 minutes
during <code>mirage build</code> and another few minutes for the deployment steps. It
would be great if this could be speeded up somehow.  The obvious bottleneck
seems to be the opam installation, as it's the same every time.  This would
speed up build by almost a third.</p>
<p>Anil pointed Amir to the Frenetic team's repo.  They had a similar issue
with Jane Street libraries (which take a while to install) and came up with
a tarballed .opam directory.  They install this in place during travis
builds and you can see how it's used in the
<a href="https://github.com/frenetic-lang/frenetic/commit/12cac9af60bf4ba23791dd40f7ad2e9f02e1ef6e">frenetic travis script</a> and also
<a href="https://github.com/seliopou/opam-street">how it's created</a> (also using Travis).
Amir will examine this at some point and Anil mentioned that we could use
irminsule (in time), to solve this particular problem.</p>
<p>A side issue came up of the question of stable packages and ensuring that
there's a 'known-good' set of packages for use with examples. The option of a
repo of pinned pacakges was floated but general sentiment was that the opam
repo itself should be stable and work with the examples in the repos.  We
should catch breakages.</p>
<h4>Mirage tutorial day</h4>
<p>Some discussion around picking a day for a Mirage tutorial.  Anil has a
number of people who've requested one so we should look for a day in late
April or early May.  Amir will send a doodle poll and we can take it from
there.</p>
<h4>Other things</h4>
<p><em>SSL</em> - This was mentioned as they were blocked on something, maybe related
to sockets.  Possibly also related to the TCP item above.</p>
<p><em>Google Summer of Code</em> - Mentors should be encouraging students to apply.
Requirements are that they're student (of any kind) at an accredited
institution.</p>
|js};
      };
      {
        updated = {js|2014-02-26 16:00|js};
        author =
          {
            name = {js|Amir Chaudhry|js};
            uri = Some {js|http://amirchaudhry.com|js};
            email = Some {js|amirmc@gmail.com|js};
          };
        subject = {js|Weekly Meeting: 2014-02-26|js};
        permalink = {js|weekly-2014-02-26|js};
        description = {js|26th February 2014: homepages are here (almost!).|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Google Summer of Code
</li>
<li>Homepage progress, including:
</li>
</ul>
<ul>
<li>tweaks and configs to static sites (best way forward)
</li>
<li>status of punk (set up for kernels etc)
</li>
<li>deployment of static sites to punk
</li>
<li>tutorials/wiki pages
</li>
</ul>
<p>Attendees: Anil Madhavapeddy, David Scott, Amir Chaudhry (chair),
Richard Mortier, Jonathan Ludlam, Julian Chesterfield</p>
<h3>Notes</h3>
<h4>Google Summer of Code</h4>
<p>Can ask SSL guys to push students to GSoC.  Process is to sign up as mentors
and the students sign up and then students get picked off by mentors.  Being
a mentor doesn't commit you to having a student nor to putting one forward
so there's no downside.  Anil's never had a bad student so it's worth doing.
Mort and Jon will sign up as well.</p>
<h4>Homepage progress</h4>
<p>Covering:</p>
<ul>
<li>tweaks and configs to static sites (best way forward)
</li>
<li>status of punk (set up for kernels etc)
</li>
<li>deployment of static sites to punk
</li>
<li>tutorials/wiki pages
</li>
</ul>
<p>Anil released Mirage 1.1.1 (yay!). Punk is up and running with Xen.
Maintainer of Xen on Debian is responsible so switched from Ubuntu to Debian.
No-one has unikernels running there yet.</p>
<p>Mort will either get his site running on vagrant but might just get it up on
Punk instead when that's ready</p>
<p>Anil got DNS working.  Actually need two servers so will have one 'normal
one' as a backup as well as a unikernel one.  Mort points out physical
redundancy is necessary.  We also need zone file for everyone's unikernel.
Some discussion of how to deal with domains.  Conclusion: Phase 1 will be
single set of DNS servers for all people on Punk</p>
<p>Amir went through mirage-skeleton's static_website setup and got his site
working when configured as unix and was very happy.  Will file bug report
about <code>mirage run</code> failing.  Once site was running, he noticed issues with
URL structure as some links are broken (i.e. the links that don't end with
<code>/index.html</code>).  Mort helped Amir find the relevant code section to edit
(<code>dispatch.ml</code>) and Amir will check out the cowabloga example of list.filter
to get an idea what to change.</p>
<p>Amir's next plan is to get end-to-end thing working with Travis so that a
unikernel can be easily deployed to Punk on a commit.  Anil's scripts work
and push stuff to a www repo for deployment and Mort ways that these worked
for him.</p>
<p>Anil mentioned that we could deploy to Amazon but Mort thinks that's phase
3, related to the self-scaling architecture previously discussed.</p>
<p>Amir will go through tutorials on current website and submit any info he'd
find useful as PRs to mirage-skeleton's readme.</p>
<h4>Other things</h4>
<p>Some discussion of static IP vs DHCP, netbooting and passing in IP address.
Some digging around in code and docs to better understand this.  Dave
mentions cloudinit.  Julian will file bug for startinfo and Anil will look
at cloudinit.</p>
|js};
      };
      {
        updated = {js|2013-06-11 16:00|js};
        author =
          {
            name = {js|Anil Madhavapeddy|js};
            uri = Some {js|http://anil.recoil.org|js};
            email = Some {js|anil@recoil.org|js};
          };
        subject = {js|Weekly Meeting: 2013-06-11|js};
        permalink = {js|weekly-2013-06-11|js};
        description = {js|11th June 2013: the end of the start is in sight|js};
        body =
          {js|<h3>Agenda</h3>
<p>Work through the integration of:</p>
<ul>
<li>the new UNIX backend which spins off a separate unikernel process
</li>
<li>the elimination of OPAM switch from the mirari workflow
</li>
<li>binary package generation
</li>
</ul>
<p>Attendees: Anil Madhavapeddy, David Scott, Vincent Bernardoff, Daniel Buenzli, Jonathan Ludlam</p>
<h3>Notes</h3>
<p>Vincent's patchset successfully split out much of the UNIX dependencies into
smaller libraries.  Anil has been code-reviewing and integrating them, and now
has a working Mirage again in trunk!</p>
<p>The new OPAM scheme breaks up:</p>
<ul>
<li><code>mirage</code> into <code>mirage-unix</code> and <code>mirage-xen</code>
</li>
<li><code>mirage-net</code> into <code>mirage-net-direct</code> and <code>mirage-net-socket</code>
</li>
<li>Adds a dependency of the form <code>(mirage-unix|mirage-xen)</code> to the now-dummy <code>mirage</code> package.
</li>
<li>Adds conflicts to each other on <code>mirage-unix</code> and <code>mirage-xen</code>.
</li>
</ul>
<p>This all means that we no longer need to use a separate compiler switch for
compiling UNIX and Xen backends, thus simplifying mirari considerably.  Dave
added a patch which stubs out <code>mmap</code>, also eliminating the need for the
<code>xenbigarray</code> package.</p>
<p>Anil will push all these changes to trunk and cut a new set of releases with this
scheme.  This should be the last of the changes required before a beta!</p>
<p>Anil: trunk compiler seems broken with Xen due to missing symbols Dave: yes, as
they have been added since 4.00.1 was released.  Decision to stick with 4.00
for now, as we don't require the 4.1 features (but they speed up the unikernel
a lot, but performance isn't priority just yet).</p>
<h3>Next Steps</h3>
<p>We're going to aim to stabilize everything for two weeks.</p>
<ul>
<li>Vincent: get EC2 bindings in shape.
</li>
<li>Anil: try out libvirt
</li>
<li>Anil: look at plumbing through block storage in mirari.
</li>
<li>Dave: fixing Balraj's network ring reservation query.
</li>
<li>Dave: look at pulling out FAT32 (still using Bitstring).
</li>
<li>Vincent: write blog post on Mirari.
</li>
<li>Vincent/Dave: look at evtchn unification and test cases for event handling.
</li>
</ul>
<p>Anil will chat with David Sheets about getting continuous builds runnings now
that it's all part of the mainline.</p>
<h3>Binary packages</h3>
<p>Discussion about whether we could use OCamlot for binary distribution
generation, as Dave and Jon have been knocking out RPM spec files at an
alarming rate.  We also need this to generate binary distribution of Mirage for
the OSCON preview.</p>
<p>Jon/Dave/Citrix are working with upstream CentOS, so this is the first place to start.
Anil: we can customise OCamlot much more easily than Jenkins, so this should be good to hook in.</p>
|js};
      };
      {
        updated = {js|2013-06-04 16:00|js};
        author =
          {
            name = {js|Anil Madhavapeddy|js};
            uri = Some {js|http://anil.recoil.org|js};
            email = Some {js|anil@recoil.org|js};
          };
        subject = {js|Weekly Meeting: 2013-06-04|js};
        permalink = {js|weekly-2013-06-04|js};
        description =
          {js|6th June 2013: EC2, shared ring performance and outreach|js};
        body =
          {js|<p><em>Attendees:</em> Jonathan Ludlam, Vincent Bernardoff, Dave Scott, Anil Madhavapeddy, Amir Chaudhry, Mike McClurg</p>
<h3>Mirari</h3>
<p>Excellent progress on Mirari from Vincent, who will have patches available soon for merging.</p>
<p>Anil: main last change we need to make is to stop Mirari from requiring OPAM
switch.  This is because it forces you to compile a new compiler (takes a long
time) just to build a Xen kernel.  Instead, we can use the OPAM constraint
solver to do the selection of packages rather than environment variables.</p>
<p>All agreed (Thomas is on vacation but agreed this would work earlier on a cl-mirage
mail thread).  This should be the last breaking change in the build infrastructure
before the release, so we'll aim to integrate by next week.</p>
<h3>Testing and EC2 integration</h3>
<p>Vincent: There is no automatic way to set up a free EC2 for Mirage with micro.
You have to do it by hand each time you want to upload a kernel.</p>
<p>Anil: We also need reliable shutdown hooks for EC2, or risk spending lots of cash by mistake!</p>
<p>Balraj has been playing with performance to optimise the network stack.  Some
questions about perf and Xen: there doesn't appear to be a perf-xen mode
although there is a perf-kvm mode.  OCaml 4.1-trunk has really good CFI stubs
that make using perf almost pleasant.</p>
<p>nil: Tom Ridge is just starting work on building a verified filesystem in
OCaml, so we had a meeting about that with Thomas Gazagnaire last week.  Very
exciting work, as it should be easy to hook into Mirage.</p>
<p>Some discussion of the RPC mechanism for Vincent's testing infrastructure.  Consensus
is that instead of using Xenstore as an RPC mechanism, we should use an explicit
libvchan communication channel instead.  This would let us build command-line
tools for vchan that make it easier to manipulate the kernel.</p>
<p>Balraj also raised the question of TCP and intended behaviour of the ring
interface with fragmentation.  His tests run very small packets (below TCP
minimum size) and deadlock if the ring doesn't have enough free slots.
Dave/Anil think that we need to lock the shared rings to queue up producers (so
that we dont end up with out-of-order packets on the wire) and also provide a
new function to request a reservation of multiple contiguous ring slots.  Dave
will look into this further.</p>
<h3>Outreach</h3>
<p>Anil: Preparing for the release in July, we need to think about what blog posts
people would be interested in.</p>
<p>Anil: A really good blog post for Dave would be how to build a userspace block
device in pure OCaml that provides storage to VMs.  For a memory device, we
could pretty much build this from the OCaml toplevel in dom0.</p>
<p>Jon: I like the idea of getting people to do screen-casts.</p>
<p>Anil: Aim for one high quality blog post from everyone every two months.
Should be able to get a post up every two weeks then.  Every post should think
about its target (level of Xen familiarity, etc).  Lars from Xen.org could
advise on this.</p>
<h3>Merging to trunk</h3>
<p>Vincent: Can someone look at Unix back-end and code-review the shift
to multiple processes for UNIX.</p>
<p>Anil: on the queue for this week, and will definitely have it merged by
next week's meeting. This will very likely break trunk for a little while
since I'll do the OPAM rearrangement at the same time.</p>
<h3>SSL libraries</h3>
<p>Anil: Now that ctypes is released, we should look at SSL alternative bindings again.
Prashanth pointed out axTLS, which is a BSD licensed alternative to MatrixSSL and
therefore worth looking into more (but it's API isn't quite as agnostic to sockets
as MatrixSSL, sadly, but should still work fine as sockets can be nonblocking in
the axTLS world).</p>
|js};
      };
      {
        updated = {js|2013-05-28 16:00|js};
        author =
          {
            name = {js|Anil Madhavapeddy|js};
            uri = Some {js|http://anil.recoil.org|js};
            email = Some {js|anil@recoil.org|js};
          };
        subject = {js|Weekly Meeting: 2013-05-28|js};
        permalink = {js|weekly-2013-05-28|js};
        description =
          {js|28 May 2013: Build pain reduced to mild ache, Try Mirage, Benchmarking available|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Build progress since last week
</li>
<li>Exploring a Try Mirage site for launch
</li>
<li>Benchmarking progress with Core_bench
</li>
</ul>
<p><em>Attendees</em>: Balraj Singh, Anil Madhavapeddy, Amir Chaudhry, David Sheets, Jonathan Ludlam, Thomas Gazagnaire, Prashanth Mundkur, Vincent Bernardoff, Mike McClurg, Daniel Buenzli</p>
<h3>Build update</h3>
<p>Dave: An obuild 0.0.2 snapshot has been uploaded to OPAM that fixed lots of bugs and is
generally very usable.</p>
<p>Anil: we would like to use Jenga in Real World OCaml, but it's still not
portable to the Mac (there is ongoing work in ocaml-plugin to make this work
there).</p>
<p>Thomas: ocp-build is working nicely but not well-documented due to lack of
time. The front end isn't great but it's designed to be generated from other
tools (Fabrice is willing to improve it).  We would like input on what is
required would not be difficult to adapt it.</p>
<p>Anil: One nice feature of Mirari is that dependencies can be auto-installed
during the configure phase. We like OPAM to understand build a bit more and
automate things more easily in the longer-term.  e.g Parse OASIS file and
generate meta files.  Jenga doesn't have that.</p>
<p>Thomas: We need something more concrete in the build space, or we won't
make progress.</p>
<p>Anil: We're driven by the 1.0 deadlie in July at the moment, and can then take
some breathing room to work on the longer term solution. Sounds like it comes
down to OASIS being ok for now, and Mirari being an interface to the application
construction. (general agreement from the room)</p>
<h3>Try Mirage</h3>
<p>Anil: Many people want to try Mirage, but blocked by not having Xen
installation handy. Can we figure out a way to expose a machine for people to
build quickly (e.g. for few mins), or is this too painful?  We can seed this
effort from the Lab (but do actually need the machines for research).</p>
<p>Dave Scott: possible to find VMs, but hosting within Citrix firewall is
problematic due to (entirely valid) security concerns.</p>
<p>Anil: would be good to get EC2 bindings sorted soon, as we should be able
to run the main website on it again.  Vincent: he has ported barko's AWS
bindings to the newest Cohttp already, but not tested it.</p>
<p>Balraj: The TCP stack should be fine to run a live site on.  All the current
bugs are deep in microbenchmarks such as 1-byte writes and far from the
day-to-day stuff a website would see. (muttering of &quot;famous last words&quot; from
the room).</p>
<p>Anil: xen.openmirage.org has been running on EC2 for 20 months and seems ok (but don't all visit at once!).</p>
<h3>Benchmarking and visualisation</h3>
<p>Anil: I've just written a bunch of Real World OCaml text that uses Core_bench, and it's an execllent library.  Can we generate visual graphs from Daniel's library?</p>
<p>Daniel: Having some issues with glyphs in the Canvas backend, but should be ok aside from that.</p>
<p>Anil: How dependant are we on the browser output? Is there an SVG output? can we build graphs that don't depend on Canvas?</p>
<p>(the answer to all the above questions are affirmative)</p>
<p>David Sheets: I'd like to be able to plot stats curves for Ocamlot for queue length and worker utilization.</p>
<p>Daniel: This should be ok from now.  Just need to look at the glyphs thing.</p>
<p>Anil: Going to wait until tuntap is stable and then breakup the network stack
to aid benchmarking.  Helps other people to use (and contribute to) these other
libraries.  Vincent has been Ocamldoc-ing as he goes along and that's been
<em>very</em> useful.  It's hard to do that in one go but as you go along its much
easier.  Please do this for the libs that you are working on.</p>
|js};
      };
      {
        updated = {js|2013-05-21 16:00|js};
        author =
          {
            name = {js|Anil Madhavapeddy|js};
            uri = Some {js|http://anil.recoil.org|js};
            email = Some {js|anil@recoil.org|js};
          };
        subject = {js|Weekly Meeting: 2013-05-21|js};
        permalink = {js|weekly-2013-05-21|js};
        description = {js|21 May 2013: Build, build, build, argh.|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Mirari update (Vincent)
</li>
<li>Jenga (Dave)
</li>
</ul>
<p><em>Attendees:</em> Amir Chaudhry, Anil Madhavapeddy, Thomas Gazagnaire, Richard Mortier, Daniel Buenzli, David Scott, Jonathan Ludlam</p>
<h4>Jenga (Dave Scott)</h4>
<p>Jane Street has released a preview of Jenga onto OPAM, which is a library for
highly scalable builds.  It includes dynamic discovery of dependencies and
Async build rules so network targets can work.</p>
<p>Dave: Jenga looks attractive for a number of reasons, including incremental builds.</p>
<p>Anil: We need a build tool that doesn't suck and that someone cares about (i.e. will maintain).  Jenga does have a big user behind it. Prefer to take something and make it portable rather than continue a forked one.</p>
<p>Dave: Should be easy to make it work for our small projects.</p>
<p>Anil: Key blocker is getting it to work on a Mac.  If you've tried it then do
tell people what didn't work on the Mirage list! Jane Street put it out there
in order to get feedback so they do want to know what people think.</p>
<p>Jane Street is rolling out Jenga for their internal stuff now so it'll start
settling down very fast.  We have the next two weeks to get big changes in while
things are fluid.  We can make Mirari interface with Jenga, for example.</p>
<p>Daniel: Jenga only covers build, but not distribution (making META files, etc).
How do we deal with that?</p>
<p>Anil: We take the good bits of obuild and use them to build Jenga rules.
There's also ocp-build hiding in the shadows.  It's technically very nice
but not fully released, and doesn't have output-obj (but that's easy to add).</p>
<p>Dave: Another option is to slice out the distribution library from obuild
(which has a good META parser that's standalone).</p>
<p>Anil: Hoping to get Jenkins running again, since Balraj notices trunk is broken
again while working on perforamce stuff.  We need to remove opam-repo-dev
as it's always breaking dependencies silently.</p>
<p>Mort: Kind of works on Linux, but we still need to run <code>tunctl</code> by hand.
Anil: Mirari should fix this up automatically, so I'll take a look in the next few weeks.</p>
<p>Jon: Vincent Bernardoff is working on the Xen unikernel testing infrastructure
with Mirage, so we'll wait to hear from him to see what he's done (test VM and
Test harness). Could use that to test the Unix backend too.</p>
<p>Anil: In OPAM can use OCamlot can do a bunch of scripts (not just OCaml). We
need to figure out where to host VMs though, as the Lab is unsuitable for
ongoing deployments due to lack of sysadmin cover.</p>
<h3>AoB</h3>
<h4>cohttp</h4>
<p>Anil: About to release a new cohttp and want to hook it up to a graphing system for plots.  Can this connect with Daniel's vg? Can try getting raw numbers out now and then attach graphics after.  Does vg need a particular format?</p>
<p>Daniel: Vg is usable now and installable via opam.  JSON is fine but don't need
anything particular. We need a release of OPAM 1.0.1 to fix a bug with unstable
git remotes.</p>
<p>Anil: Jeremy's Libffi (ctypes) now works on Mac and Linux. Have ncurses and
various POSIX bindings working!  In the worst case it's 10x slower (usu 2-3 x
slower) but you don't have to write any C, and we know how to fix the slowdown.
It'll be open-source very soon.</p>
|js};
      };
      {
        updated = {js|2013-05-14 16:00|js};
        author =
          {
            name = {js|Anil Madhavapeddy|js};
            uri = Some {js|http://anil.recoil.org|js};
            email = Some {js|anil@recoil.org|js};
          };
        subject = {js|Weekly Meeting: 2013-05-14|js};
        permalink = {js|weekly-2013-05-14|js};
        description = {js|14th May 2013: Ocamlot, actors and performance|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Ocamlot update and use in Mirage (Anil, David Sheets)
</li>
<li>Actors: Dave's been working on this with his message switch
</li>
<li>Performance testing (all!)
</li>
<li>CHERI/MIPS64 discussion
</li>
</ul>
<p><em>Attendees:</em> Anil Madhavapeddy, David Scott, Richard Mortier, Thomas Gazagnaire,
Prashanth Mundkur, Balraj Singh, Euan Harris, Amir Chaudhry, David Sheets, Jon
Ludlam, Vincent Bernardoff, David Sheets</p>
<h3>OCamlot</h3>
<p>OCamlot is coming together and should go live in a couple of weeks.  It is
currently using Lwt but will eventually transition to Async.  It can download
from a GitHub pull-request, merge the OPAM repositories locally, and run tests.
We will get this up and running in Computer Lab soon with machines here, but
could use more resources and hardware from Citrix and others.</p>
<p><em>David Sheets:</em> I want to be able to get event notification and know when data
structures change and get the functional diff between old and new (as well as
the new).  <em>Anil:</em> This sounds suspiciously similar to what Irminsule could
offer. We're going to work with Thomas next week to figure out how all this
fits together.</p>
<p><em>Dave Scott:</em> Citrix also needs a simple messaging system, with queues persistent in memory (not necessarily on disk).  This all needs to run on a Mirage VM also, and will coordinate the nextgen unikernel architecture.
Apps will talk about named queues of events. The current implementation uses file descriptor passing but will fall back to TCP if across different hosts in the cluster. Using Lwt at the moment. It's a [prototype on Github](http://github.com/djs55/message-switch] so feedback on semantics would be helpful.  Taken some ideas from OpenStack etc. Could use Fable when it's ready (looks pointedly at Anil).</p>
<p><em>Anil:</em> This work may unblock some of the OCamlot prototyping too.  We can use Irminsule when ready but leave that out for the very first release of OCamlot, since we need tests running asap.  However, this all converging nicely for the longer term.</p>
<h3>Actor</h3>
<p>Euan Harris continues to work on the actor library, although he's mainly on the
low-level end of things at the moment.  Two significant other interface-related
things were pointed out.</p>
<p><em>Anil Madhavapeddy:</em> Daniel Bunzli is working on a really nice <a href="http://erratique.ch/software/vg/demos/rhtmlc.html#color-grayscale-ramp">Vg</a> graphing library suite which will help visualise actor interactions.
<em>Thomas Gazagnaire</em>: Have you seen the <a href="http://console-demo.typesafe.com/demo@typesafe.com/Demo/">Akka demo</a> console, which provides similar functionality for Scala.</p>
<p><em>Anil:</em> Balraj had a localhost web server embedded directly into the Mirage TCP
stack for debugging.  This actor approach offers us a well-structured
alternatives to such daring hacks.  It would be great to be able to recompile
the whole stack into debug mode, with RPCs flying around instead of function calls.
RPCs are far easier to debug. <em>Balraj</em> agrees that a more general solution would
be useful.</p>
<p>Cohttp is much more stable, and it's functorised cleanly now. Citrix has their
own IO monad for it using regular buffered IO over channels using FD
reading/writing. There are an increasing number of third-party projects using
Cohttp, so we really do need to get a stable version out.</p>
<h3>Performance</h3>
<p>Need to do testing for All the Things, preferably on an ongoing basis within
OCamlot!  Since we're now on release track this matters far more than when it
was just prototypes for research papers.  We don't have a full regression suite
to work off yet.</p>
<p>For now, we should just pick a set of reasonable tests per library.  Balraj had
some for the TCP stack, Anil will put together for HTTP stack.  Mark Shinwell
is working on some very useful allocation profiling patches that should be
ready in a month or earlier.</p>
<p><em>Balraj:</em> Example test for TCP might be the 10MM concurrent connections. We
should be able to do that without too much sweat.</p>
<p><em>Anil:</em> For HTTP, can use httperf.  Curious to see where we are with that and
how we compare with nginx, as we were competitive in the ASPLOS paper but may
have regressed.</p>
<p>Having performance tests as part of libraries is a good idea so that they can
be run by Ocamelot automatically.</p>
<h4>Repository management.</h4>
<p>80+ repos now listed on wiki. Maybe add info on testing status to this list
also.  Dave and Jon and Anil will chat separately about writing Github scripts
to help manage these repositories as a cluster.</p>
<h3>MIPS64/CHERI port</h3>
<p>Prashanth Mundkur is looking into getting OCaml into CHERI (a MIPS 64
experimental CPU developed at the Computer Lab and SRI International).  Anil
suggests looking at porting OCaml into stackless mode so it doesn't share
the C stack, which would break the FFI very slightly, but be easier to segment.</p>
<p>There were some patches flying around a few years to implement this directly
in ocamlopt, and Anil will investigate.</p>
<h4>AoB</h4>
<p>A number of Cambridge students are going to Jane Street for internships, and
we're synching up projects so that they can continue after the summer.  Ideas
for internships welcome.</p>
|js};
      };
      {
        updated = {js|2013-04-30 16:00|js};
        author =
          {
            name = {js|Anil Madhavapeddy|js};
            uri = Some {js|http://anil.recoil.org|js};
            email = Some {js|anil@recoil.org|js};
          };
        subject = {js|Weekly Meeting: 2013-04-30|js};
        permalink = {js|weekly-2013-04-30|js};
        description =
          {js|30th April 2013: device drivers, SSL, actors, OpenFlow|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Moving devices drivers out into userspace (Dave Scott)
</li>
<li>Cross-compiling MatrixSSL (Jon Ludlam)
</li>
<li>Js_of_ocaml storage (Anil Madhavapeddy)
</li>
<li>Actor libraries and the new wg-parallel working group (Anil Madhavapeddy)
</li>
<li>Openflow (Prashanth Mundkur)
</li>
</ul>
<p>Attendees: Anil Madhavapeddy, Dave Scott, Euan Harris, Amir Chaudhry, Daniel Bunzli, Vincent Bernardoff, Jon Ludlam, Prashanth Mundkur</p>
<h4>Moving devices drivers out into userspace (Dave)</h4>
<p>Goal is to make the Mirage device driver libraries compile on both UNIX and Xen, so that we can prototype them all in userspace and then just recompile into Xen.  All of the required kernel bits in Linux should be there in 3.5 upwards, such as the <code>gnttab</code> and <code>evtchn</code> devices. Dave has issued a series of <a href="https://github.com/mirage/mirage-platform/pull/29">pull requests</a> to make this possible for Mirage Platform, and will merge them this week.  This means that <code>mirage-platform</code> now exposes a xenctrl OCamlfind package.</p>
<p><em>Anil:</em> we're missing an example to test userspace bits as a simple unit test.  Perhaps a simple memory-backed block device would be a useful one to include, as there are significant moving parts required to get it up and running at the moment.
<em>Jon</em>: There's some VHD code that we could use and should be in OPAM.
<em>Anil:</em> Even a RAM disk would work initially, before this, just to get functional tests running before anything persistent.
<em>Dave</em>: tricky thing with blkfront is that the API is different between userspace and kernel mode.  Will work on this more with Jon.</p>
<p>Vincent also just finished up the <a href="https://github.com/vbmithr/ocaml-tuntap">tuntap</a> bindings and is working on migrating <code>mirage-platform</code> to using it this week.
<em>Anil:</em> Writing up these minutes are a good excuse to regularly rebuild the live <code>mirage-www</code> with the latest stuff, so he'll try Vincent's patches when they're ready.</p>
<h4>Cross-compiling MatrixSSL (Jon Ludlam)</h4>
<p>Anil and Jon attended the <a href="http://www.flickr.com/photos/ydn/8703101338/in/set-72157633314001114">Yahoo hack day</a>. There were giant robots there.  They ended up starting OCaml bindings to MatrixSSL.
<em>Jon</em> just writing bindings to it under the UNIX environment but also has stuff working in Mirage.  This is a good way of getting SSL support into Mirage as an early stepping stone.<br />
<em>Anil:</em> Lib is GPLv2 so will need to replace at some point but better than OpenSSL for binding.
<em>Jon:</em> could we have Dropbox like functionality. using a VM backend as store.
<em>Anil</em>: yes, with Async/Cohttp this shouldnt be too hard once userspace drivers are working.</p>
<p><em>Anil:</em> Hot off the press are some <a href="http://github.com/yallop/ocaml-ctypes">FFI bindings</a> by Jeremy Yallop.  Doesn't require any actual C code to bind any more, but still stabilising and perf testing.</p>
<p><em>Prashanth</em>: Anyone looked at <a href="http://mitls.rocq.inria.fr/downloads/miTLS-report.pdf">miTLS</a> from MSR/INRIA?
<em>Anil:</em> Challenge is to get a verified high-performance version of anything in this space.</p>
<h4>Js_of_ocaml storage (Anil Madhavapeddy)</h4>
<p>Anil started writing a little abstraction library for js_of_ocaml for storage, for eventual integration into Irminsule.
It's a bit complicated as you have to write for the case where local storage is present and where it is not.  Lib helps take care of that so you don't have to worry when writing your stuff.
Need a name for this unified library.  Email Anil if you have any ideas! He's going to upload it for next week.</p>
<p><em>Daniel:</em> Need to do some JS hacking so Anil will send stuff to him too.  Also, Anil should check stuff in vg as had to do some similar stuff so check it out and see if there's anything useful in there.   Link is here for <a href="https://github.com/dbuenzli/vg/blob/master/test/mui.mli#L97">mli</a> and <a href="https://github.com/dbuenzli/vg/blob/master/test/mui.ml#L255">ml</a>.</p>
<p><em>Daniel:</em> Bigarray support in Js_of_ocaml?
<em>Anil:</em> JS has typed arrays instead, but I don't know how many browsers support this.<br />
<em>Daniel:</em> Canvas may allow you to use that.<br />
<em>Euan:</em> Everything supports typed arrays except Opera mini (discovered via caniuse.com)</p>
<h4>Actor libraries and the new wg-parallel working group (Anil Madhavapeddy)</h4>
<p>We've set up <a href="http://lists.ocaml.org/listinfo/wg-parallel">wg-parallel</a> for (a) multicore and (b) actor thing for stateless programming.  Euan is cloning Erlang OTP in Async/Core as his &quot;month off&quot; project.  wg-parallel not announced to OCaml list yet until we do some preparatory work.</p>
<p>Euan describes his emerging actor library.  Using polymorphic variants as message types. hoping to have type checking between process but running into polymorphism and subtyping issues.  Sent some <a href="https://lists.cam.ac.uk/pipermail/cl-mirage/2013-April/msg00069.html">emails to list</a> and apparently can't do it the way he wanted (after chatting with Leo).</p>
<p>Interesting thing is really OTP which is how Erlang builds reliable systems on
message passing.  Hope that we might build an OCaml runtime that has separate
heaps and message passing (of interest to Stephen Dolan and Leo).</p>
<p><em>Anil</em>: Pipes in Async are abstract: they take alpha/beta values and apply flow-control.  The Reader/Writers in Async_unix actually implement TCP. We need a shared memory version.
<em>David:</em> API for <a href="http://github.com/djs55/shared-memory-ring">shared-memory-ring</a> is mostly good, but quite low-level and needs some work to clean it up with accessors.
<em>Euan:</em> Hello World in Erlang is program called ping-pong.  Haven't benchmarked Erlang's version but OCaml version does 8000 per second.  Will start cross-comparisons with Erlang.</p>
<p><em>Prashanth</em>: For benchmarking, Erlang uses bunch of http stuff.<br />
<em>Euan:</em> In Erlang, they're less concerned about throughput but about handling multiple connections. It's more about scalability of concurrent connections.</p>
<p>Brief discussion about load generation for testing purposes and difficulty of spinning up sufficient load to stress a server.  Could use Mirage for better load generators, which would be more widely usable.
<em>Anil:</em> May not want to use multiple experimental systems for testing/benchmarking.  Maybe the stuff for fuzz-testing might be useful for HTTP though.</p>
<p>wg-parallel list is small at the moment so idea is to start discussion how to move Lwt and Async together.  Just need them to work well together as they're both going to be around for a long time. This is a pressing concern from Mirage which has a significant investment in Lwt but needs to migrate to Async in the longer term.</p>
<p><em>Prashanth</em>: does the actor library consider scheduling to be a concern?  Erlang is pre-emptievely scheduled.  Can be blocked any time you're running.  That's why we need better underlying support in the VM if we want actor model.
<em>Anil</em> believes that we can make it work just fine with UNIX processes and message passing and Monitors.  The emerging multicore OCaml runtime will help.</p>
<p><em>Euan:</em> Hot code reloading in Erlang will be more difficult in OCaml.
<em>Anil:</em> Sounds like xen live-migration, which everyone says is great but don't really use it.
<em>Prashanth</em>: That's one reason why Erlang doesn't have a static type-system (so they can hot-reload).
<em>Anil</em>: we should be looking at service-level hot reload, not at the code level (c.f. the ongoing FRP/React discussion).</p>
<h4>Openflow status</h4>
<p>Prashanth has been looking at OpenFlow versions and seems lots has changed between recent revisions.  Some of it breaks backwards compatibility, and semantics too. i.e flow matching has changed between 1.1 and 1.3.</p>
<p><em>Anil</em>: nothing we're doing requires compatibility with current hardware so perhaps just work with 1.3 and then figure out a backwards compatible mapping.
<em>Prashanth</em>: I'll send some links to updated spec (find it <a href="https://lists.cam.ac.uk/pipermail/cl-mirage/2013-May/msg00000.html">here</a>).</p>
<p>No call next week (7th May) as several members are travelling, but we can resume the call as normal in two weeks on the 14th May.</p>
|js};
      };
      {
        updated = {js|2013-04-23 16:00|js};
        author =
          {
            name = {js|Anil Madhavapeddy|js};
            uri = Some {js|http://anil.recoil.org|js};
            email = Some {js|anil@recoil.org|js};
          };
        subject = {js|Weekly Meeting: 2013-04-23|js};
        permalink = {js|weekly-2013-04-23|js};
        description =
          {js|23th April 2013: Irminsule, concurrent revisions and release checklist|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Thomas Gazagnaire: <a href="http://www.cl.cam.ac.uk/projects/ocamllabs/tasks/t2.html#Irminsule">Irminsule</a> demonstration
</li>
<li>Richard Mortier: <a href="http://research.microsoft.com/en-us/projects/revisions/">Concurrent revisions</a> implementation in OCaml
</li>
<li>Anil Madhavapeddy: <a href="https://mirage.github.io/wiki/dev-preview-checklist">Release checklist</a> review
</li>
</ul>
<p><em>Attendees</em>: Anil Madhavapeddy, Dave Scott, Vincent Bernardoff, Thomas Gazagnaire, Richard Mortier, Daniel Bünzli, Prashanth Mundkur.</p>
<h3>Irminsule Early Demo</h3>
<p>We managed to get screen-sharing working from Dave's iPad, with pinch-to-zoom
maxing the screen-size and everyone realising that we are living in the
future!  Thomas walked us through the Irminsule interfaces, available on <a href="https://github.com/samoht/irminsule">Github</a>.
Irminsule has three parts, discussed in more detail below: a low-level immutable collection of binary blobs, some structured
objects and revision-branching structure.</p>
<h4>Low-level immutable database</h4>
<p>When you write a value, you get a key (SHA1 or SHA256?). You can read the value
with a key, if you don't have a key you get a null.  This is non-blocking.</p>
<h4>Structured objects</h4>
<p>On top of immutable DB you have some structured objects, like trees. If you
give a root and hash, it'll give you back some key.</p>
<p><em>Anil:</em> how come the <code>merge</code> function maps a <code>value</code> to <code>value</code> and not <code>tree</code> to <code>tree</code>?
Conversation discussing the type of the <code>merge</code> function, and how higher level
abstractions could be built on top of it.  More design work needed to ensure
that existing git merge strategies can be implemented using it.</p>
<p><em>Anil:</em> Can Irminsule replace Xenstore with a persistent version?
Consensus is this should be easy once Dave finishes his xenstore refactoring to
isolate the database, and careful encoding of existing transaction semantics
into Irminsule (which Thomas is familiar with as he did lots of work on
Xenstore).  Dave Scott agrees with this assessment and thinks a distributed xenstore isnt too bad.</p>
<p><em>Prashanth:</em> What about traversal order in the tree? would it make sense to have specified order of traversal?
Answer: there is a stable order, but in the future we may want to define
iterators instead of creating lots of temporary list. This is just an
allocation optimisation and not important for version 1.</p>
<h4>Revision Structure</h4>
<p>On top of structured objects, you have a revision structure.  Read <a href="http://ftp.newartisans.com/pub/git.from.bottom.up.pdf">Git from the Bottom Up</a> for a design perspective on this. Tags are the only mutable structure, and annotated tags create objects with tags associated with them.  Thomas started to work on (only two days) how to sync between two repositories via a pull/push model, and begin to model existing concurrency models on top of the branch-consistent model exposed by Irminsule.</p>
<p><em>Anil:</em> How do you construct a remote node?
<em>Thomas:</em> right now the module types are kept abstract deliberately, but the implementation provides a constructor function (e.g. TCP).</p>
<p><em>Anil:</em> Sounds like this almost ready for David Sheets to pick up and have a look at for OCamlot.  We only need basic stuff for OCamlot and could build simple queues on top of this.  Is persistence like the git file format?   Thomas: yes, see <a href="http://github.com/samoht/cagit">samoht/cagit</a> for the pure-OCaml git library.</p>
<p><em>Prashanth:</em> What is the list of labels in the TREE.set function for?
<em>Answer:</em> the label list is the list of path fragments in the DAG, analogous to a filename under UNIX.</p>
<p><em>Anil:</em> points out a typo in the <code>let</code> in TG's code.  The world breaths a sigh of relief.</p>
<h3>Concurrent revisions</h3>
<p>Mort spoke about <a href="http://github.com/mor1/froctal">froctal</a>, which is a wrapper to track configuration dependencies in Mirage code. See his <a href="https://github.com/mor1/froctal">README</a> for thoughts so far.
He first looked at <a href="https://github.com/avsm/ocaml-ld">ocaml-md</a> which was toy experiment last summer to track reconfiguration and then tried Jake Donham's <a href="http://github.com/jaked/froc">Froc</a> library during ASPLOS.  Then he was thinking about what we could use FRP for in Mirage. Self-scaling web services doesn't necessarily seem to need FRP, but just simpler configuration tracking instead.</p>
<p>Anil: There's a healthy followup list of papers, specifically from MSR on <a href="http://research.microsoft.com/en-us/projects/revisions/">Concurrent Revisions</a>.  The cloud types even provide automatic reconciliation, and so are a good fit for the Irminsule model.</p>
<p>Mort then described the beginnings of an attempt of implementation of concurrent revisions, with alternate versions using modules and objects (which are closer to the original pseudocode in the paper), but is running into the hard bits of classes in OCaml.  General sounds of sympathy from the group, and advice that classes aren't necessary for many uses of objects in OCaml, and that straightforward object definitions and polymorphism might be easier instead.</p>
<p>Repos are: <a href="http://github.com/mor1/froctal">froctal</a> and <a href="http://github.com/mor1/ocaml-revisions">ocaml-revisions</a> on Mort's github.  All work-in-progress, obviously.</p>
<h4>Mirage library review</h4>
<p>Around 53 libraries in three states, with more coming in fast:</p>
<ul>
<li>Not started! (only three of these)
</li>
<li>Waiting to die! (should be broken up etc)
</li>
<li>80% finished! (need docs and interface improvements)
</li>
</ul>
<p>Anil: Note that some OCL people are working on improvements to tooling around documentation, such as <a href="http://www.cl.cam.ac.uk/projects/ocamllabs/tasks/platform.html#OPAM%20Doc">opam-doc</a>.
Should go though list of libs and define what will get done.
See the <a href="https://mirage.github.io/wiki/dev-preview-checklist">dev preview checklist</a> on the wiki for more information on progress.</p>
<h4>AoB</h4>
<p>Mort: Does anyone else have issues with tuntap on Linux?
Turns out no-one else has really tried as most of us use Tuntap on MacOS X and the Xen backend on Linux.  Vincent's ocaml-tuntap tests should be sufficient to try a unit test though.</p>
<h4>Next week:</h4>
<ul>
<li>Solidify the story with actor libraries and concurrency from the 1.0 release checklist.
</li>
<li>Figure out the SSL options for 1.0.
</li>
</ul>
|js};
      };
      {
        updated = {js|2013-04-16 16:00|js};
        author =
          {
            name = {js|Anil Madhavapeddy|js};
            uri = Some {js|http://anil.recoil.org|js};
            email = Some {js|anil@recoil.org|js};
          };
        subject = {js|Weekly Meeting: 2013-04-16|js};
        permalink = {js|weekly-2013-04-16|js};
        description = {js|16th April 2013: release, libvirt and Mirari|js};
        body =
          {js|<h3>Agenda</h3>
<ul>
<li>Anil Madhavapeddy: overview of release goals
</li>
<li>Dave Scott: libvirt and other status
</li>
<li>Vincent Bernardoff: Mirari and testing
</li>
<li>Thomas Gazagnaire: Irminsule, the storage substrate for Mirage
</li>
<li>Amir Chaudhry: xen.org incubation status and next steps
</li>
</ul>
<p><em>Attendees:</em> Thomas Gazagnaire, Vincent Bernardoff, Jonathan Ludlam, David
Sheets, David Scott, Anil Madhavapeddy, Amir Chaudhry, Prashanth Mundkur</p>
<h3>Minutes</h3>
<h4>Overview of release goals (Anil)</h4>
<p>Aim of this meeting is to clarify release goals for 1.0. We're aiming for the
OSCON 2013 talk in July, so release plan should have a stable output by June
so that we can document and stabilise.  Three concrete applications:</p>
<ul>
<li>
<p>Need stub-domains for Xenstore and Xenconsoled.  Device drivers (mainly
netfront and blkfront) should compile on both Xen and Linux to let us
swap between front-ends and back-ends as either stub-domain or dom0.</p>
</li>
<li>
<p>Self-hosting website and DNS server. Already working well now, but the
TCP stack could use some attention, as well as an SSL prototype.</p>
</li>
<li>
<p>Proof of concept of distributed system (ideally can be demo'd for OSCON).
Some strawman distributed system to start with; current thinking is something
like OCamlot or Signpost.  This would be a nice &quot;Hello world!&quot; demo as it
requires actors, a persistent job queue. For example, i.e spawning new VMs in
response to load, as evidenced by self-scaling web-server.</p>
</li>
</ul>
<p>David Sheets (working on OCamlot), asks about the place for Mirage in OCamllot.
For example would it be the dispatcher running as a Mirage kernel on &quot;the
cloud&quot; and the workers would be running as ordinary VMs? This would demonstrate
that the distributed system actually works. Anil: can discuss the details of
this later (e.g what OS are the workers using), but that's correct in
principle.  We need to split the <code>OS</code> module into a controller that is
responsible for resource provisioning, and the worker application itself.
Vincent is already working on this on the UNIX backend.</p>
<h4>Libvirt and other cloud APIs (Dave)</h4>
<p>Dave: Libvirt manages VMs on a physical host and is hypervisor-agnostic.  OCaml
bindings exist for this via Richard Jones at Red Hat, and Dave Scott has been
fixing up the Xen bindings.  We can't use it to work with EC2 or proprietary
clouds (have to use EC2 API directly there), but we could write something that
sits between if really motivated. libvirt could work with KVM and other
machines, which is a big plus when we have other hypervisor backends such as
KVM.</p>
<p>Anil: Need to investigate mapping to cloud APIs; e.g Mirage app splits into the
controller and the app that does worker as a separate VM (on Xen), or a
separate process (on UNIX), or even uses capability APIs such as Capsicum on
FreeBSD to separate the two.</p>
<p>No current fork API on Xen: that is, a VM cannot self-provision more
resources, hence the need for this controller/worker split.  This is a general
issue on the cloud, and there are several ad-hoc PV interfaces (e.g. balloon
driver).  We need to think about how the OS library interface for Mirage will
do in this space.</p>
<p><em>Decision:</em> Initial cloud APIs to target are libvirt (will cover 90% of FOSS
users as it works with <code>xm</code>) and EC2 (interesting demos and for self-hosting
website).</p>
<p>Dave: Need to make sure that libvirt works on Ubuntu and Debian.</p>
<p>Jon: asks whether configuration is still a compile-time thing.  Can also do
key exchange thing at compile time, which should be cool and avoids dynamic
secret exchange.  Anil: yes, and closely tied into Mirari (see next).</p>
<p>#### Mirari (Vincent)</p>
<p>Mirari splits workflow into config stage (<code>mirari configure</code>) which installs
OPAM dependencies, the build phase which invokes obuild, and mirari run to
execute the result.  The configure and build phases work fine, but we're
missing mirari <code>run</code> to interface with libvirt and EC2.</p>
<p>Need to think about the FRP model for configuring and keeping track of
dependencies.  It would make an awesome demo (and useful in general!) to
reconfigure server variables and recompile/launch precisely what is needed.
Question asked if anyone has used FRP for anything serious.  Silence ensues.
Followed by some sniggering. Followed by serious looks.  Mort's name is mentioned.</p>
<p>Prashanth: Does Mirari monitor VMs across multiple hosts?
Anil: Eventually yes, but not in 1.0. It keeps track of local VMs for now on
the same host and Mirari v2 will deal with tracking versions
across hosts, or on EC2.  Just libvirt for now will get us a long way in
terms of usability.</p>
<p>Jon: we need to define some goal applications for Mirage 2.0 to make all these
design decisions clearer.  Anil agrees, and suggests:</p>
<ol>
<li>
<p>Project Windsor, a dom0 free system that essentially turns xapi into a
communicating set of unikernels.</p>
</li>
<li>
<p>For Mirage website, e.g automatically reconfiguring itself from
individual to two VMs and a load balancer, and then more VMs and DNS
balancing as load increases.  This is the concept of self-scaling.   How do
we do this in the libraries?  Anil would love to demo a self-scaling webserver at
OSCON: Mort, Anil and Malte have played with this a couple of years ago, but its
not practical at the VM level without fast boots (which we have now) and careful
dependency tracking across resources and libraries.
The latency and precision we can bring is an order of magnitude better than the
current state-of-the-art, and (thanks to Dave's work on xenopsd), we have the control
stacks to glue them all together.</p>
</li>
</ol>
<p>Jon: XenServer pool-level support for these makes sense since there is already
a cluster-wide API to deal with moving across hosts.
Anil: yes, but the XAPI distributed db is a potential significant slowdown.</p>
<h4>Irminsule (Thomas)</h4>
<p>We need a storage interface (persistence) and control interface in Mirage.<br />
Branch-consistency is the lowest level we can work at without embedding
any policy in the database.  Want to have a DB that grows immutably, and then we just have a
garbage collection problem to deal with (&quot;just&quot;).</p>
<p>Goal is to have a Mirage-friendly DB with 3 scenarios:</p>
<ol>
<li>
<p>VM storage:  expose an NFS library and eventually PV blkfront that can
expose fake git directory to VM.  Not stuck at the block-level but real
filesystem-level packs.</p>
</li>
<li>
<p>Native Mirage filestore system. Needs to be lock-free as they have to run
all over the public cloud.  Irminsule designed for this.  Could use Sqlite
with data constraints but... no. Desire a more rigorous, low-level DB and
build SQL on top as necessary.</p>
</li>
<li>
<p>For the RWO book, people making comments have lost stuff as Javascript
API requires people to be online to report issues.
We can compile Irminsule down into JS and then comments can be made
locally and then sync/merged upstream.</p>
</li>
</ol>
<p>Jon: asked if you need the whole blob/tree in your browser to do the stuff
for RWO book?
Anil/Thomas: you need the graph but not the whole thing as we're not stuck to
only needing the git protocol. The low-level protocol actually supports lazy
graph traversal fine.  Anil: we can also rebase the trunk using a sliding
window scheme.</p>
<p>Jon: Targeting Xenstore may be worth considering as its a close fit to
Irminsule. Thomas points out that very close mappings between existing
transaction semantics and Xenstore (Thomas worked on both).  Anil: we can
also turn Xenstore into a cluster-wide persistent store like this, removing
a lot of XAPI complexity.</p>
<p>Prashanth: what if I want something from the subdirectory rather than root?
Thomas: Git doesn't allow this but in his implementation its possible by
delving at a lower level. Sheets: Git patches have been proposed but
rejected that permit this in git for submodules.</p>
<h4>Xenproject update (Amir)</h4>
<p>Xen.org has become a Linux Foundation project (called Xen project) and there
have been some high profile announcements so far which explicitly mention
Mirage OS so we can expect more attention being paid to the work.  There
will also be blog posts and news about Mirage being put up on Xen Project's
site and openmirage.org.</p>
<p>Anil: we all need to be looking over the installation instructions and
checking they work ok. They need refreshing and tweaking as even small
missing steps cause confusion.</p>
<h4>Any other business</h4>
<p>Jon wanted get Mirage set up as a test VM for XAPI. It does a great job
(starts and stops in no time), which is part of motivation to get start-
suspend working properly.  Anil: fuzz-testing in general is a
good thing and we can use this in all the libraries.  Balraj created a
TCP loopback VM that uses two VIFs in single VM (see mirage-skeleton/tcp).</p>
<p>Plan for next week's call: Discuss the mirari FRP integration in more detail.
Invite Daniel Bunzli to advise.</p>
|js};
      };
    ]
end

module Link = struct
  type t = {
    id : string;
    uri : string;
    title : string;
    date : string;
    stream : string;
  }

  let all =
    [
      {
        id = {js|talk-big-techday8|js};
        uri = {js|http://www.techcast.com/events/bigtechday8/salvator-1130/|js};
        title = {js|Nymote: Git your own cloud here|js};
        date = {js|2015-06-12|js};
        stream = {js|public-talk|js};
      };
      {
        id = {js|tls-podcast-ohm|js};
        uri = {js|http://monoxyd.de/20150408-ohm-008-ohne-heftige-mangel|js};
        title =
          {js|(german) OHM #008 – Ohne Heftige Mängel: TLS und dessen Probleme; robuste Implementierung von Sicherheitsprotokollen; OCaml-TLS und MirageOS|js};
        date = {js|2015-04-08|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|cam-news-nymote|js};
        uri =
          {js|http://www.cambridge-news.co.uk/personal-cloud-private-data-reality-thanks-Nymote/story-26074338-detail/story.html|js};
        title =
          {js|A personal cloud for your private data could become a reality thanks to Nymote|js};
        date = {js|2015-02-24|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|acolyer-mergeable-structures|js};
        uri =
          {js|http://blog.acolyer.org/2015/01/14/mergeable-persistent-data-structures/|js};
        title = {js|Mergeable persistent data structures|js};
        date = {js|2015-01-14|js};
        stream = {js|public-blog|js};
      };
      {
        id = {js|acolyer-unikernels|js};
        uri =
          {js|http://blog.acolyer.org/2015/01/13/unikernels-library-operating-systems-for-the-cloud/|js};
        title = {js|Unikernels: Library Operating Systems for the Cloud|js};
        date = {js|2015-01-13|js};
        stream = {js|public-blog|js};
      };
      {
        id = {js|gfx-os-tech-to-watch|js};
        uri =
          {js|http://gfxmonk.net/2015/01/04/os-technologies-to-watch.html|js};
        title = {js|OS Technologies To Watch In 2015|js};
        date = {js|2015-01-04|js};
        stream = {js|public-blog|js};
      };
      {
        id = {js|31c3-secure-modular-os-tls|js};
        uri =
          {js|http://media.ccc.de/browse/congress/2014/31c3_-_6443_-_en_-_saal_2_-_201412271245_-_trustworthy_secure_modular_operating_system_engineering_-_hannes_-_david_kaloper.html#video|js};
        title = {js|Trustworthy secure modular operating system engineering|js};
        date = {js|2014-12-27|js};
        stream = {js|public-talk|js};
      };
      {
        id = {js|oups-dec2014-state-of-mirage|js};
        uri = {js|https://www.irill.org/videos/oups-december-2014/MirageOS|js};
        title = {js|OCaml Users Paris: State of the Mirage|js};
        date = {js|2014-12-09|js};
        stream = {js|public-talk|js};
      };
      {
        id = {js|techrepublic-unikernels|js};
        uri =
          {js|http://www.techrepublic.com/article/unikernels-offer-a-stripped-down-alternative-to-linux/|js};
        title = {js|Unikernels offer a stripped down alternative to Linux|js};
        date = {js|2014-12-18|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|after-docker-immutable-infra|js};
        uri =
          {js|https://medium.com/@darrenrush/after-docker-unikernels-and-immutable-infrastructure-93d5a91c849e|js};
        title = {js|After Docker: Unikernels and Immutable Infrastructure|js};
        date = {js|2014-11-06|js};
        stream = {js|public-blog|js};
      };
      {
        id = {js|unikernels-what-where-why-awick|js};
        uri = {js|https://www.youtube.com/watch?v=oHcHTFleNtg|js};
        title =
          {js|Unikernels: Who, What, Where, When, Why - Adam Wick, Galois|js};
        date = {js|2014-10-17|js};
        stream = {js|public-talk|js};
      };
      {
        id = {js|enterprise-oss-2014|js};
        uri =
          {js|http://www.linux.com/news/software/applications/789241--5-new-enterprise-open-source-projects-to-watch/|js};
        title = {js|5 New Enterprise Open Source Projects to Watch|js};
        date = {js|2014-09-24|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|haskell-symposium-2014-keynote|js};
        uri = {js|https://www.youtube.com/watch?v=UEIHfXLMtwA|js};
        title = {js|Haskell Symposium 2014 Keynote on Unikernels|js};
        date = {js|2014-09-05|js};
        stream = {js|public-talk|js};
      };
      {
        id = {js|edge-cases-episode-101|js};
        uri =
          {js|http://edgecasesshow.com/101-a-program-that-runs-on-metal.html|js};
        title = {js|A Program That Runs on Metal|js};
        date = {js|2014-08-14|js};
        stream = {js|public-blog|js};
      };
      {
        id = {js|miso-talk-entrepreneur-first|js};
        uri =
          {js|http://amirchaudhry.com/describing-miso-entrepreneur-first-2014|js};
        title = {js|Describing the MISO stack at Entrepreneur First|js};
        date = {js|2014-07-25|js};
        stream = {js|public-blog|js};
      };
      {
        id = {js|mirage-20-pr-congoo|js};
        uri =
          {js|http://www.congoo.com/news/addstorycomment.aspx?st=291376442&Channel_ID=8&Category_ID=-1|js};
        title = {js|Xen Project Introduces New Mirage OS Release|js};
        date = {js|2014-07-22|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|mirage-20-pr-reuters|js};
        uri =
          {js|http://www.reuters.com/article/2014/07/22/idUSnMKWyFRLBa+1de+MKW20140722|js};
        title = {js|Xen Project Introduces New Mirage OS Release|js};
        date = {js|2014-07-22|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|mirage-20-pr-phoronix|js};
        uri = {js|http://www.phoronix.com/scan.php?page=news_item&px=MTc0NjY|js};
        title = {js|Xen Project Announces Mirage OS 2.0|js};
        date = {js|2014-07-22|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|mirage-20-pr-linux-embedded|js};
        uri =
          {js|https://www.linux.com/news/embedded-mobile/mobile-linux/781359-xen-project-announces-mirage-os-20|js};
        title = {js|Xen Project Announces Mirage OS 2.0|js};
        date = {js|2014-07-22|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|mirage-20-pr-slashdot|js};
        uri =
          {js|http://beta.slashdot.org/submission/3717339/news-mirage-os-20----compile-your-own-cloud|js};
        title = {js|News: Mirage OS 2.0 -- Compile Your Own Cloud|js};
        date = {js|2014-07-22|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|mirage-20-pr-vmblog|js};
        uri =
          {js|http://vmblog.com/archive/2014/07/22/xen-project-introduces-new-mirage-os-release.aspx|js};
        title = {js|Xen Project Introduces New Mirage OS Release|js};
        date = {js|2014-07-22|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|mirage-20-pr-lastminutegeek|js};
        uri =
          {js|http://www.lastminutegeek.com/english/77-linuxtoday/1151651-mirage-os-v20-the-new-features.html|js};
        title = {js|Mirage OS v2.0: The new features|js};
        date = {js|2014-07-22|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|mirage-20-pr-techinvestornews|js};
        uri =
          {js|http://www.techinvestornews.com/Cloud/Latest-Cloud-Computing-News/xen-unveils-mirage-os-2.0-for-open-source-virtual-cloud-apps|js};
        title =
          {js|Xen Unveils Mirage OS 2.0 for Open Source Virtual Cloud Apps|js};
        date = {js|2014-07-22|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|mirage-20-pr-slashdot-2|js};
        uri =
          {js|http://beta.slashdot.org/submission/3720459/xen-unveils-mirage-os-20-for-open-source-virtual-cloud-apps|js};
        title =
          {js|Xen Unveils Mirage OS 2.0 for Open Source Virtual Cloud Apps|js};
        date = {js|2014-07-22|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|mirage-20-pr-linuxtoday|js};
        uri =
          {js|http://www.linuxtoday.com/high_performance/mirage-os-v2.0-the-new-features.html|js};
        title = {js|Mirage OS v2.0: The new features|js};
        date = {js|2014-07-23|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|mirage-20-pr-twit|js};
        uri = {js|https://plus.google.com/+TWiT/posts/6DkCPz3TSdd|js};
        title = {js|FLOSS Weekly 302 | TWiT.TV|js};
        date = {js|2014-07-23|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|mirage-20-pr-cloudcomputinginfo|js};
        uri =
          {js|http://cloudcomputing.info/en/news/2014/07/xen-project-releases-mirage-os-2-0.html|js};
        title = {js|Xen Project releases Mirage OS 2.0|js};
        date = {js|2014-07-23|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|mirage-20-pr-vibriefing|js};
        uri =
          {js|http://www.vibriefing.com/xen-unveils-mirage-os-2-0-for-open-source-virtual-cloud-apps/|js};
        title =
          {js|Xen Unveils Mirage OS 2.0 for Open Source Virtual Cloud Apps|js};
        date = {js|2014-07-25|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|mirage-20-pr-marketwatch|js};
        uri =
          {js|http://www.marketwatch.com/story/xen-project-introduces-new-mirage-os-release-2014-07-22|js};
        title = {js|Xen Project Introduces New Mirage OS Release|js};
        date = {js|2014-07-22|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|mirage-20-pr-linuxquestions|js};
        uri =
          {js|http://www.linuxquestions.org/questions/syndicated-linux-news-67/lxer-xen-unveils-mirage-os-2-0-for-open-source-virtual-cloud-apps-4175512075/|js};
        title =
          {js|LXer: Xen Unveils Mirage OS 2.0 for Open Source Virtual Cloud Apps|js};
        date = {js|2014-07-22|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|mirage-20-pr-4-traders|js};
        uri =
          {js|http://www.4-traders.com/news/Xen-Project-Introduces-New-Mirage-OS-Release--18774589/|js};
        title = {js| Xen Project Introduces New Mirage OS Release|js};
        date = {js|2014-07-22|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|mirage-20-pr-release|js};
        uri =
          {js|http://www.marketwired.com/press-release/xen-project-introduces-new-mirage-os-release-1931602.htm|js};
        title = {js|Xen Project Introduces New Mirage OS Release|js};
        date = {js|2014-07-22|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|yahoo-pr-mirage-20-release|js};
        uri =
          {js|http://finance.yahoo.com/news/xen-project-introduces-mirage-os-120000542.html|js};
        title =
          {js|Yahoo Finance - Xen Project Introduces New Mirage OS Release|js};
        date = {js|2014-07-22|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|cloud-computing-mirage-20|js};
        uri =
          {js|http://cloudcomputing.info/en/news/2014/07/xen-project-releases-mirage-os-2-0.html|js};
        title = {js|CloudComputing - Xen Project releases Mirage OS 2.0|js};
        date = {js|2014-07-22|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|xenblog-mirage-20-release|js};
        uri =
          {js|http://blog.xen.org/index.php/2014/07/22/mirage-os-v2-0-the-new-features/|js};
        title = {js|XenBlog: Mirage OS v2.0: The new features|js};
        date = {js|2014-07-22|js};
        stream = {js|public-blog|js};
      };
      {
        id = {js|varguy-mirage-20-release|js};
        uri =
          {js|http://thevarguy.com/virtualization-applications-and-technologies/072314/xen-unveils-mirage-os-20-open-source-virtual-cloud-apps|js};
        title =
          {js|Xen Unveils Mirage OS 2.0 for Open Source Virtual Cloud Apps|js};
        date = {js|2014-07-23|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|mirage-20-release-linux-magazin-de|js};
        uri =
          {js|http://www.linux-magazin.de/NEWS/Ocaml-Cloud-OS-Mirage-OS-2.0-erhoeht-Sicherheit|js};
        title = {js|(german) OCaml-Cloud-OS Mirage OS 2.0 erhöht Sicherheit|js};
        date = {js|2014-07-23|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|mirage-20-release-yc-isvoc|js};
        uri =
          {js|http://yc.isvoc.com/201407231852-xen-project-introduces-new-mirage-os-release.html#.U9AWkhZD3nc|js};
        title = {js|(chinese) Xen项目推出新的幻影操作系统版本|js};
        date = {js|2014-07-23|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|mirage-20-release-admin-magazin-de|js};
        uri =
          {js|http://www.admin-magazin.de/News/Mirage-OS-2.0-veroeffentlicht|js};
        title = {js|(german) Mirage OS 2.0 veröffentlicht|js};
        date = {js|2014-07-22|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|bww-mirage-20-release|js};
        uri =
          {js|http://www.broadwayworld.com/bwwgeeks/article/Xen-Project-Introduces-New-Mirage-OS-Release-20140722#.U9AX5xZD3nc|js};
        title = {js|BWW: Xen Project Introduces New Mirage OS Release|js};
        date = {js|2014-07-22|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|open-source-china-mirage-20-release|js};
        uri = {js|http://www.oschina.net/news/53851/mirage-os-2-0-released|js};
        title = {js|(chinese) Mirage OS 2.0 发布，云编程平台|js};
        date = {js|2014-07-23|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|seedhack-experience|js};
        uri = {js|http://seedcamp.com/seedhack-5-0/|js};
        title = {js|The Seedhack Experience|js};
        date = {js|2014-07-23|js};
        stream = {js|public-blog|js};
      };
      {
        id = {js|hn-introducing-irmin|js};
        uri = {js|https://news.ycombinator.com/item?id=8053687|js};
        title = {js|HN: Irmin: Git-like distributed, branchable storage|js};
        date = {js|2014-07-18|js};
        stream = {js|hackernews|js};
      };
      {
        id = {js|hn-introducing-asn1|js};
        uri = {js|https://news.ycombinator.com/item?id=8020125|js};
        title = {js|HN: OCaml-TLS: ASN.1 and notation embedding|js};
        date = {js|2014-07-11|js};
        stream = {js|hackernews|js};
      };
      {
        id = {js|hn-mirage-os-unikernel-for-xen-hypervisor|js};
        uri = {js|https://news.ycombinator.com/item?id=7726748|js};
        title = {js|HN: Mirage OS: A Unikernel For The Xen Hypervisor|js};
        date = {js|2014-05-10|js};
        stream = {js|hackernews|js};
      };
      {
        id = {js|hn-ocaml-tls-api-internals-attacks-mitigation|js};
        uri = {js|https://news.ycombinator.com/item?id=8031368|js};
        title =
          {js|HN: OCaml-TLS: the protocol implementation and mitigations to known attacks|js};
        date = {js|2014-07-14|js};
        stream = {js|hackernews|js};
      };
      {
        id = {js|hn-announcing-mirage-20-release|js};
        uri = {js|https://news.ycombinator.com/item?id=8069132|js};
        title = {js|HN: Mirage v2.0: a recap of the new features|js};
        date = {js|2014-07-22|js};
        stream = {js|hackernews|js};
      };
      {
        id = {js|hn-acm-queue-01|js};
        uri = {js|https://news.ycombinator.com/item?id=7053638|js};
        title =
          {js|HN: Unikernels: Rise of the Virtual Library Operating System|js};
        date = {js|2014-01-14|js};
        stream = {js|hackernews|js};
      };
      {
        id = {js|hn-acm-queue-02|js};
        uri = {js|https://news.ycombinator.com/item?id=8025493|js};
        title =
          {js|HN: Unikernels: Rise of the Virtual Library Operating System|js};
        date = {js|2014-07-12|js};
        stream = {js|hackernews|js};
      };
      {
        id = {js|hn-introducing-tls|js};
        uri = {js|https://news.ycombinator.com/item?id=8005130|js};
        title = {js|HN: Introducing Transport Layer Security in pure OCaml|js};
        date = {js|2014-07-08|js};
        stream = {js|hackernews|js};
      };
      {
        id = {js|digital-conversations-2014|js};
        uri =
          {js|http://www.brondbjerg.co.uk/blog/2014/06/building-the-next-generation-of-the-web/|js};
        title =
          {js|Digital Conversations - Building the Next Generation of the Web|js};
        date = {js|2014-06-12|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|linux-magazin-de-zero-install|js};
        uri =
          {js|http://www.linux-magazin.de/Ausgaben/2014/06/Ocaml/%28language%29/ger-DE/|js};
        title = {js|Programmieren in OCaml (German)|js};
        date = {js|2014-06-01|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|se-radio-2014|js};
        uri =
          {js|http://www.se-radio.net/2014/05/episode-204-anil-madhavapeddy-on-the-mirage-cloud-operating-system-and-the-ocaml-language/|js};
        title =
          {js|Software Engineering Radio: podcast on MirageOS and OCaml with Anil Madhavapeddy|js};
        date = {js|2014-05-30|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|nw-lang-mirageos|js};
        uri =
          {js|http://www.networkworld.com/slideshow/149127/beyond-the-usual-suspects-10-hot-programming-languages-on-the-rise.html#slide10|js};
        title =
          {js|Beyond the usual suspects: 10 hot programming languages on the rise|js};
        date = {js|2014-04-17|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|citirx-containers-xen|js};
        uri =
          {js|http://open.citrix.com/blog/328-are-containers-the-right-answer-to-the-wrong-question.html|js};
        title = {js|Are Containers the Right Answer to the Wrong Question?|js};
        date = {js|2014-04-08|js};
        stream = {js|public-blog|js};
      };
      {
        id = {js|mindy-unikernel-1|js};
        uri =
          {js|http://www.somerandomidiot.com/blog/2014/03/14/its-a-mirage/|js};
        title = {js|It's a Mirage! (or, How to Shave a Yak.)|js};
        date = {js|2014-03-14|js};
        stream = {js|public-blog|js};
      };
      {
        id = {js|amirmc-jekyll-1|js};
        uri =
          {js|http://amirchaudhry.com/from-jekyll-to-unikernel-in-fifty-lines|js};
        title = {js|From Jekyll site to Unikernel in fifty lines of code|js};
        date = {js|2014-03-10|js};
        stream = {js|public-blog|js};
      };
      {
        id = {js|pcworld-2014-xenarm|js};
        uri =
          {js|http://www.pcworld.com/article/2106460/xen-hypervisor-moves-into-arm-space.html|js};
        title = {js|Xen hypervisor moves into ARM space|js};
        date = {js|2014-03-10|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|fosdem-2014-video|js};
        uri =
          {js|http://video.fosdem.org/2014/Janson/Sunday/MirageOS_compiling_functional_library_operating_systems.webm|js};
        title =
          {js|FOSDEM 2014: MirageOS: compiling functional library operating systems|js};
        date = {js|2014-02-02|js};
        stream = {js|public-talk|js};
      };
      {
        id = {js|fosdem-2014|js};
        uri =
          {js|https://fosdem.org/2014/interviews/2014-anil-madhavapeddy-richard-mortier/|js};
        title =
          {js|Interview with Anil Madhavapeddy and Richard Mortier on MirageOS|js};
        date = {js|2014-01-29|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|osnews-2014|js};
        uri =
          {js|http://www.osnews.com/comments/27516?view=threaded&sort=&threshold=0|js};
        title =
          {js|OSNews: MirageOS: rise of the virtual library operating system|js};
        date = {js|2014-01-15|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|nymote-mirage-ann-2014|js};
        uri =
          {js|http://nymote.org/blog/2014/announcing-first-mirage-release/|js};
        title =
          {js|Nymote.org: Announcing the first major release of Mirage - the Cloud Operating System|js};
        date = {js|2014-01-13|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|infoworld-mirage-2014|js};
        uri =
          {js|http://www.infoworld.com/t/operating-systems/xen-mirage-the-less-more-cloud-os-233823|js};
        title = {js|Xen Mirage: The less-is-more cloud OS|js};
        date = {js|2014-01-09|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|infoq-rwo-2013|js};
        uri = {js|http://www.infoq.com/articles/real-world-ocaml-interview|js};
        title = {js|Book Review and Interview: Real World OCaml|js};
        date = {js|2014-01-08|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|techweek-europe-2013|js};
        uri =
          {js|http://www.techweekeurope.co.uk/comment/xen-launches-mirage-cloud-os-133875|js};
        title = {js|Xen Launches The Mirage Cloud OS|js};
        date = {js|2013-12-11|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|linuxcom-cloud-os-2013|js};
        uri =
          {js|http://www.linux.com/news/enterprise/cloud-computing/751156-are-cloud-operating-systems-the-next-big-thing-|js};
        title =
          {js|Linux.com: Are Cloud Operating Systems the Next Big Thing?|js};
        date = {js|2013-12-03|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|infoq-mirageos-2013|js};
        uri = {js|http://www.infoq.com/news/2013/12/mirageos|js};
        title = {js|InfoQ: Xen Project Releases 1.0 of Mirage OS|js};
        date = {js|2013-12-23|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|eweek-mirageos-2013|js};
        uri =
          {js|http://www.eweek.com/cloud/xen-project-builds-its-own-cloud-os-mirage.html/|js};
        title = {js|eWeek: Xen Project Builds Its Own Cloud OS Mirage|js};
        date = {js|2013-12-09|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|xenproject-mirageos-2013|js};
        uri =
          {js|http://www.xenproject.org/about/in-the-news/162-xen-project-releases-mirage-os-welcomes-arm-as-newest-member.html|js};
        title =
          {js|Xen Project Releases Mirage OS, Welcomes ARM as Newest Member|js};
        date = {js|2013-12-09|js};
        stream = {js|press-coverage|js};
      };
      {
        id = {js|voxoz-docker-2013|js};
        uri =
          {js|http://blog.docker.io/2013/09/powering-voxoz-ecosystem-with-docker/|js};
        title = {js|Powering Voxoz ecosystem with Docker|js};
        date = {js|2013-09-26|js};
        stream = {js|public-blog|js};
      };
    ]
end

module Paper = struct
  type link = { description : string; uri : string }

  type t = {
    name : string;
    title : string;
    links : link list;
    authors : string list;
    description : string;
    abstract : string;
  }

  let all =
    [
      {
        name = {js|cacm|js};
        title = {js|Unikernels: Rise of the Virtual Library Operating System|js};
        links =
          [
            {
              description = {js|Read Online|js};
              uri = {js|http://queue.acm.org/detail.cfm?id=2566628|js};
            };
          ];
        authors = [ {js|Anil Madhavapeddy|js}; {js|David Scott|js} ];
        description = {js|In Communications of the ACM, January 2014.|js};
        abstract =
          {js|What if all the software layers in a virtual appliance were compiled within the same safe, high-level language framework?
|js};
      };
      {
        name = {js|rwo|js};
        title = {js|Real World OCaml: functional programming for the masses|js};
        links =
          [
            {
              description = {js|Read Online|js};
              uri = {js|https://realworldocaml.org|js};
            };
          ];
        authors =
          [
            {js|Anil Madhavapeddy|js};
            {js|Yaron Minsky|js};
            {js|Jason Hickey|js};
          ];
        description =
          {js|Published by O'Reilly Associates, 510 pages, Nov 2013.|js};
        abstract =
          {js|This fast-moving tutorial introduces you to OCaml, an industrial-strength programming language designed for expressiveness, safety, and speed. Through the book’s many examples, you’ll quickly learn how OCaml stands out as a tool for writing fast, succinct, and readable systems code. Real World OCaml takes you through the concepts of the language at a brisk pace, and then helps you explore the tools and techniques that make OCaml an effective and practical tool. In the book’s third section, you’ll delve deep into the details of the compiler toolchain and OCaml’s simple and efficient runtime system.
|js};
      };
      {
        name = {js|asplos|js};
        title = {js|Unikernels: library operating systems for the cloud|js};
        links =
          [
            {
              description = {js|Download PDF|js};
              uri = {js|http://anil.recoil.org/papers/2013-asplos-mirage.pdf|js};
            };
          ];
        authors =
          [
            {js|Anil Madhavapeddy|js};
            {js|Richard Mortier|js};
            {js|Charalampos Rotsos|js};
            {js|David Scott|js};
            {js|Balraj Singh|js};
            {js|Thomas Gazagnaire|js};
            {js|Steven Smith|js};
            {js|Steven Hand|js};
            {js|Jon Crowcroft|js};
          ];
        description =
          {js|Proceedings of the 18th International Conference on Architectural Support for Programming Languages and Operating Systems ASPLOS '13, April, 2013.|js};
        abstract =
          {js|We present <em>unikernels</em>, a new approach to deploying cloud services via applications written in high-level source code. Unikernels are single-purpose appliances that are compile-time specialised into standalone kernels, and sealed against modification when deployed to a cloud platform. In return they offer significant reduction in image sizes, improved efficiency and security, and should reduce operational costs. Our MirageOS prototype compiles OCaml code into unikernels that run on commodity clouds and offer an order of magnitude reduction in code size without significant performance penalty. The architecture combines static type-safety with a single address-space layout that can be made immutable via a hypervisor extension. MirageOS contributes a suite of type-safe protocol libraries, and our results demonstrate that the hypervisor is a platform that overcomes the hardware compatibility issues that have made past library operating systems impractical to deploy in the real-world.
|js};
      };
      {
        name = {js|openflow|js};
        title = {js|Cost, Performance & Flexibility in OpenFlow: Pick Three|js};
        links =
          [
            {
              description = {js|Download PDF|js};
              uri =
                {js|http://www.cs.nott.ac.uk/~rmm/papers/pdf/iccsdn12-mirageof.pdf|js};
            };
          ];
        authors =
          [
            {js|Richard Mortier|js};
            {js|Charalampos Rotsos|js};
            {js|Anil Madhavapeddy|js};
            {js|Balraj Singh|js};
            {js|Andrew Moore|js};
          ];
        description =
          {js|Proceedings of IEEE ICC Software Defined Networking workshop, June 2012.|js};
        abstract = {js|...
|js};
      };
      {
        name = {js|droplets|js};
        title = {js|Unclouded Vision|js};
        links =
          [
            {
              description = {js|Download PDF|js};
              uri =
                {js|http://www.cs.nott.ac.uk/~rmm/papers/pdf/icdcn11-droplets.pdf|js};
            };
          ];
        authors =
          [
            {js|Jon Crowcroft|js};
            {js|Anil Madhavapeddy|js};
            {js|Malte Schwarzkopf|js};
            {js|Theo Hong|js};
            {js|Richard Mortier|js};
          ];
        description =
          {js|Proceedings of 12th International Conference on Distributed Computing and Networking ICDCN '11, January 2011. Invited paper.|js};
        abstract = {js|...
|js};
      };
      {
        name = {js|hotcloud|js};
        title =
          {js|Turning down the LAMP: Software Specialisation for the Cloud|js};
        links =
          [
            {
              description = {js|Download PDF|js};
              uri = {js|http://anil.recoil.org/papers/2010-hotcloud-lamp.pdf|js};
            };
          ];
        authors =
          [
            {js|Anil Madhavapeddy|js};
            {js|Richard Mortier|js};
            {js|Ripduman Sohan|js};
            {js|Thomas Gazagnaire|js};
            {js|Steven Hand|js};
            {js|Tim Deegan|js};
            {js|Derek McAuley|js};
            {js|Jon Crowcroft|js};
          ];
        description =
          {js|2nd USENIX Workshop on Hot Topics in Cloud Computing HotCloud '10, June 2010.|js};
        abstract =
          {js|This paper positions work on the Xen backend for MirageOS. It is a decent summary of the idea, although some details such as the filesystem extension are likely to be significantly different in the first release.
|js};
      };
      {
        name = {js|dustclouds|js};
        title = {js|Using Dust Clouds to Enhance Anonymous Communication|js};
        links =
          [
            {
              description = {js|Download PDF|js};
              uri =
                {js|http://www.cs.nott.ac.uk/~rmm/papers/pdf/iwsp10-dustclouds.pdf|js};
            };
          ];
        authors =
          [
            {js|Richard Mortier|js};
            {js|Anil Madhavapeddy|js};
            {js|Theo Hong|js};
            {js|Derek Murray|js};
            {js|Malte Schwarzkopf|js};
          ];
        description =
          {js|Proceedings of the 18th International Workshop on Security Protocols (IWSP), April 2010|js};
        abstract = {js|...
|js};
      };
      {
        name = {js|visions|js};
        title =
          {js|Multiscale not Multicore: Efficient Heterogeneous Cloud Computing|js};
        links =
          [
            {
              description = {js|Download PDF|js};
              uri = {js|http://anil.recoil.org/papers/2010-bcs-visions.pdf|js};
            };
            {
              description = {js|BCS Homepage|js};
              uri = {js|http://www.bcs.org/server.php?show=nav.11980|js};
            };
          ];
        authors =
          [
            {js|Anil Madhavapeddy|js};
            {js|Richard Mortier|js};
            {js|Jon Crowcroft|js};
            {js|Steven Hand|js};
          ];
        description = {js|ACM/BCS Visions of Computer Science, April 2010|js};
        abstract =
          {js|This is a vision paper that lays out the broader background to the project, including some of the problem areas we are tackling in social networking and scientific computing. The first half is a good introduction to the area, but read the later HotCloud paper instead of the technical second half.
|js};
      };
      {
        name = {js|wgt|js};
        title = {js|Statically-typed value persistence for ML|js};
        links =
          [
            {
              description = {js|Download PDF|js};
              uri = {js|http://anil.recoil.org/papers/2010-dyntype-wgt.pdf|js};
            };
            {
              description = {js|Prezy Presentation|js};
              uri = {js|http://prezi.com/qjkrijlacqiq/mirage/|js};
            };
          ];
        authors = [ {js|Thomas Gazagnaire|js}; {js|Anil Madhavapeddy|js} ];
        description = {js|Workshop on Generative Technologies, April 2010|js};
        abstract =
          {js|This paper defines the dyntype dynamic typing extension we developed for OCaml, and the SQL mapper that converts ML values directly into SQL calls. The approach is useful as it is purely meta-programming instead of compiler patching, and thus much easier to integrate with other OCaml code.
|js};
      };
      {
        name = {js|icfem|js};
        title =
          {js|Combining Static Model Checking with Dynamic Enforcement using the Statecall Policy Language|js};
        links =
          [
            {
              description = {js|Download PDF|js};
              uri = {js|http://anil.recoil.org/papers/2009-icfem-spl.pdf|js};
            };
          ];
        authors = [ {js|Anil Madhavapeddy|js} ];
        description =
          {js|International Conference on Formal Engineering Methods ICFEM, December 2009.|js};
        abstract =
          {js|A small domain-specific language which compiles to both PROMELA (for static model checking) and OCaml (for dynamic enforcement) of state machines. This paper defines the DSL and an example against an SSH server written in pure OCaml.
|js};
      };
      {
        name = {js|eurosys|js};
        title = {js|Melange: Towards a "functional" Internet|js};
        links =
          [
            {
              description = {js|Download PDF|js};
              uri =
                {js|http://anil.recoil.org/papers/2007-eurosys-melange.pdf|js};
            };
            {
              description = {js|ACM Portal|js};
              uri =
                {js|http://portal.acm.org/citation.cfm?id=1272996.1273009|js};
            };
          ];
        authors =
          [
            {js|Anil Madhavapeddy|js};
            {js|Alex Ho|js};
            {js|Tim Deegan|js};
            {js|David Scott|js};
            {js|Ripduman Sohan|js};
          ];
        description = {js|EuroSys 2007, March 2007.|js};
        abstract =
          {js|The original paper that formed the basis of MirageOS. We define MPL, a DSL to express bi-directional packet descriptions and compile them into efficient, type-safe OCaml code. Performance is tested for DNS and SSH servers written in OCaml versus their C counterparts (BIND and OpenSSH
|js};
      };
      {
        name = {js|mainname|js};
        title = {js|The Main Name System|js};
        links =
          [
            {
              description = {js|Download PDF|js};
              uri = {js|http://www.tjd.phlegethon.org/words/thesis.pdf|js};
            };
          ];
        authors = [ {js|Tim Deegan|js} ];
        description = {js|PhD Thesis, University of Cambridge, 2006.|js};
        abstract =
          {js|This thesis describes the Main Name System, an approach to centralising DNS for improved reliability. The source code for the MirageOS DNS library is based directly off the data structures described in this thesis.
|js};
      };
    ]
end
